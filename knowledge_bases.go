// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	time "time"
)

type KnowledgeBasesListRequest struct {
	// This is the maximum number of items to return. Defaults to 100.
	Limit *float64 `json:"-" url:"limit,omitempty"`
	// This will return items where the createdAt is greater than the specified value.
	CreatedAtGt *time.Time `json:"-" url:"createdAtGt,omitempty"`
	// This will return items where the createdAt is less than the specified value.
	CreatedAtLt *time.Time `json:"-" url:"createdAtLt,omitempty"`
	// This will return items where the createdAt is greater than or equal to the specified value.
	CreatedAtGe *time.Time `json:"-" url:"createdAtGe,omitempty"`
	// This will return items where the createdAt is less than or equal to the specified value.
	CreatedAtLe *time.Time `json:"-" url:"createdAtLe,omitempty"`
	// This will return items where the updatedAt is greater than the specified value.
	UpdatedAtGt *time.Time `json:"-" url:"updatedAtGt,omitempty"`
	// This will return items where the updatedAt is less than the specified value.
	UpdatedAtLt *time.Time `json:"-" url:"updatedAtLt,omitempty"`
	// This will return items where the updatedAt is greater than or equal to the specified value.
	UpdatedAtGe *time.Time `json:"-" url:"updatedAtGe,omitempty"`
	// This will return items where the updatedAt is less than or equal to the specified value.
	UpdatedAtLe *time.Time `json:"-" url:"updatedAtLe,omitempty"`
}

type CreateTrieveKnowledgeBaseDto struct {
	// This is the name of the knowledge base.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the searching plan used when searching for relevant chunks from the vector store.
	//
	// You should configure this if you're running into these issues:
	// - Too much unnecessary context is being fed as knowledge base context.
	// - Not enough relevant context is being fed as knowledge base context.
	SearchPlan *TrieveKnowledgeBaseSearchPlan `json:"searchPlan,omitempty" url:"searchPlan,omitempty"`
	// This is the plan if you want us to create/import a new vector store using Trieve.
	CreatePlan *CreateTrieveKnowledgeBaseDtoCreatePlan `json:"createPlan,omitempty" url:"createPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTrieveKnowledgeBaseDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTrieveKnowledgeBaseDto) GetSearchPlan() *TrieveKnowledgeBaseSearchPlan {
	if c == nil {
		return nil
	}
	return c.SearchPlan
}

func (c *CreateTrieveKnowledgeBaseDto) GetCreatePlan() *CreateTrieveKnowledgeBaseDtoCreatePlan {
	if c == nil {
		return nil
	}
	return c.CreatePlan
}

func (c *CreateTrieveKnowledgeBaseDto) Provider() string {
	return c.provider
}

func (c *CreateTrieveKnowledgeBaseDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTrieveKnowledgeBaseDto) UnmarshalJSON(data []byte) error {
	type embed CreateTrieveKnowledgeBaseDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTrieveKnowledgeBaseDto(unmarshaler.embed)
	if unmarshaler.Provider != "trieve" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "trieve", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTrieveKnowledgeBaseDto) MarshalJSON() ([]byte, error) {
	type embed CreateTrieveKnowledgeBaseDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "trieve",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTrieveKnowledgeBaseDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the plan if you want us to create/import a new vector store using Trieve.
type CreateTrieveKnowledgeBaseDtoCreatePlan struct {
	TrieveKnowledgeBaseCreate *TrieveKnowledgeBaseCreate
	TrieveKnowledgeBaseImport *TrieveKnowledgeBaseImport

	typ string
}

func (c *CreateTrieveKnowledgeBaseDtoCreatePlan) GetTrieveKnowledgeBaseCreate() *TrieveKnowledgeBaseCreate {
	if c == nil {
		return nil
	}
	return c.TrieveKnowledgeBaseCreate
}

func (c *CreateTrieveKnowledgeBaseDtoCreatePlan) GetTrieveKnowledgeBaseImport() *TrieveKnowledgeBaseImport {
	if c == nil {
		return nil
	}
	return c.TrieveKnowledgeBaseImport
}

func (c *CreateTrieveKnowledgeBaseDtoCreatePlan) UnmarshalJSON(data []byte) error {
	valueTrieveKnowledgeBaseCreate := new(TrieveKnowledgeBaseCreate)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBaseCreate); err == nil {
		c.typ = "TrieveKnowledgeBaseCreate"
		c.TrieveKnowledgeBaseCreate = valueTrieveKnowledgeBaseCreate
		return nil
	}
	valueTrieveKnowledgeBaseImport := new(TrieveKnowledgeBaseImport)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBaseImport); err == nil {
		c.typ = "TrieveKnowledgeBaseImport"
		c.TrieveKnowledgeBaseImport = valueTrieveKnowledgeBaseImport
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTrieveKnowledgeBaseDtoCreatePlan) MarshalJSON() ([]byte, error) {
	if c.typ == "TrieveKnowledgeBaseCreate" || c.TrieveKnowledgeBaseCreate != nil {
		return json.Marshal(c.TrieveKnowledgeBaseCreate)
	}
	if c.typ == "TrieveKnowledgeBaseImport" || c.TrieveKnowledgeBaseImport != nil {
		return json.Marshal(c.TrieveKnowledgeBaseImport)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTrieveKnowledgeBaseDtoCreatePlanVisitor interface {
	VisitTrieveKnowledgeBaseCreate(*TrieveKnowledgeBaseCreate) error
	VisitTrieveKnowledgeBaseImport(*TrieveKnowledgeBaseImport) error
}

func (c *CreateTrieveKnowledgeBaseDtoCreatePlan) Accept(visitor CreateTrieveKnowledgeBaseDtoCreatePlanVisitor) error {
	if c.typ == "TrieveKnowledgeBaseCreate" || c.TrieveKnowledgeBaseCreate != nil {
		return visitor.VisitTrieveKnowledgeBaseCreate(c.TrieveKnowledgeBaseCreate)
	}
	if c.typ == "TrieveKnowledgeBaseImport" || c.TrieveKnowledgeBaseImport != nil {
		return visitor.VisitTrieveKnowledgeBaseImport(c.TrieveKnowledgeBaseImport)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CustomKnowledgeBase struct {
	// This is where the knowledge base request will be sent.
	//
	// Request Example:
	//
	// POST https://{server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "messsage": {
	//	    "type": "knowledge-base-request",
	//	    "messages": [
	//	      {
	//	        "role": "user",
	//	        "content": "Why is ocean blue?"
	//	      }
	//	    ],
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// Response Expected:
	// ```
	//
	//	{
	//	  "message": {
	//	     "role": "assistant",
	//	     "content": "The ocean is blue because water absorbs everything but blue.",
	//	  }, // YOU CAN RETURN THE EXACT RESPONSE TO SPEAK
	//	  "documents": [
	//	    {
	//	      "content": "The ocean is blue primarily because water absorbs colors in the red part of the light spectrum and scatters the blue light, making it more visible to our eyes.",
	//	      "similarity": 1
	//	    },
	//	    {
	//	      "content": "Blue light is scattered more by the water molecules than other colors, enhancing the blue appearance of the ocean.",
	//	      "similarity": .5
	//	    }
	//	  ] // OR, YOU CAN RETURN AN ARRAY OF DOCUMENTS THAT WILL BE SENT TO THE MODEL
	//	}
	//
	// ```
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the id of the knowledge base.
	Id string `json:"id" url:"id"`
	// This is the org id of the knowledge base.
	OrgId    string `json:"orgId" url:"orgId"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomKnowledgeBase) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CustomKnowledgeBase) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CustomKnowledgeBase) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CustomKnowledgeBase) Provider() string {
	return c.provider
}

func (c *CustomKnowledgeBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomKnowledgeBase) UnmarshalJSON(data []byte) error {
	type embed CustomKnowledgeBase
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomKnowledgeBase(unmarshaler.embed)
	if unmarshaler.Provider != "custom-knowledge-base" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-knowledge-base", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomKnowledgeBase) MarshalJSON() ([]byte, error) {
	type embed CustomKnowledgeBase
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-knowledge-base",
	}
	return json.Marshal(marshaler)
}

func (c *CustomKnowledgeBase) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type TrieveKnowledgeBase struct {
	// This is the name of the knowledge base.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the searching plan used when searching for relevant chunks from the vector store.
	//
	// You should configure this if you're running into these issues:
	// - Too much unnecessary context is being fed as knowledge base context.
	// - Not enough relevant context is being fed as knowledge base context.
	SearchPlan *TrieveKnowledgeBaseSearchPlan `json:"searchPlan,omitempty" url:"searchPlan,omitempty"`
	// This is the plan if you want us to create/import a new vector store using Trieve.
	CreatePlan *TrieveKnowledgeBaseCreatePlan `json:"createPlan,omitempty" url:"createPlan,omitempty"`
	// This is the id of the knowledge base.
	Id string `json:"id" url:"id"`
	// This is the org id of the knowledge base.
	OrgId    string `json:"orgId" url:"orgId"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TrieveKnowledgeBase) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TrieveKnowledgeBase) GetSearchPlan() *TrieveKnowledgeBaseSearchPlan {
	if t == nil {
		return nil
	}
	return t.SearchPlan
}

func (t *TrieveKnowledgeBase) GetCreatePlan() *TrieveKnowledgeBaseCreatePlan {
	if t == nil {
		return nil
	}
	return t.CreatePlan
}

func (t *TrieveKnowledgeBase) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TrieveKnowledgeBase) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TrieveKnowledgeBase) Provider() string {
	return t.provider
}

func (t *TrieveKnowledgeBase) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TrieveKnowledgeBase) UnmarshalJSON(data []byte) error {
	type embed TrieveKnowledgeBase
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TrieveKnowledgeBase(unmarshaler.embed)
	if unmarshaler.Provider != "trieve" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "trieve", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrieveKnowledgeBase) MarshalJSON() ([]byte, error) {
	type embed TrieveKnowledgeBase
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "trieve",
	}
	return json.Marshal(marshaler)
}

func (t *TrieveKnowledgeBase) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TrieveKnowledgeBaseChunkPlan struct {
	// These are the file ids that will be used to create the vector store. To upload files, use the `POST /files` endpoint.
	FileIds []string `json:"fileIds,omitempty" url:"fileIds,omitempty"`
	// These are the websites that will be used to create the vector store.
	Websites []string `json:"websites,omitempty" url:"websites,omitempty"`
	// This is an optional field which allows you to specify the number of splits you want per chunk. If not specified, the default 20 is used. However, you may want to use a different number.
	TargetSplitsPerChunk *float64 `json:"targetSplitsPerChunk,omitempty" url:"targetSplitsPerChunk,omitempty"`
	// This is an optional field which allows you to specify the delimiters to use when splitting the file before chunking the text. If not specified, the default [.!?\n] are used to split into sentences. However, you may want to use spaces or other delimiters.
	SplitDelimiters []string `json:"splitDelimiters,omitempty" url:"splitDelimiters,omitempty"`
	// This is an optional field which allows you to specify whether or not to rebalance the chunks created from the file. If not specified, the default true is used. If true, Trieve will evenly distribute remainder splits across chunks such that 66 splits with a target_splits_per_chunk of 20 will result in 3 chunks with 22 splits each.
	RebalanceChunks *bool `json:"rebalanceChunks,omitempty" url:"rebalanceChunks,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TrieveKnowledgeBaseChunkPlan) GetFileIds() []string {
	if t == nil {
		return nil
	}
	return t.FileIds
}

func (t *TrieveKnowledgeBaseChunkPlan) GetWebsites() []string {
	if t == nil {
		return nil
	}
	return t.Websites
}

func (t *TrieveKnowledgeBaseChunkPlan) GetTargetSplitsPerChunk() *float64 {
	if t == nil {
		return nil
	}
	return t.TargetSplitsPerChunk
}

func (t *TrieveKnowledgeBaseChunkPlan) GetSplitDelimiters() []string {
	if t == nil {
		return nil
	}
	return t.SplitDelimiters
}

func (t *TrieveKnowledgeBaseChunkPlan) GetRebalanceChunks() *bool {
	if t == nil {
		return nil
	}
	return t.RebalanceChunks
}

func (t *TrieveKnowledgeBaseChunkPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TrieveKnowledgeBaseChunkPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TrieveKnowledgeBaseChunkPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrieveKnowledgeBaseChunkPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrieveKnowledgeBaseChunkPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TrieveKnowledgeBaseCreate struct {
	// This is to create a new dataset on Trieve.
	// These are the chunk plans used to create the dataset.
	ChunkPlans []*TrieveKnowledgeBaseChunkPlan `json:"chunkPlans,omitempty" url:"chunkPlans,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TrieveKnowledgeBaseCreate) GetChunkPlans() []*TrieveKnowledgeBaseChunkPlan {
	if t == nil {
		return nil
	}
	return t.ChunkPlans
}

func (t *TrieveKnowledgeBaseCreate) Type() string {
	return t.type_
}

func (t *TrieveKnowledgeBaseCreate) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TrieveKnowledgeBaseCreate) UnmarshalJSON(data []byte) error {
	type embed TrieveKnowledgeBaseCreate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TrieveKnowledgeBaseCreate(unmarshaler.embed)
	if unmarshaler.Type != "create" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "create", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrieveKnowledgeBaseCreate) MarshalJSON() ([]byte, error) {
	type embed TrieveKnowledgeBaseCreate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "create",
	}
	return json.Marshal(marshaler)
}

func (t *TrieveKnowledgeBaseCreate) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the plan if you want us to create/import a new vector store using Trieve.
type TrieveKnowledgeBaseCreatePlan struct {
	TrieveKnowledgeBaseCreate *TrieveKnowledgeBaseCreate
	TrieveKnowledgeBaseImport *TrieveKnowledgeBaseImport

	typ string
}

func (t *TrieveKnowledgeBaseCreatePlan) GetTrieveKnowledgeBaseCreate() *TrieveKnowledgeBaseCreate {
	if t == nil {
		return nil
	}
	return t.TrieveKnowledgeBaseCreate
}

func (t *TrieveKnowledgeBaseCreatePlan) GetTrieveKnowledgeBaseImport() *TrieveKnowledgeBaseImport {
	if t == nil {
		return nil
	}
	return t.TrieveKnowledgeBaseImport
}

func (t *TrieveKnowledgeBaseCreatePlan) UnmarshalJSON(data []byte) error {
	valueTrieveKnowledgeBaseCreate := new(TrieveKnowledgeBaseCreate)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBaseCreate); err == nil {
		t.typ = "TrieveKnowledgeBaseCreate"
		t.TrieveKnowledgeBaseCreate = valueTrieveKnowledgeBaseCreate
		return nil
	}
	valueTrieveKnowledgeBaseImport := new(TrieveKnowledgeBaseImport)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBaseImport); err == nil {
		t.typ = "TrieveKnowledgeBaseImport"
		t.TrieveKnowledgeBaseImport = valueTrieveKnowledgeBaseImport
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TrieveKnowledgeBaseCreatePlan) MarshalJSON() ([]byte, error) {
	if t.typ == "TrieveKnowledgeBaseCreate" || t.TrieveKnowledgeBaseCreate != nil {
		return json.Marshal(t.TrieveKnowledgeBaseCreate)
	}
	if t.typ == "TrieveKnowledgeBaseImport" || t.TrieveKnowledgeBaseImport != nil {
		return json.Marshal(t.TrieveKnowledgeBaseImport)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TrieveKnowledgeBaseCreatePlanVisitor interface {
	VisitTrieveKnowledgeBaseCreate(*TrieveKnowledgeBaseCreate) error
	VisitTrieveKnowledgeBaseImport(*TrieveKnowledgeBaseImport) error
}

func (t *TrieveKnowledgeBaseCreatePlan) Accept(visitor TrieveKnowledgeBaseCreatePlanVisitor) error {
	if t.typ == "TrieveKnowledgeBaseCreate" || t.TrieveKnowledgeBaseCreate != nil {
		return visitor.VisitTrieveKnowledgeBaseCreate(t.TrieveKnowledgeBaseCreate)
	}
	if t.typ == "TrieveKnowledgeBaseImport" || t.TrieveKnowledgeBaseImport != nil {
		return visitor.VisitTrieveKnowledgeBaseImport(t.TrieveKnowledgeBaseImport)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TrieveKnowledgeBaseImport struct {
	// This is to import an existing dataset from Trieve.
	// This is the `datasetId` of the dataset on your Trieve account.
	ProviderId string `json:"providerId" url:"providerId"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TrieveKnowledgeBaseImport) GetProviderId() string {
	if t == nil {
		return ""
	}
	return t.ProviderId
}

func (t *TrieveKnowledgeBaseImport) Type() string {
	return t.type_
}

func (t *TrieveKnowledgeBaseImport) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TrieveKnowledgeBaseImport) UnmarshalJSON(data []byte) error {
	type embed TrieveKnowledgeBaseImport
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TrieveKnowledgeBaseImport(unmarshaler.embed)
	if unmarshaler.Type != "import" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "import", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrieveKnowledgeBaseImport) MarshalJSON() ([]byte, error) {
	type embed TrieveKnowledgeBaseImport
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "import",
	}
	return json.Marshal(marshaler)
}

func (t *TrieveKnowledgeBaseImport) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TrieveKnowledgeBaseSearchPlan struct {
	// If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. This will preserve queries that are entirely stop words.
	RemoveStopWords *bool `json:"removeStopWords,omitempty" url:"removeStopWords,omitempty"`
	// This is the score threshold to filter out chunks with a score below the threshold for cosine distance metric. For Manhattan Distance, Euclidean Distance, and Dot Product, it will filter out scores above the threshold distance. This threshold applies before weight and bias modifications. If not specified, this defaults to no threshold. A threshold of 0 will default to no threshold.
	ScoreThreshold *float64 `json:"scoreThreshold,omitempty" url:"scoreThreshold,omitempty"`
	// This is the search method used when searching for relevant chunks from the vector store.
	SearchType TrieveKnowledgeBaseSearchPlanSearchType `json:"searchType" url:"searchType"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TrieveKnowledgeBaseSearchPlan) GetRemoveStopWords() *bool {
	if t == nil {
		return nil
	}
	return t.RemoveStopWords
}

func (t *TrieveKnowledgeBaseSearchPlan) GetScoreThreshold() *float64 {
	if t == nil {
		return nil
	}
	return t.ScoreThreshold
}

func (t *TrieveKnowledgeBaseSearchPlan) GetSearchType() TrieveKnowledgeBaseSearchPlanSearchType {
	if t == nil {
		return ""
	}
	return t.SearchType
}

func (t *TrieveKnowledgeBaseSearchPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TrieveKnowledgeBaseSearchPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TrieveKnowledgeBaseSearchPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrieveKnowledgeBaseSearchPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrieveKnowledgeBaseSearchPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the search method used when searching for relevant chunks from the vector store.
type TrieveKnowledgeBaseSearchPlanSearchType string

const (
	TrieveKnowledgeBaseSearchPlanSearchTypeFulltext TrieveKnowledgeBaseSearchPlanSearchType = "fulltext"
	TrieveKnowledgeBaseSearchPlanSearchTypeSemantic TrieveKnowledgeBaseSearchPlanSearchType = "semantic"
	TrieveKnowledgeBaseSearchPlanSearchTypeHybrid   TrieveKnowledgeBaseSearchPlanSearchType = "hybrid"
	TrieveKnowledgeBaseSearchPlanSearchTypeBm25     TrieveKnowledgeBaseSearchPlanSearchType = "bm25"
)

func NewTrieveKnowledgeBaseSearchPlanSearchTypeFromString(s string) (TrieveKnowledgeBaseSearchPlanSearchType, error) {
	switch s {
	case "fulltext":
		return TrieveKnowledgeBaseSearchPlanSearchTypeFulltext, nil
	case "semantic":
		return TrieveKnowledgeBaseSearchPlanSearchTypeSemantic, nil
	case "hybrid":
		return TrieveKnowledgeBaseSearchPlanSearchTypeHybrid, nil
	case "bm25":
		return TrieveKnowledgeBaseSearchPlanSearchTypeBm25, nil
	}
	var t TrieveKnowledgeBaseSearchPlanSearchType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrieveKnowledgeBaseSearchPlanSearchType) Ptr() *TrieveKnowledgeBaseSearchPlanSearchType {
	return &t
}

type UpdateCustomKnowledgeBaseDto struct {
	// This is where the knowledge base request will be sent.
	//
	// Request Example:
	//
	// POST https://{server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "messsage": {
	//	    "type": "knowledge-base-request",
	//	    "messages": [
	//	      {
	//	        "role": "user",
	//	        "content": "Why is ocean blue?"
	//	      }
	//	    ],
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// Response Expected:
	// ```
	//
	//	{
	//	  "message": {
	//	     "role": "assistant",
	//	     "content": "The ocean is blue because water absorbs everything but blue.",
	//	  }, // YOU CAN RETURN THE EXACT RESPONSE TO SPEAK
	//	  "documents": [
	//	    {
	//	      "content": "The ocean is blue primarily because water absorbs colors in the red part of the light spectrum and scatters the blue light, making it more visible to our eyes.",
	//	      "similarity": 1
	//	    },
	//	    {
	//	      "content": "Blue light is scattered more by the water molecules than other colors, enhancing the blue appearance of the ocean.",
	//	      "similarity": .5
	//	    }
	//	  ] // OR, YOU CAN RETURN AN ARRAY OF DOCUMENTS THAT WILL BE SENT TO THE MODEL
	//	}
	//
	// ```
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCustomKnowledgeBaseDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateCustomKnowledgeBaseDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomKnowledgeBaseDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomKnowledgeBaseDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomKnowledgeBaseDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomKnowledgeBaseDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTrieveKnowledgeBaseDto struct {
	// This is the name of the knowledge base.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the searching plan used when searching for relevant chunks from the vector store.
	//
	// You should configure this if you're running into these issues:
	// - Too much unnecessary context is being fed as knowledge base context.
	// - Not enough relevant context is being fed as knowledge base context.
	SearchPlan *TrieveKnowledgeBaseSearchPlan `json:"searchPlan,omitempty" url:"searchPlan,omitempty"`
	// This is the plan if you want us to create/import a new vector store using Trieve.
	CreatePlan *UpdateTrieveKnowledgeBaseDtoCreatePlan `json:"createPlan,omitempty" url:"createPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTrieveKnowledgeBaseDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTrieveKnowledgeBaseDto) GetSearchPlan() *TrieveKnowledgeBaseSearchPlan {
	if u == nil {
		return nil
	}
	return u.SearchPlan
}

func (u *UpdateTrieveKnowledgeBaseDto) GetCreatePlan() *UpdateTrieveKnowledgeBaseDtoCreatePlan {
	if u == nil {
		return nil
	}
	return u.CreatePlan
}

func (u *UpdateTrieveKnowledgeBaseDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTrieveKnowledgeBaseDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTrieveKnowledgeBaseDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTrieveKnowledgeBaseDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTrieveKnowledgeBaseDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the plan if you want us to create/import a new vector store using Trieve.
type UpdateTrieveKnowledgeBaseDtoCreatePlan struct {
	TrieveKnowledgeBaseCreate *TrieveKnowledgeBaseCreate
	TrieveKnowledgeBaseImport *TrieveKnowledgeBaseImport

	typ string
}

func (u *UpdateTrieveKnowledgeBaseDtoCreatePlan) GetTrieveKnowledgeBaseCreate() *TrieveKnowledgeBaseCreate {
	if u == nil {
		return nil
	}
	return u.TrieveKnowledgeBaseCreate
}

func (u *UpdateTrieveKnowledgeBaseDtoCreatePlan) GetTrieveKnowledgeBaseImport() *TrieveKnowledgeBaseImport {
	if u == nil {
		return nil
	}
	return u.TrieveKnowledgeBaseImport
}

func (u *UpdateTrieveKnowledgeBaseDtoCreatePlan) UnmarshalJSON(data []byte) error {
	valueTrieveKnowledgeBaseCreate := new(TrieveKnowledgeBaseCreate)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBaseCreate); err == nil {
		u.typ = "TrieveKnowledgeBaseCreate"
		u.TrieveKnowledgeBaseCreate = valueTrieveKnowledgeBaseCreate
		return nil
	}
	valueTrieveKnowledgeBaseImport := new(TrieveKnowledgeBaseImport)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBaseImport); err == nil {
		u.typ = "TrieveKnowledgeBaseImport"
		u.TrieveKnowledgeBaseImport = valueTrieveKnowledgeBaseImport
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTrieveKnowledgeBaseDtoCreatePlan) MarshalJSON() ([]byte, error) {
	if u.typ == "TrieveKnowledgeBaseCreate" || u.TrieveKnowledgeBaseCreate != nil {
		return json.Marshal(u.TrieveKnowledgeBaseCreate)
	}
	if u.typ == "TrieveKnowledgeBaseImport" || u.TrieveKnowledgeBaseImport != nil {
		return json.Marshal(u.TrieveKnowledgeBaseImport)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateTrieveKnowledgeBaseDtoCreatePlanVisitor interface {
	VisitTrieveKnowledgeBaseCreate(*TrieveKnowledgeBaseCreate) error
	VisitTrieveKnowledgeBaseImport(*TrieveKnowledgeBaseImport) error
}

func (u *UpdateTrieveKnowledgeBaseDtoCreatePlan) Accept(visitor UpdateTrieveKnowledgeBaseDtoCreatePlanVisitor) error {
	if u.typ == "TrieveKnowledgeBaseCreate" || u.TrieveKnowledgeBaseCreate != nil {
		return visitor.VisitTrieveKnowledgeBaseCreate(u.TrieveKnowledgeBaseCreate)
	}
	if u.typ == "TrieveKnowledgeBaseImport" || u.TrieveKnowledgeBaseImport != nil {
		return visitor.VisitTrieveKnowledgeBaseImport(u.TrieveKnowledgeBaseImport)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type KnowledgeBasesCreateRequest struct {
	CreateTrieveKnowledgeBaseDto *CreateTrieveKnowledgeBaseDto
	CreateCustomKnowledgeBaseDto *CreateCustomKnowledgeBaseDto

	typ string
}

func (k *KnowledgeBasesCreateRequest) GetCreateTrieveKnowledgeBaseDto() *CreateTrieveKnowledgeBaseDto {
	if k == nil {
		return nil
	}
	return k.CreateTrieveKnowledgeBaseDto
}

func (k *KnowledgeBasesCreateRequest) GetCreateCustomKnowledgeBaseDto() *CreateCustomKnowledgeBaseDto {
	if k == nil {
		return nil
	}
	return k.CreateCustomKnowledgeBaseDto
}

func (k *KnowledgeBasesCreateRequest) UnmarshalJSON(data []byte) error {
	valueCreateTrieveKnowledgeBaseDto := new(CreateTrieveKnowledgeBaseDto)
	if err := json.Unmarshal(data, &valueCreateTrieveKnowledgeBaseDto); err == nil {
		k.typ = "CreateTrieveKnowledgeBaseDto"
		k.CreateTrieveKnowledgeBaseDto = valueCreateTrieveKnowledgeBaseDto
		return nil
	}
	valueCreateCustomKnowledgeBaseDto := new(CreateCustomKnowledgeBaseDto)
	if err := json.Unmarshal(data, &valueCreateCustomKnowledgeBaseDto); err == nil {
		k.typ = "CreateCustomKnowledgeBaseDto"
		k.CreateCustomKnowledgeBaseDto = valueCreateCustomKnowledgeBaseDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, k)
}

func (k KnowledgeBasesCreateRequest) MarshalJSON() ([]byte, error) {
	if k.typ == "CreateTrieveKnowledgeBaseDto" || k.CreateTrieveKnowledgeBaseDto != nil {
		return json.Marshal(k.CreateTrieveKnowledgeBaseDto)
	}
	if k.typ == "CreateCustomKnowledgeBaseDto" || k.CreateCustomKnowledgeBaseDto != nil {
		return json.Marshal(k.CreateCustomKnowledgeBaseDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesCreateRequestVisitor interface {
	VisitCreateTrieveKnowledgeBaseDto(*CreateTrieveKnowledgeBaseDto) error
	VisitCreateCustomKnowledgeBaseDto(*CreateCustomKnowledgeBaseDto) error
}

func (k *KnowledgeBasesCreateRequest) Accept(visitor KnowledgeBasesCreateRequestVisitor) error {
	if k.typ == "CreateTrieveKnowledgeBaseDto" || k.CreateTrieveKnowledgeBaseDto != nil {
		return visitor.VisitCreateTrieveKnowledgeBaseDto(k.CreateTrieveKnowledgeBaseDto)
	}
	if k.typ == "CreateCustomKnowledgeBaseDto" || k.CreateCustomKnowledgeBaseDto != nil {
		return visitor.VisitCreateCustomKnowledgeBaseDto(k.CreateCustomKnowledgeBaseDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesCreateResponse struct {
	TrieveKnowledgeBase *TrieveKnowledgeBase
	CustomKnowledgeBase *CustomKnowledgeBase

	typ string
}

func (k *KnowledgeBasesCreateResponse) GetTrieveKnowledgeBase() *TrieveKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.TrieveKnowledgeBase
}

func (k *KnowledgeBasesCreateResponse) GetCustomKnowledgeBase() *CustomKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.CustomKnowledgeBase
}

func (k *KnowledgeBasesCreateResponse) UnmarshalJSON(data []byte) error {
	valueTrieveKnowledgeBase := new(TrieveKnowledgeBase)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBase); err == nil {
		k.typ = "TrieveKnowledgeBase"
		k.TrieveKnowledgeBase = valueTrieveKnowledgeBase
		return nil
	}
	valueCustomKnowledgeBase := new(CustomKnowledgeBase)
	if err := json.Unmarshal(data, &valueCustomKnowledgeBase); err == nil {
		k.typ = "CustomKnowledgeBase"
		k.CustomKnowledgeBase = valueCustomKnowledgeBase
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, k)
}

func (k KnowledgeBasesCreateResponse) MarshalJSON() ([]byte, error) {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return json.Marshal(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return json.Marshal(k.CustomKnowledgeBase)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesCreateResponseVisitor interface {
	VisitTrieveKnowledgeBase(*TrieveKnowledgeBase) error
	VisitCustomKnowledgeBase(*CustomKnowledgeBase) error
}

func (k *KnowledgeBasesCreateResponse) Accept(visitor KnowledgeBasesCreateResponseVisitor) error {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return visitor.VisitTrieveKnowledgeBase(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return visitor.VisitCustomKnowledgeBase(k.CustomKnowledgeBase)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesDeleteResponse struct {
	TrieveKnowledgeBase *TrieveKnowledgeBase
	CustomKnowledgeBase *CustomKnowledgeBase

	typ string
}

func (k *KnowledgeBasesDeleteResponse) GetTrieveKnowledgeBase() *TrieveKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.TrieveKnowledgeBase
}

func (k *KnowledgeBasesDeleteResponse) GetCustomKnowledgeBase() *CustomKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.CustomKnowledgeBase
}

func (k *KnowledgeBasesDeleteResponse) UnmarshalJSON(data []byte) error {
	valueTrieveKnowledgeBase := new(TrieveKnowledgeBase)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBase); err == nil {
		k.typ = "TrieveKnowledgeBase"
		k.TrieveKnowledgeBase = valueTrieveKnowledgeBase
		return nil
	}
	valueCustomKnowledgeBase := new(CustomKnowledgeBase)
	if err := json.Unmarshal(data, &valueCustomKnowledgeBase); err == nil {
		k.typ = "CustomKnowledgeBase"
		k.CustomKnowledgeBase = valueCustomKnowledgeBase
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, k)
}

func (k KnowledgeBasesDeleteResponse) MarshalJSON() ([]byte, error) {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return json.Marshal(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return json.Marshal(k.CustomKnowledgeBase)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesDeleteResponseVisitor interface {
	VisitTrieveKnowledgeBase(*TrieveKnowledgeBase) error
	VisitCustomKnowledgeBase(*CustomKnowledgeBase) error
}

func (k *KnowledgeBasesDeleteResponse) Accept(visitor KnowledgeBasesDeleteResponseVisitor) error {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return visitor.VisitTrieveKnowledgeBase(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return visitor.VisitCustomKnowledgeBase(k.CustomKnowledgeBase)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesGetResponse struct {
	TrieveKnowledgeBase *TrieveKnowledgeBase
	CustomKnowledgeBase *CustomKnowledgeBase

	typ string
}

func (k *KnowledgeBasesGetResponse) GetTrieveKnowledgeBase() *TrieveKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.TrieveKnowledgeBase
}

func (k *KnowledgeBasesGetResponse) GetCustomKnowledgeBase() *CustomKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.CustomKnowledgeBase
}

func (k *KnowledgeBasesGetResponse) UnmarshalJSON(data []byte) error {
	valueTrieveKnowledgeBase := new(TrieveKnowledgeBase)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBase); err == nil {
		k.typ = "TrieveKnowledgeBase"
		k.TrieveKnowledgeBase = valueTrieveKnowledgeBase
		return nil
	}
	valueCustomKnowledgeBase := new(CustomKnowledgeBase)
	if err := json.Unmarshal(data, &valueCustomKnowledgeBase); err == nil {
		k.typ = "CustomKnowledgeBase"
		k.CustomKnowledgeBase = valueCustomKnowledgeBase
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, k)
}

func (k KnowledgeBasesGetResponse) MarshalJSON() ([]byte, error) {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return json.Marshal(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return json.Marshal(k.CustomKnowledgeBase)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesGetResponseVisitor interface {
	VisitTrieveKnowledgeBase(*TrieveKnowledgeBase) error
	VisitCustomKnowledgeBase(*CustomKnowledgeBase) error
}

func (k *KnowledgeBasesGetResponse) Accept(visitor KnowledgeBasesGetResponseVisitor) error {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return visitor.VisitTrieveKnowledgeBase(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return visitor.VisitCustomKnowledgeBase(k.CustomKnowledgeBase)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesListResponseItem struct {
	TrieveKnowledgeBase *TrieveKnowledgeBase
	CustomKnowledgeBase *CustomKnowledgeBase

	typ string
}

func (k *KnowledgeBasesListResponseItem) GetTrieveKnowledgeBase() *TrieveKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.TrieveKnowledgeBase
}

func (k *KnowledgeBasesListResponseItem) GetCustomKnowledgeBase() *CustomKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.CustomKnowledgeBase
}

func (k *KnowledgeBasesListResponseItem) UnmarshalJSON(data []byte) error {
	valueTrieveKnowledgeBase := new(TrieveKnowledgeBase)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBase); err == nil {
		k.typ = "TrieveKnowledgeBase"
		k.TrieveKnowledgeBase = valueTrieveKnowledgeBase
		return nil
	}
	valueCustomKnowledgeBase := new(CustomKnowledgeBase)
	if err := json.Unmarshal(data, &valueCustomKnowledgeBase); err == nil {
		k.typ = "CustomKnowledgeBase"
		k.CustomKnowledgeBase = valueCustomKnowledgeBase
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, k)
}

func (k KnowledgeBasesListResponseItem) MarshalJSON() ([]byte, error) {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return json.Marshal(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return json.Marshal(k.CustomKnowledgeBase)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesListResponseItemVisitor interface {
	VisitTrieveKnowledgeBase(*TrieveKnowledgeBase) error
	VisitCustomKnowledgeBase(*CustomKnowledgeBase) error
}

func (k *KnowledgeBasesListResponseItem) Accept(visitor KnowledgeBasesListResponseItemVisitor) error {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return visitor.VisitTrieveKnowledgeBase(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return visitor.VisitCustomKnowledgeBase(k.CustomKnowledgeBase)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesUpdateRequest struct {
	UpdateTrieveKnowledgeBaseDto *UpdateTrieveKnowledgeBaseDto
	UpdateCustomKnowledgeBaseDto *UpdateCustomKnowledgeBaseDto

	typ string
}

func (k *KnowledgeBasesUpdateRequest) GetUpdateTrieveKnowledgeBaseDto() *UpdateTrieveKnowledgeBaseDto {
	if k == nil {
		return nil
	}
	return k.UpdateTrieveKnowledgeBaseDto
}

func (k *KnowledgeBasesUpdateRequest) GetUpdateCustomKnowledgeBaseDto() *UpdateCustomKnowledgeBaseDto {
	if k == nil {
		return nil
	}
	return k.UpdateCustomKnowledgeBaseDto
}

func (k *KnowledgeBasesUpdateRequest) UnmarshalJSON(data []byte) error {
	valueUpdateTrieveKnowledgeBaseDto := new(UpdateTrieveKnowledgeBaseDto)
	if err := json.Unmarshal(data, &valueUpdateTrieveKnowledgeBaseDto); err == nil {
		k.typ = "UpdateTrieveKnowledgeBaseDto"
		k.UpdateTrieveKnowledgeBaseDto = valueUpdateTrieveKnowledgeBaseDto
		return nil
	}
	valueUpdateCustomKnowledgeBaseDto := new(UpdateCustomKnowledgeBaseDto)
	if err := json.Unmarshal(data, &valueUpdateCustomKnowledgeBaseDto); err == nil {
		k.typ = "UpdateCustomKnowledgeBaseDto"
		k.UpdateCustomKnowledgeBaseDto = valueUpdateCustomKnowledgeBaseDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, k)
}

func (k KnowledgeBasesUpdateRequest) MarshalJSON() ([]byte, error) {
	if k.typ == "UpdateTrieveKnowledgeBaseDto" || k.UpdateTrieveKnowledgeBaseDto != nil {
		return json.Marshal(k.UpdateTrieveKnowledgeBaseDto)
	}
	if k.typ == "UpdateCustomKnowledgeBaseDto" || k.UpdateCustomKnowledgeBaseDto != nil {
		return json.Marshal(k.UpdateCustomKnowledgeBaseDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesUpdateRequestVisitor interface {
	VisitUpdateTrieveKnowledgeBaseDto(*UpdateTrieveKnowledgeBaseDto) error
	VisitUpdateCustomKnowledgeBaseDto(*UpdateCustomKnowledgeBaseDto) error
}

func (k *KnowledgeBasesUpdateRequest) Accept(visitor KnowledgeBasesUpdateRequestVisitor) error {
	if k.typ == "UpdateTrieveKnowledgeBaseDto" || k.UpdateTrieveKnowledgeBaseDto != nil {
		return visitor.VisitUpdateTrieveKnowledgeBaseDto(k.UpdateTrieveKnowledgeBaseDto)
	}
	if k.typ == "UpdateCustomKnowledgeBaseDto" || k.UpdateCustomKnowledgeBaseDto != nil {
		return visitor.VisitUpdateCustomKnowledgeBaseDto(k.UpdateCustomKnowledgeBaseDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesUpdateResponse struct {
	TrieveKnowledgeBase *TrieveKnowledgeBase
	CustomKnowledgeBase *CustomKnowledgeBase

	typ string
}

func (k *KnowledgeBasesUpdateResponse) GetTrieveKnowledgeBase() *TrieveKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.TrieveKnowledgeBase
}

func (k *KnowledgeBasesUpdateResponse) GetCustomKnowledgeBase() *CustomKnowledgeBase {
	if k == nil {
		return nil
	}
	return k.CustomKnowledgeBase
}

func (k *KnowledgeBasesUpdateResponse) UnmarshalJSON(data []byte) error {
	valueTrieveKnowledgeBase := new(TrieveKnowledgeBase)
	if err := json.Unmarshal(data, &valueTrieveKnowledgeBase); err == nil {
		k.typ = "TrieveKnowledgeBase"
		k.TrieveKnowledgeBase = valueTrieveKnowledgeBase
		return nil
	}
	valueCustomKnowledgeBase := new(CustomKnowledgeBase)
	if err := json.Unmarshal(data, &valueCustomKnowledgeBase); err == nil {
		k.typ = "CustomKnowledgeBase"
		k.CustomKnowledgeBase = valueCustomKnowledgeBase
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, k)
}

func (k KnowledgeBasesUpdateResponse) MarshalJSON() ([]byte, error) {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return json.Marshal(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return json.Marshal(k.CustomKnowledgeBase)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", k)
}

type KnowledgeBasesUpdateResponseVisitor interface {
	VisitTrieveKnowledgeBase(*TrieveKnowledgeBase) error
	VisitCustomKnowledgeBase(*CustomKnowledgeBase) error
}

func (k *KnowledgeBasesUpdateResponse) Accept(visitor KnowledgeBasesUpdateResponseVisitor) error {
	if k.typ == "TrieveKnowledgeBase" || k.TrieveKnowledgeBase != nil {
		return visitor.VisitTrieveKnowledgeBase(k.TrieveKnowledgeBase)
	}
	if k.typ == "CustomKnowledgeBase" || k.CustomKnowledgeBase != nil {
		return visitor.VisitCustomKnowledgeBase(k.CustomKnowledgeBase)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", k)
}
