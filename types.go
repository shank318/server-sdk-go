// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/VapiAI/server-sdk-go/internal"
	time "time"
)

type AddVoiceToProviderDto struct {
	// This is the owner_id of your shared voice which you want to add to your provider Account from Provider Voice Library
	OwnerId string `json:"ownerId" url:"ownerId"`
	// This is the voice_id of the shared voice which you want to add to your provider Account from Provider Voice Library
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the new name of the voice which you want to have once you have added voice to your provider Account from Provider Voice Library
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddVoiceToProviderDto) GetOwnerId() string {
	if a == nil {
		return ""
	}
	return a.OwnerId
}

func (a *AddVoiceToProviderDto) GetVoiceId() string {
	if a == nil {
		return ""
	}
	return a.VoiceId
}

func (a *AddVoiceToProviderDto) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AddVoiceToProviderDto) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddVoiceToProviderDto) UnmarshalJSON(data []byte) error {
	type unmarshaler AddVoiceToProviderDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddVoiceToProviderDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddVoiceToProviderDto) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalysisPlan struct {
	// This is the plan for generating the summary of the call. This outputs to `call.analysis.summary`.
	SummaryPlan *SummaryPlan `json:"summaryPlan,omitempty" url:"summaryPlan,omitempty"`
	// This is the plan for generating the structured data from the call. This outputs to `call.analysis.structuredData`.
	StructuredDataPlan *StructuredDataPlan `json:"structuredDataPlan,omitempty" url:"structuredDataPlan,omitempty"`
	// This is the plan for generating the success evaluation of the call. This outputs to `call.analysis.successEvaluation`.
	SuccessEvaluationPlan *SuccessEvaluationPlan `json:"successEvaluationPlan,omitempty" url:"successEvaluationPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalysisPlan) GetSummaryPlan() *SummaryPlan {
	if a == nil {
		return nil
	}
	return a.SummaryPlan
}

func (a *AnalysisPlan) GetStructuredDataPlan() *StructuredDataPlan {
	if a == nil {
		return nil
	}
	return a.StructuredDataPlan
}

func (a *AnalysisPlan) GetSuccessEvaluationPlan() *SuccessEvaluationPlan {
	if a == nil {
		return nil
	}
	return a.SuccessEvaluationPlan
}

func (a *AnalysisPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalysisPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalysisPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalysisPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalysisPlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalyticsOperation struct {
	// This is the aggregation operation you want to perform.
	Operation AnalyticsOperationOperation `json:"operation" url:"operation"`
	// This is the columns you want to perform the aggregation operation on.
	Column AnalyticsOperationColumn `json:"column" url:"column"`
	// This is the alias for column name returned. Defaults to `${operation}${column}`.
	Alias *string `json:"alias,omitempty" url:"alias,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalyticsOperation) GetOperation() AnalyticsOperationOperation {
	if a == nil {
		return ""
	}
	return a.Operation
}

func (a *AnalyticsOperation) GetColumn() AnalyticsOperationColumn {
	if a == nil {
		return ""
	}
	return a.Column
}

func (a *AnalyticsOperation) GetAlias() *string {
	if a == nil {
		return nil
	}
	return a.Alias
}

func (a *AnalyticsOperation) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsOperation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsOperation) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the columns you want to perform the aggregation operation on.
type AnalyticsOperationColumn string

const (
	AnalyticsOperationColumnId                               AnalyticsOperationColumn = "id"
	AnalyticsOperationColumnCost                             AnalyticsOperationColumn = "cost"
	AnalyticsOperationColumnCostBreakdownLlm                 AnalyticsOperationColumn = "costBreakdown.llm"
	AnalyticsOperationColumnCostBreakdownStt                 AnalyticsOperationColumn = "costBreakdown.stt"
	AnalyticsOperationColumnCostBreakdownTts                 AnalyticsOperationColumn = "costBreakdown.tts"
	AnalyticsOperationColumnCostBreakdownVapi                AnalyticsOperationColumn = "costBreakdown.vapi"
	AnalyticsOperationColumnCostBreakdownTtsCharacters       AnalyticsOperationColumn = "costBreakdown.ttsCharacters"
	AnalyticsOperationColumnCostBreakdownLlmPromptTokens     AnalyticsOperationColumn = "costBreakdown.llmPromptTokens"
	AnalyticsOperationColumnCostBreakdownLlmCompletionTokens AnalyticsOperationColumn = "costBreakdown.llmCompletionTokens"
	AnalyticsOperationColumnDuration                         AnalyticsOperationColumn = "duration"
)

func NewAnalyticsOperationColumnFromString(s string) (AnalyticsOperationColumn, error) {
	switch s {
	case "id":
		return AnalyticsOperationColumnId, nil
	case "cost":
		return AnalyticsOperationColumnCost, nil
	case "costBreakdown.llm":
		return AnalyticsOperationColumnCostBreakdownLlm, nil
	case "costBreakdown.stt":
		return AnalyticsOperationColumnCostBreakdownStt, nil
	case "costBreakdown.tts":
		return AnalyticsOperationColumnCostBreakdownTts, nil
	case "costBreakdown.vapi":
		return AnalyticsOperationColumnCostBreakdownVapi, nil
	case "costBreakdown.ttsCharacters":
		return AnalyticsOperationColumnCostBreakdownTtsCharacters, nil
	case "costBreakdown.llmPromptTokens":
		return AnalyticsOperationColumnCostBreakdownLlmPromptTokens, nil
	case "costBreakdown.llmCompletionTokens":
		return AnalyticsOperationColumnCostBreakdownLlmCompletionTokens, nil
	case "duration":
		return AnalyticsOperationColumnDuration, nil
	}
	var t AnalyticsOperationColumn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsOperationColumn) Ptr() *AnalyticsOperationColumn {
	return &a
}

// This is the aggregation operation you want to perform.
type AnalyticsOperationOperation string

const (
	AnalyticsOperationOperationSum   AnalyticsOperationOperation = "sum"
	AnalyticsOperationOperationAvg   AnalyticsOperationOperation = "avg"
	AnalyticsOperationOperationCount AnalyticsOperationOperation = "count"
	AnalyticsOperationOperationMin   AnalyticsOperationOperation = "min"
	AnalyticsOperationOperationMax   AnalyticsOperationOperation = "max"
)

func NewAnalyticsOperationOperationFromString(s string) (AnalyticsOperationOperation, error) {
	switch s {
	case "sum":
		return AnalyticsOperationOperationSum, nil
	case "avg":
		return AnalyticsOperationOperationAvg, nil
	case "count":
		return AnalyticsOperationOperationCount, nil
	case "min":
		return AnalyticsOperationOperationMin, nil
	case "max":
		return AnalyticsOperationOperationMax, nil
	}
	var t AnalyticsOperationOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsOperationOperation) Ptr() *AnalyticsOperationOperation {
	return &a
}

type AnalyticsQuery struct {
	// This is the table you want to query.
	// This is the list of columns you want to group by.
	GroupBy []AnalyticsQueryGroupByItem `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// This is the name of the query. This will be used to identify the query in the response.
	Name string `json:"name" url:"name"`
	// This is the time range for the query.
	TimeRange *TimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the list of operations you want to perform.
	Operations []*AnalyticsOperation `json:"operations,omitempty" url:"operations,omitempty"`
	table      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalyticsQuery) GetGroupBy() []AnalyticsQueryGroupByItem {
	if a == nil {
		return nil
	}
	return a.GroupBy
}

func (a *AnalyticsQuery) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AnalyticsQuery) GetTimeRange() *TimeRange {
	if a == nil {
		return nil
	}
	return a.TimeRange
}

func (a *AnalyticsQuery) GetOperations() []*AnalyticsOperation {
	if a == nil {
		return nil
	}
	return a.Operations
}

func (a *AnalyticsQuery) Table() string {
	return a.table
}

func (a *AnalyticsQuery) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsQuery) UnmarshalJSON(data []byte) error {
	type embed AnalyticsQuery
	var unmarshaler = struct {
		embed
		Table string `json:"table"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnalyticsQuery(unmarshaler.embed)
	if unmarshaler.Table != "call" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "call", unmarshaler.Table)
	}
	a.table = unmarshaler.Table
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "table")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsQuery) MarshalJSON() ([]byte, error) {
	type embed AnalyticsQuery
	var marshaler = struct {
		embed
		Table string `json:"table"`
	}{
		embed: embed(*a),
		Table: "call",
	}
	return json.Marshal(marshaler)
}

func (a *AnalyticsQuery) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalyticsQueryDto struct {
	// This is the list of metric queries you want to perform.
	Queries []*AnalyticsQuery `json:"queries,omitempty" url:"queries,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalyticsQueryDto) GetQueries() []*AnalyticsQuery {
	if a == nil {
		return nil
	}
	return a.Queries
}

func (a *AnalyticsQueryDto) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsQueryDto) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsQueryDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsQueryDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsQueryDto) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnalyticsQueryGroupByItem string

const (
	AnalyticsQueryGroupByItemType                      AnalyticsQueryGroupByItem = "type"
	AnalyticsQueryGroupByItemAssistantId               AnalyticsQueryGroupByItem = "assistantId"
	AnalyticsQueryGroupByItemEndedReason               AnalyticsQueryGroupByItem = "endedReason"
	AnalyticsQueryGroupByItemAnalysisSuccessEvaluation AnalyticsQueryGroupByItem = "analysis.successEvaluation"
	AnalyticsQueryGroupByItemStatus                    AnalyticsQueryGroupByItem = "status"
)

func NewAnalyticsQueryGroupByItemFromString(s string) (AnalyticsQueryGroupByItem, error) {
	switch s {
	case "type":
		return AnalyticsQueryGroupByItemType, nil
	case "assistantId":
		return AnalyticsQueryGroupByItemAssistantId, nil
	case "endedReason":
		return AnalyticsQueryGroupByItemEndedReason, nil
	case "analysis.successEvaluation":
		return AnalyticsQueryGroupByItemAnalysisSuccessEvaluation, nil
	case "status":
		return AnalyticsQueryGroupByItemStatus, nil
	}
	var t AnalyticsQueryGroupByItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnalyticsQueryGroupByItem) Ptr() *AnalyticsQueryGroupByItem {
	return &a
}

type AnalyticsQueryResult struct {
	// This is the unique key for the query.
	Name string `json:"name" url:"name"`
	// This is the time range for the query.
	TimeRange *TimeRange `json:"timeRange,omitempty" url:"timeRange,omitempty"`
	// This is the result of the query, a list of unique groups with result of their aggregations.
	//
	// Example:
	// "result": [
	//
	//	{ "date": "2023-01-01", "assistantId": "123", "endedReason": "customer-ended-call", "sumDuration": 120, "avgCost": 10.5 },
	//	{ "date": "2023-01-02", "assistantId": "123", "endedReason": "customer-did-not-give-microphone-permission", "sumDuration": 0, "avgCost": 0 },
	//	// Additional results
	//
	// ]
	Result []map[string]interface{} `json:"result,omitempty" url:"result,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnalyticsQueryResult) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AnalyticsQueryResult) GetTimeRange() *TimeRange {
	if a == nil {
		return nil
	}
	return a.TimeRange
}

func (a *AnalyticsQueryResult) GetResult() []map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Result
}

func (a *AnalyticsQueryResult) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnalyticsQueryResult) UnmarshalJSON(data []byte) error {
	type unmarshaler AnalyticsQueryResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AnalyticsQueryResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnalyticsQueryResult) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnthropicCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnthropicCredential) GetApiKey() string {
	if a == nil {
		return ""
	}
	return a.ApiKey
}

func (a *AnthropicCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AnthropicCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AnthropicCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AnthropicCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AnthropicCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AnthropicCredential) Provider() string {
	return a.provider
}

func (a *AnthropicCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnthropicCredential) UnmarshalJSON(data []byte) error {
	type embed AnthropicCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnthropicCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anthropic", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnthropicCredential) MarshalJSON() ([]byte, error) {
	type embed AnthropicCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "anthropic",
	}
	return json.Marshal(marshaler)
}

func (a *AnthropicCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnthropicModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*AnthropicModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the Anthropic/Claude models that will be used.
	Model AnthropicModelModel `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnthropicModel) GetMessages() []*OpenAiMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *AnthropicModel) GetTools() []*AnthropicModelToolsItem {
	if a == nil {
		return nil
	}
	return a.Tools
}

func (a *AnthropicModel) GetToolIds() []string {
	if a == nil {
		return nil
	}
	return a.ToolIds
}

func (a *AnthropicModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if a == nil {
		return nil
	}
	return a.KnowledgeBase
}

func (a *AnthropicModel) GetKnowledgeBaseId() *string {
	if a == nil {
		return nil
	}
	return a.KnowledgeBaseId
}

func (a *AnthropicModel) GetModel() AnthropicModelModel {
	if a == nil {
		return ""
	}
	return a.Model
}

func (a *AnthropicModel) GetTemperature() *float64 {
	if a == nil {
		return nil
	}
	return a.Temperature
}

func (a *AnthropicModel) GetMaxTokens() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxTokens
}

func (a *AnthropicModel) GetEmotionRecognitionEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.EmotionRecognitionEnabled
}

func (a *AnthropicModel) GetNumFastTurns() *float64 {
	if a == nil {
		return nil
	}
	return a.NumFastTurns
}

func (a *AnthropicModel) Provider() string {
	return a.provider
}

func (a *AnthropicModel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnthropicModel) UnmarshalJSON(data []byte) error {
	type embed AnthropicModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnthropicModel(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anthropic", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnthropicModel) MarshalJSON() ([]byte, error) {
	type embed AnthropicModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "anthropic",
	}
	return json.Marshal(marshaler)
}

func (a *AnthropicModel) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the Anthropic/Claude models that will be used.
type AnthropicModelModel string

const (
	AnthropicModelModelClaude3Opus20240229    AnthropicModelModel = "claude-3-opus-20240229"
	AnthropicModelModelClaude3Sonnet20240229  AnthropicModelModel = "claude-3-sonnet-20240229"
	AnthropicModelModelClaude3Haiku20240307   AnthropicModelModel = "claude-3-haiku-20240307"
	AnthropicModelModelClaude35Sonnet20240620 AnthropicModelModel = "claude-3-5-sonnet-20240620"
	AnthropicModelModelClaude35Sonnet20241022 AnthropicModelModel = "claude-3-5-sonnet-20241022"
	AnthropicModelModelClaude35Haiku20241022  AnthropicModelModel = "claude-3-5-haiku-20241022"
)

func NewAnthropicModelModelFromString(s string) (AnthropicModelModel, error) {
	switch s {
	case "claude-3-opus-20240229":
		return AnthropicModelModelClaude3Opus20240229, nil
	case "claude-3-sonnet-20240229":
		return AnthropicModelModelClaude3Sonnet20240229, nil
	case "claude-3-haiku-20240307":
		return AnthropicModelModelClaude3Haiku20240307, nil
	case "claude-3-5-sonnet-20240620":
		return AnthropicModelModelClaude35Sonnet20240620, nil
	case "claude-3-5-sonnet-20241022":
		return AnthropicModelModelClaude35Sonnet20241022, nil
	case "claude-3-5-haiku-20241022":
		return AnthropicModelModelClaude35Haiku20241022, nil
	}
	var t AnthropicModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnthropicModelModel) Ptr() *AnthropicModelModel {
	return &a
}

type AnthropicModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (a *AnthropicModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if a == nil {
		return nil
	}
	return a.CreateDtmfToolDto
}

func (a *AnthropicModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if a == nil {
		return nil
	}
	return a.CreateEndCallToolDto
}

func (a *AnthropicModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if a == nil {
		return nil
	}
	return a.CreateVoicemailToolDto
}

func (a *AnthropicModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if a == nil {
		return nil
	}
	return a.CreateFunctionToolDto
}

func (a *AnthropicModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGhlToolDto
}

func (a *AnthropicModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if a == nil {
		return nil
	}
	return a.CreateMakeToolDto
}

func (a *AnthropicModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if a == nil {
		return nil
	}
	return a.CreateTransferCallToolDto
}

func (a *AnthropicModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		a.typ = "CreateDtmfToolDto"
		a.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		a.typ = "CreateEndCallToolDto"
		a.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		a.typ = "CreateVoicemailToolDto"
		a.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		a.typ = "CreateFunctionToolDto"
		a.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		a.typ = "CreateGhlToolDto"
		a.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		a.typ = "CreateMakeToolDto"
		a.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		a.typ = "CreateTransferCallToolDto"
		a.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AnthropicModelToolsItem) MarshalJSON() ([]byte, error) {
	if a.typ == "CreateDtmfToolDto" || a.CreateDtmfToolDto != nil {
		return json.Marshal(a.CreateDtmfToolDto)
	}
	if a.typ == "CreateEndCallToolDto" || a.CreateEndCallToolDto != nil {
		return json.Marshal(a.CreateEndCallToolDto)
	}
	if a.typ == "CreateVoicemailToolDto" || a.CreateVoicemailToolDto != nil {
		return json.Marshal(a.CreateVoicemailToolDto)
	}
	if a.typ == "CreateFunctionToolDto" || a.CreateFunctionToolDto != nil {
		return json.Marshal(a.CreateFunctionToolDto)
	}
	if a.typ == "CreateGhlToolDto" || a.CreateGhlToolDto != nil {
		return json.Marshal(a.CreateGhlToolDto)
	}
	if a.typ == "CreateMakeToolDto" || a.CreateMakeToolDto != nil {
		return json.Marshal(a.CreateMakeToolDto)
	}
	if a.typ == "CreateTransferCallToolDto" || a.CreateTransferCallToolDto != nil {
		return json.Marshal(a.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnthropicModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (a *AnthropicModelToolsItem) Accept(visitor AnthropicModelToolsItemVisitor) error {
	if a.typ == "CreateDtmfToolDto" || a.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(a.CreateDtmfToolDto)
	}
	if a.typ == "CreateEndCallToolDto" || a.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(a.CreateEndCallToolDto)
	}
	if a.typ == "CreateVoicemailToolDto" || a.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(a.CreateVoicemailToolDto)
	}
	if a.typ == "CreateFunctionToolDto" || a.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(a.CreateFunctionToolDto)
	}
	if a.typ == "CreateGhlToolDto" || a.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(a.CreateGhlToolDto)
	}
	if a.typ == "CreateMakeToolDto" || a.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(a.CreateMakeToolDto)
	}
	if a.typ == "CreateTransferCallToolDto" || a.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(a.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnyscaleCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnyscaleCredential) GetApiKey() string {
	if a == nil {
		return ""
	}
	return a.ApiKey
}

func (a *AnyscaleCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AnyscaleCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AnyscaleCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AnyscaleCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AnyscaleCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AnyscaleCredential) Provider() string {
	return a.provider
}

func (a *AnyscaleCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnyscaleCredential) UnmarshalJSON(data []byte) error {
	type embed AnyscaleCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnyscaleCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anyscale", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnyscaleCredential) MarshalJSON() ([]byte, error) {
	type embed AnyscaleCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "anyscale",
	}
	return json.Marshal(marshaler)
}

func (a *AnyscaleCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnyscaleModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*AnyscaleModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AnyscaleModel) GetMessages() []*OpenAiMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *AnyscaleModel) GetTools() []*AnyscaleModelToolsItem {
	if a == nil {
		return nil
	}
	return a.Tools
}

func (a *AnyscaleModel) GetToolIds() []string {
	if a == nil {
		return nil
	}
	return a.ToolIds
}

func (a *AnyscaleModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if a == nil {
		return nil
	}
	return a.KnowledgeBase
}

func (a *AnyscaleModel) GetKnowledgeBaseId() *string {
	if a == nil {
		return nil
	}
	return a.KnowledgeBaseId
}

func (a *AnyscaleModel) GetModel() string {
	if a == nil {
		return ""
	}
	return a.Model
}

func (a *AnyscaleModel) GetTemperature() *float64 {
	if a == nil {
		return nil
	}
	return a.Temperature
}

func (a *AnyscaleModel) GetMaxTokens() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxTokens
}

func (a *AnyscaleModel) GetEmotionRecognitionEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.EmotionRecognitionEnabled
}

func (a *AnyscaleModel) GetNumFastTurns() *float64 {
	if a == nil {
		return nil
	}
	return a.NumFastTurns
}

func (a *AnyscaleModel) Provider() string {
	return a.provider
}

func (a *AnyscaleModel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AnyscaleModel) UnmarshalJSON(data []byte) error {
	type embed AnyscaleModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AnyscaleModel(unmarshaler.embed)
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "anyscale", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AnyscaleModel) MarshalJSON() ([]byte, error) {
	type embed AnyscaleModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "anyscale",
	}
	return json.Marshal(marshaler)
}

func (a *AnyscaleModel) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnyscaleModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (a *AnyscaleModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if a == nil {
		return nil
	}
	return a.CreateDtmfToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if a == nil {
		return nil
	}
	return a.CreateEndCallToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if a == nil {
		return nil
	}
	return a.CreateVoicemailToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if a == nil {
		return nil
	}
	return a.CreateFunctionToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if a == nil {
		return nil
	}
	return a.CreateGhlToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if a == nil {
		return nil
	}
	return a.CreateMakeToolDto
}

func (a *AnyscaleModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if a == nil {
		return nil
	}
	return a.CreateTransferCallToolDto
}

func (a *AnyscaleModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		a.typ = "CreateDtmfToolDto"
		a.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		a.typ = "CreateEndCallToolDto"
		a.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		a.typ = "CreateVoicemailToolDto"
		a.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		a.typ = "CreateFunctionToolDto"
		a.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		a.typ = "CreateGhlToolDto"
		a.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		a.typ = "CreateMakeToolDto"
		a.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		a.typ = "CreateTransferCallToolDto"
		a.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AnyscaleModelToolsItem) MarshalJSON() ([]byte, error) {
	if a.typ == "CreateDtmfToolDto" || a.CreateDtmfToolDto != nil {
		return json.Marshal(a.CreateDtmfToolDto)
	}
	if a.typ == "CreateEndCallToolDto" || a.CreateEndCallToolDto != nil {
		return json.Marshal(a.CreateEndCallToolDto)
	}
	if a.typ == "CreateVoicemailToolDto" || a.CreateVoicemailToolDto != nil {
		return json.Marshal(a.CreateVoicemailToolDto)
	}
	if a.typ == "CreateFunctionToolDto" || a.CreateFunctionToolDto != nil {
		return json.Marshal(a.CreateFunctionToolDto)
	}
	if a.typ == "CreateGhlToolDto" || a.CreateGhlToolDto != nil {
		return json.Marshal(a.CreateGhlToolDto)
	}
	if a.typ == "CreateMakeToolDto" || a.CreateMakeToolDto != nil {
		return json.Marshal(a.CreateMakeToolDto)
	}
	if a.typ == "CreateTransferCallToolDto" || a.CreateTransferCallToolDto != nil {
		return json.Marshal(a.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AnyscaleModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (a *AnyscaleModelToolsItem) Accept(visitor AnyscaleModelToolsItemVisitor) error {
	if a.typ == "CreateDtmfToolDto" || a.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(a.CreateDtmfToolDto)
	}
	if a.typ == "CreateEndCallToolDto" || a.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(a.CreateEndCallToolDto)
	}
	if a.typ == "CreateVoicemailToolDto" || a.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(a.CreateVoicemailToolDto)
	}
	if a.typ == "CreateFunctionToolDto" || a.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(a.CreateFunctionToolDto)
	}
	if a.typ == "CreateGhlToolDto" || a.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(a.CreateGhlToolDto)
	}
	if a.typ == "CreateMakeToolDto" || a.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(a.CreateMakeToolDto)
	}
	if a.typ == "CreateTransferCallToolDto" || a.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(a.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ArtifactPlan struct {
	// This determines whether assistant's calls are recorded. Defaults to true.
	//
	// Usage:
	// - If you don't want to record the calls, set this to false.
	// - If you want to record the calls when `assistant.hipaaEnabled`, explicity set this to true and make sure to provide S3 or GCP credentials on the Provider Credentials page in the Dashboard.
	//
	// You can find the recording at `call.artifact.recordingUrl` and `call.artifact.stereoRecordingUrl` after the call is ended.
	//
	// @default true
	RecordingEnabled *bool `json:"recordingEnabled,omitempty" url:"recordingEnabled,omitempty"`
	// This determines whether the video is recorded during the call. Defaults to false. Only relevant for `webCall` type.
	//
	// You can find the video recording at `call.artifact.videoRecordingUrl` after the call is ended.
	//
	// @default false
	VideoRecordingEnabled *bool `json:"videoRecordingEnabled,omitempty" url:"videoRecordingEnabled,omitempty"`
	// This is the plan for `call.artifact.transcript`. To disable, set `transcriptPlan.enabled` to false.
	TranscriptPlan *TranscriptPlan `json:"transcriptPlan,omitempty" url:"transcriptPlan,omitempty"`
	// This is the path where the recording will be uploaded. This is only used if you have provided S3 or GCP credentials on the Provider Credentials page in the Dashboard.
	//
	// If credential.s3PathPrefix or credential.bucketPlan.path is set, this will append to it.
	//
	// Usage:
	// - If you want to upload the recording to a specific path, set this to the path. Example: `/my-assistant-recordings`.
	// - If you want to upload the recording to the root of the bucket, set this to `/`.
	//
	// @default '/'
	RecordingPath *string `json:"recordingPath,omitempty" url:"recordingPath,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ArtifactPlan) GetRecordingEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.RecordingEnabled
}

func (a *ArtifactPlan) GetVideoRecordingEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.VideoRecordingEnabled
}

func (a *ArtifactPlan) GetTranscriptPlan() *TranscriptPlan {
	if a == nil {
		return nil
	}
	return a.TranscriptPlan
}

func (a *ArtifactPlan) GetRecordingPath() *string {
	if a == nil {
		return nil
	}
	return a.RecordingPath
}

func (a *ArtifactPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ArtifactPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler ArtifactPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArtifactPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArtifactPlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssemblyAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssemblyAiCredential) GetApiKey() string {
	if a == nil {
		return ""
	}
	return a.ApiKey
}

func (a *AssemblyAiCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AssemblyAiCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AssemblyAiCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AssemblyAiCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AssemblyAiCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AssemblyAiCredential) Provider() string {
	return a.provider
}

func (a *AssemblyAiCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssemblyAiCredential) UnmarshalJSON(data []byte) error {
	type embed AssemblyAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssemblyAiCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "assembly-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assembly-ai", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssemblyAiCredential) MarshalJSON() ([]byte, error) {
	type embed AssemblyAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "assembly-ai",
	}
	return json.Marshal(marshaler)
}

func (a *AssemblyAiCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssemblyAiTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the language that will be set for the transcription.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The WebSocket URL that the transcriber connects to.
	RealtimeUrl *string `json:"realtimeUrl,omitempty" url:"realtimeUrl,omitempty"`
	// Add up to 2500 characters of custom vocabulary.
	WordBoost []string `json:"wordBoost,omitempty" url:"wordBoost,omitempty"`
	// The duration of the end utterance silence threshold in milliseconds.
	EndUtteranceSilenceThreshold *float64 `json:"endUtteranceSilenceThreshold,omitempty" url:"endUtteranceSilenceThreshold,omitempty"`
	// Disable partial transcripts.
	// Set to `true` to not receive partial transcripts. Defaults to `false`.
	DisablePartialTranscripts *bool `json:"disablePartialTranscripts,omitempty" url:"disablePartialTranscripts,omitempty"`
	provider                  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssemblyAiTranscriber) GetRealtimeUrl() *string {
	if a == nil {
		return nil
	}
	return a.RealtimeUrl
}

func (a *AssemblyAiTranscriber) GetWordBoost() []string {
	if a == nil {
		return nil
	}
	return a.WordBoost
}

func (a *AssemblyAiTranscriber) GetEndUtteranceSilenceThreshold() *float64 {
	if a == nil {
		return nil
	}
	return a.EndUtteranceSilenceThreshold
}

func (a *AssemblyAiTranscriber) GetDisablePartialTranscripts() *bool {
	if a == nil {
		return nil
	}
	return a.DisablePartialTranscripts
}

func (a *AssemblyAiTranscriber) Provider() string {
	return a.provider
}

func (a *AssemblyAiTranscriber) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssemblyAiTranscriber) UnmarshalJSON(data []byte) error {
	type embed AssemblyAiTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssemblyAiTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "assembly-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assembly-ai", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssemblyAiTranscriber) MarshalJSON() ([]byte, error) {
	type embed AssemblyAiTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "assembly-ai",
	}
	return json.Marshal(marshaler)
}

func (a *AssemblyAiTranscriber) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignmentMutation struct {
	// This is an optional array of conditions that must be met for this mutation to be triggered.
	Conditions []*AssignmentMutationConditionsItem `json:"conditions,omitempty" url:"conditions,omitempty"`
	// This mutation assigns a new value to an existing or new variable.
	// This is the variable to assign a new value to.
	//
	// You can reference any variable in the context of the current block execution (step):
	// - "output.your-property-name" for current step's output
	// - "your-step-name.output.your-property-name" for another step's output (in the same workflow; read caveat #1)
	// - "your-block-name.output.your-property-name" for another block's output (in the same workflow; read caveat #2)
	// - "global.your-property-name" for the global context
	//
	// This needs to be the key path of the variable. If you use {{}}, it'll dereference that to the value of the variable before assignment. This can be useful if the path is dynamic. Example:
	// - "global.{{my-tool-call-step.output.my-key-name}}"
	//
	// You can also string interpolate multiple variables to get the key name:
	// - "global.{{my-tool-call-step.output.my-key-name-suffix}}-{{my-tool-call-step.output.my-key-name}}"
	//
	// The path to the new variable is created if it doesn't exist. Example:
	// - "global.this-does-not-exist.neither-does-this" will create `this-does-not-exist` object with `neither-does-this` as a key
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.
	Variable string `json:"variable" url:"variable"`
	// The value to assign to the variable.
	//
	// You can reference any variable in the context of the current block execution (step):
	// - "{{output.your-property-name}}" for current step's output
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{global.your-property-name}}" for the global context
	//
	// Or, you can use a constant:
	// - "1"
	// - "text"
	// - "true"
	// - "false"
	//
	// Or, you can mix and match with string interpolation:
	// - "{{your-property-name}}-{{input.your-property-name-2}}-1"
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.
	Value string `json:"value" url:"value"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssignmentMutation) GetConditions() []*AssignmentMutationConditionsItem {
	if a == nil {
		return nil
	}
	return a.Conditions
}

func (a *AssignmentMutation) GetVariable() string {
	if a == nil {
		return ""
	}
	return a.Variable
}

func (a *AssignmentMutation) GetValue() string {
	if a == nil {
		return ""
	}
	return a.Value
}

func (a *AssignmentMutation) Type() string {
	return a.type_
}

func (a *AssignmentMutation) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssignmentMutation) UnmarshalJSON(data []byte) error {
	type embed AssignmentMutation
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssignmentMutation(unmarshaler.embed)
	if unmarshaler.Type != "assignment" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assignment", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssignmentMutation) MarshalJSON() ([]byte, error) {
	type embed AssignmentMutation
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "assignment",
	}
	return json.Marshal(marshaler)
}

func (a *AssignmentMutation) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssignmentMutationConditionsItem struct {
	ModelBasedCondition *ModelBasedCondition
	RuleBasedCondition  *RuleBasedCondition

	typ string
}

func (a *AssignmentMutationConditionsItem) GetModelBasedCondition() *ModelBasedCondition {
	if a == nil {
		return nil
	}
	return a.ModelBasedCondition
}

func (a *AssignmentMutationConditionsItem) GetRuleBasedCondition() *RuleBasedCondition {
	if a == nil {
		return nil
	}
	return a.RuleBasedCondition
}

func (a *AssignmentMutationConditionsItem) UnmarshalJSON(data []byte) error {
	valueModelBasedCondition := new(ModelBasedCondition)
	if err := json.Unmarshal(data, &valueModelBasedCondition); err == nil {
		a.typ = "ModelBasedCondition"
		a.ModelBasedCondition = valueModelBasedCondition
		return nil
	}
	valueRuleBasedCondition := new(RuleBasedCondition)
	if err := json.Unmarshal(data, &valueRuleBasedCondition); err == nil {
		a.typ = "RuleBasedCondition"
		a.RuleBasedCondition = valueRuleBasedCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssignmentMutationConditionsItem) MarshalJSON() ([]byte, error) {
	if a.typ == "ModelBasedCondition" || a.ModelBasedCondition != nil {
		return json.Marshal(a.ModelBasedCondition)
	}
	if a.typ == "RuleBasedCondition" || a.RuleBasedCondition != nil {
		return json.Marshal(a.RuleBasedCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssignmentMutationConditionsItemVisitor interface {
	VisitModelBasedCondition(*ModelBasedCondition) error
	VisitRuleBasedCondition(*RuleBasedCondition) error
}

func (a *AssignmentMutationConditionsItem) Accept(visitor AssignmentMutationConditionsItemVisitor) error {
	if a.typ == "ModelBasedCondition" || a.ModelBasedCondition != nil {
		return visitor.VisitModelBasedCondition(a.ModelBasedCondition)
	}
	if a.typ == "RuleBasedCondition" || a.RuleBasedCondition != nil {
		return visitor.VisitRuleBasedCondition(a.RuleBasedCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantCustomEndpointingRule struct {
	// This endpointing rule is based on the last assistant message before customer started speaking.
	//
	// Flow:
	// - Assistant speaks
	// - Customer starts speaking
	// - Customer transcription comes in
	// - This rule is evaluated on the last assistant message
	// - If a match is found based on `regex`, the endpointing timeout is set to `timeoutSeconds`
	//
	// Usage:
	// - If you have yes/no questions in your use case like "are you interested in a loan?", you can set a shorter timeout.
	// - If you have questions where the customer may pause to look up information like "what's my account number?", you can set a longer timeout.
	// This is the regex pattern to match.
	//
	// Note:
	// - This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test("hello there")` will return `true`.
	//
	// Hot tip:
	// - In JavaScript, escape `\` when sending the regex pattern. Eg. `"hello\sthere"` will be sent over the wire as `"hellosthere"`. Send `"hello\\sthere"` instead.
	// - `RegExp.test` does substring matching, so `/cat/.test("I love cats")` will return `true`. To do full string matching, send "^cat$".
	Regex string `json:"regex" url:"regex"`
	// These are the options for the regex match. Defaults to all disabled.
	//
	// @default []
	RegexOptions []*RegexOption `json:"regexOptions,omitempty" url:"regexOptions,omitempty"`
	// This is the endpointing timeout in seconds, if the rule is matched.
	TimeoutSeconds float64 `json:"timeoutSeconds" url:"timeoutSeconds"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantCustomEndpointingRule) GetRegex() string {
	if a == nil {
		return ""
	}
	return a.Regex
}

func (a *AssistantCustomEndpointingRule) GetRegexOptions() []*RegexOption {
	if a == nil {
		return nil
	}
	return a.RegexOptions
}

func (a *AssistantCustomEndpointingRule) GetTimeoutSeconds() float64 {
	if a == nil {
		return 0
	}
	return a.TimeoutSeconds
}

func (a *AssistantCustomEndpointingRule) Type() string {
	return a.type_
}

func (a *AssistantCustomEndpointingRule) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantCustomEndpointingRule) UnmarshalJSON(data []byte) error {
	type embed AssistantCustomEndpointingRule
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantCustomEndpointingRule(unmarshaler.embed)
	if unmarshaler.Type != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assistant", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantCustomEndpointingRule) MarshalJSON() ([]byte, error) {
	type embed AssistantCustomEndpointingRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "assistant",
	}
	return json.Marshal(marshaler)
}

func (a *AssistantCustomEndpointingRule) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantOverrides struct {
	// These are the options for the assistant's transcriber.
	Transcriber *AssistantOverridesTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's LLM.
	Model *AssistantOverridesModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's voice.
	Voice *AssistantOverridesVoice `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage *string `json:"firstMessage,omitempty" url:"firstMessage,omitempty"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *AssistantOverridesFirstMessageMode `json:"firstMessageMode,omitempty" url:"firstMessageMode,omitempty"`
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []AssistantOverridesClientMessagesItem `json:"clientMessages,omitempty" url:"clientMessages,omitempty"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []AssistantOverridesServerMessagesItem `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"silenceTimeoutSeconds,omitempty"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"maxDurationSeconds,omitempty"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	BackgroundSound *AssistantOverridesBackgroundSound `json:"backgroundSound,omitempty" url:"backgroundSound,omitempty"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"backgroundDenoisingEnabled,omitempty"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"modelOutputInMessagesEnabled,omitempty"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"transportConfigurations,omitempty"`
	// These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.
	Credentials []*AssistantOverridesCredentialsItem `json:"credentials,omitempty" url:"credentials,omitempty"`
	// These are values that will be used to replace the template variables in the assistant messages and other text-based fields.
	// This uses LiquidJS syntax. https://liquidjs.com/tutorials/intro-to-liquid.html
	//
	// So for example, `{{ name }}` will be replaced with the value of `name` in `variableValues`.
	// `{{"now" | date: "%b %d, %Y, %I:%M %p", "America/New_York"}}` will be replaced with the current date and time in New York.
	//
	//	Some VAPI reserved defaults:
	//	- *customer* - the customer object
	VariableValues map[string]interface{} `json:"variableValues,omitempty" url:"variableValues,omitempty"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *TwilioVoicemailDetection `json:"voicemailDetection,omitempty" url:"voicemailDetection,omitempty"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"voicemailMessage,omitempty"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"endCallMessage,omitempty"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string `json:"endCallPhrases,omitempty" url:"endCallPhrases,omitempty"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"analysisPlan,omitempty"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"messagePlan,omitempty"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"startSpeakingPlan,omitempty"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"stopSpeakingPlan,omitempty"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"monitorPlan,omitempty"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"credentialIds,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server.url
	// 2. phoneNumber.serverUrl
	// 3. org.serverUrl
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantOverrides) GetTranscriber() *AssistantOverridesTranscriber {
	if a == nil {
		return nil
	}
	return a.Transcriber
}

func (a *AssistantOverrides) GetModel() *AssistantOverridesModel {
	if a == nil {
		return nil
	}
	return a.Model
}

func (a *AssistantOverrides) GetVoice() *AssistantOverridesVoice {
	if a == nil {
		return nil
	}
	return a.Voice
}

func (a *AssistantOverrides) GetFirstMessage() *string {
	if a == nil {
		return nil
	}
	return a.FirstMessage
}

func (a *AssistantOverrides) GetFirstMessageMode() *AssistantOverridesFirstMessageMode {
	if a == nil {
		return nil
	}
	return a.FirstMessageMode
}

func (a *AssistantOverrides) GetHipaaEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.HipaaEnabled
}

func (a *AssistantOverrides) GetClientMessages() []AssistantOverridesClientMessagesItem {
	if a == nil {
		return nil
	}
	return a.ClientMessages
}

func (a *AssistantOverrides) GetServerMessages() []AssistantOverridesServerMessagesItem {
	if a == nil {
		return nil
	}
	return a.ServerMessages
}

func (a *AssistantOverrides) GetSilenceTimeoutSeconds() *float64 {
	if a == nil {
		return nil
	}
	return a.SilenceTimeoutSeconds
}

func (a *AssistantOverrides) GetMaxDurationSeconds() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxDurationSeconds
}

func (a *AssistantOverrides) GetBackgroundSound() *AssistantOverridesBackgroundSound {
	if a == nil {
		return nil
	}
	return a.BackgroundSound
}

func (a *AssistantOverrides) GetBackgroundDenoisingEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.BackgroundDenoisingEnabled
}

func (a *AssistantOverrides) GetModelOutputInMessagesEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.ModelOutputInMessagesEnabled
}

func (a *AssistantOverrides) GetTransportConfigurations() []*TransportConfigurationTwilio {
	if a == nil {
		return nil
	}
	return a.TransportConfigurations
}

func (a *AssistantOverrides) GetCredentials() []*AssistantOverridesCredentialsItem {
	if a == nil {
		return nil
	}
	return a.Credentials
}

func (a *AssistantOverrides) GetVariableValues() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.VariableValues
}

func (a *AssistantOverrides) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AssistantOverrides) GetVoicemailDetection() *TwilioVoicemailDetection {
	if a == nil {
		return nil
	}
	return a.VoicemailDetection
}

func (a *AssistantOverrides) GetVoicemailMessage() *string {
	if a == nil {
		return nil
	}
	return a.VoicemailMessage
}

func (a *AssistantOverrides) GetEndCallMessage() *string {
	if a == nil {
		return nil
	}
	return a.EndCallMessage
}

func (a *AssistantOverrides) GetEndCallPhrases() []string {
	if a == nil {
		return nil
	}
	return a.EndCallPhrases
}

func (a *AssistantOverrides) GetMetadata() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Metadata
}

func (a *AssistantOverrides) GetAnalysisPlan() *AnalysisPlan {
	if a == nil {
		return nil
	}
	return a.AnalysisPlan
}

func (a *AssistantOverrides) GetArtifactPlan() *ArtifactPlan {
	if a == nil {
		return nil
	}
	return a.ArtifactPlan
}

func (a *AssistantOverrides) GetMessagePlan() *MessagePlan {
	if a == nil {
		return nil
	}
	return a.MessagePlan
}

func (a *AssistantOverrides) GetStartSpeakingPlan() *StartSpeakingPlan {
	if a == nil {
		return nil
	}
	return a.StartSpeakingPlan
}

func (a *AssistantOverrides) GetStopSpeakingPlan() *StopSpeakingPlan {
	if a == nil {
		return nil
	}
	return a.StopSpeakingPlan
}

func (a *AssistantOverrides) GetMonitorPlan() *MonitorPlan {
	if a == nil {
		return nil
	}
	return a.MonitorPlan
}

func (a *AssistantOverrides) GetCredentialIds() []string {
	if a == nil {
		return nil
	}
	return a.CredentialIds
}

func (a *AssistantOverrides) GetServer() *Server {
	if a == nil {
		return nil
	}
	return a.Server
}

func (a *AssistantOverrides) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantOverrides(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantOverrides) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
type AssistantOverridesBackgroundSound string

const (
	AssistantOverridesBackgroundSoundOff    AssistantOverridesBackgroundSound = "off"
	AssistantOverridesBackgroundSoundOffice AssistantOverridesBackgroundSound = "office"
)

func NewAssistantOverridesBackgroundSoundFromString(s string) (AssistantOverridesBackgroundSound, error) {
	switch s {
	case "off":
		return AssistantOverridesBackgroundSoundOff, nil
	case "office":
		return AssistantOverridesBackgroundSoundOffice, nil
	}
	var t AssistantOverridesBackgroundSound
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesBackgroundSound) Ptr() *AssistantOverridesBackgroundSound {
	return &a
}

type AssistantOverridesClientMessagesItem string

const (
	AssistantOverridesClientMessagesItemConversationUpdate AssistantOverridesClientMessagesItem = "conversation-update"
	AssistantOverridesClientMessagesItemFunctionCall       AssistantOverridesClientMessagesItem = "function-call"
	AssistantOverridesClientMessagesItemFunctionCallResult AssistantOverridesClientMessagesItem = "function-call-result"
	AssistantOverridesClientMessagesItemHang               AssistantOverridesClientMessagesItem = "hang"
	AssistantOverridesClientMessagesItemLanguageChanged    AssistantOverridesClientMessagesItem = "language-changed"
	AssistantOverridesClientMessagesItemMetadata           AssistantOverridesClientMessagesItem = "metadata"
	AssistantOverridesClientMessagesItemModelOutput        AssistantOverridesClientMessagesItem = "model-output"
	AssistantOverridesClientMessagesItemSpeechUpdate       AssistantOverridesClientMessagesItem = "speech-update"
	AssistantOverridesClientMessagesItemStatusUpdate       AssistantOverridesClientMessagesItem = "status-update"
	AssistantOverridesClientMessagesItemTranscript         AssistantOverridesClientMessagesItem = "transcript"
	AssistantOverridesClientMessagesItemToolCalls          AssistantOverridesClientMessagesItem = "tool-calls"
	AssistantOverridesClientMessagesItemToolCallsResult    AssistantOverridesClientMessagesItem = "tool-calls-result"
	AssistantOverridesClientMessagesItemTransferUpdate     AssistantOverridesClientMessagesItem = "transfer-update"
	AssistantOverridesClientMessagesItemUserInterrupted    AssistantOverridesClientMessagesItem = "user-interrupted"
	AssistantOverridesClientMessagesItemVoiceInput         AssistantOverridesClientMessagesItem = "voice-input"
)

func NewAssistantOverridesClientMessagesItemFromString(s string) (AssistantOverridesClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantOverridesClientMessagesItemConversationUpdate, nil
	case "function-call":
		return AssistantOverridesClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return AssistantOverridesClientMessagesItemFunctionCallResult, nil
	case "hang":
		return AssistantOverridesClientMessagesItemHang, nil
	case "language-changed":
		return AssistantOverridesClientMessagesItemLanguageChanged, nil
	case "metadata":
		return AssistantOverridesClientMessagesItemMetadata, nil
	case "model-output":
		return AssistantOverridesClientMessagesItemModelOutput, nil
	case "speech-update":
		return AssistantOverridesClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantOverridesClientMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantOverridesClientMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantOverridesClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return AssistantOverridesClientMessagesItemToolCallsResult, nil
	case "transfer-update":
		return AssistantOverridesClientMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return AssistantOverridesClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantOverridesClientMessagesItemVoiceInput, nil
	}
	var t AssistantOverridesClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesClientMessagesItem) Ptr() *AssistantOverridesClientMessagesItem {
	return &a
}

type AssistantOverridesCredentialsItem struct {
	CreateAnthropicCredentialDto    *CreateAnthropicCredentialDto
	CreateAnyscaleCredentialDto     *CreateAnyscaleCredentialDto
	CreateAssemblyAiCredentialDto   *CreateAssemblyAiCredentialDto
	CreateAzureOpenAiCredentialDto  *CreateAzureOpenAiCredentialDto
	CreateAzureCredentialDto        *CreateAzureCredentialDto
	CreateByoSipTrunkCredentialDto  *CreateByoSipTrunkCredentialDto
	CreateCartesiaCredentialDto     *CreateCartesiaCredentialDto
	CreateCloudflareCredentialDto   *CreateCloudflareCredentialDto
	CreateCustomLlmCredentialDto    *CreateCustomLlmCredentialDto
	CreateDeepgramCredentialDto     *CreateDeepgramCredentialDto
	CreateDeepInfraCredentialDto    *CreateDeepInfraCredentialDto
	CreateDeepSeekCredentialDto     *CreateDeepSeekCredentialDto
	CreateElevenLabsCredentialDto   *CreateElevenLabsCredentialDto
	CreateGcpCredentialDto          *CreateGcpCredentialDto
	CreateGladiaCredentialDto       *CreateGladiaCredentialDto
	CreateGoHighLevelCredentialDto  *CreateGoHighLevelCredentialDto
	CreateGroqCredentialDto         *CreateGroqCredentialDto
	CreateLangfuseCredentialDto     *CreateLangfuseCredentialDto
	CreateLmntCredentialDto         *CreateLmntCredentialDto
	CreateMakeCredentialDto         *CreateMakeCredentialDto
	CreateOpenAiCredentialDto       *CreateOpenAiCredentialDto
	CreateOpenRouterCredentialDto   *CreateOpenRouterCredentialDto
	CreatePerplexityAiCredentialDto *CreatePerplexityAiCredentialDto
	CreatePlayHtCredentialDto       *CreatePlayHtCredentialDto
	CreateRimeAiCredentialDto       *CreateRimeAiCredentialDto
	CreateRunpodCredentialDto       *CreateRunpodCredentialDto
	CreateS3CredentialDto           *CreateS3CredentialDto
	CreateSmallestAiCredentialDto   *CreateSmallestAiCredentialDto
	CreateTavusCredentialDto        *CreateTavusCredentialDto
	CreateTogetherAiCredentialDto   *CreateTogetherAiCredentialDto
	CreateTwilioCredentialDto       *CreateTwilioCredentialDto
	CreateVonageCredentialDto       *CreateVonageCredentialDto
	CreateWebhookCredentialDto      *CreateWebhookCredentialDto
	CreateXAiCredentialDto          *CreateXAiCredentialDto

	typ string
}

func (a *AssistantOverridesCredentialsItem) GetCreateAnthropicCredentialDto() *CreateAnthropicCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAnthropicCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAnyscaleCredentialDto() *CreateAnyscaleCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAnyscaleCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAssemblyAiCredentialDto() *CreateAssemblyAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAssemblyAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAzureOpenAiCredentialDto() *CreateAzureOpenAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAzureOpenAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateAzureCredentialDto() *CreateAzureCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateAzureCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateByoSipTrunkCredentialDto() *CreateByoSipTrunkCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateByoSipTrunkCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateCartesiaCredentialDto() *CreateCartesiaCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateCartesiaCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateCloudflareCredentialDto() *CreateCloudflareCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateCloudflareCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateCustomLlmCredentialDto() *CreateCustomLlmCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateCustomLlmCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateDeepgramCredentialDto() *CreateDeepgramCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateDeepgramCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateDeepInfraCredentialDto() *CreateDeepInfraCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateDeepInfraCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateDeepSeekCredentialDto() *CreateDeepSeekCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateDeepSeekCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateElevenLabsCredentialDto() *CreateElevenLabsCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateElevenLabsCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGcpCredentialDto() *CreateGcpCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGcpCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGladiaCredentialDto() *CreateGladiaCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGladiaCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGoHighLevelCredentialDto() *CreateGoHighLevelCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGoHighLevelCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateGroqCredentialDto() *CreateGroqCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateGroqCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateLangfuseCredentialDto() *CreateLangfuseCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateLangfuseCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateLmntCredentialDto() *CreateLmntCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateLmntCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateMakeCredentialDto() *CreateMakeCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateMakeCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateOpenAiCredentialDto() *CreateOpenAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateOpenAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateOpenRouterCredentialDto() *CreateOpenRouterCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateOpenRouterCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreatePerplexityAiCredentialDto() *CreatePerplexityAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreatePerplexityAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreatePlayHtCredentialDto() *CreatePlayHtCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreatePlayHtCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateRimeAiCredentialDto() *CreateRimeAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateRimeAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateRunpodCredentialDto() *CreateRunpodCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateRunpodCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateS3CredentialDto() *CreateS3CredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateS3CredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateSmallestAiCredentialDto() *CreateSmallestAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateSmallestAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateTavusCredentialDto() *CreateTavusCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateTavusCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateTogetherAiCredentialDto() *CreateTogetherAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateTogetherAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateTwilioCredentialDto() *CreateTwilioCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateTwilioCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateVonageCredentialDto() *CreateVonageCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateVonageCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateWebhookCredentialDto() *CreateWebhookCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateWebhookCredentialDto
}

func (a *AssistantOverridesCredentialsItem) GetCreateXAiCredentialDto() *CreateXAiCredentialDto {
	if a == nil {
		return nil
	}
	return a.CreateXAiCredentialDto
}

func (a *AssistantOverridesCredentialsItem) UnmarshalJSON(data []byte) error {
	valueCreateAnthropicCredentialDto := new(CreateAnthropicCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAnthropicCredentialDto); err == nil {
		a.typ = "CreateAnthropicCredentialDto"
		a.CreateAnthropicCredentialDto = valueCreateAnthropicCredentialDto
		return nil
	}
	valueCreateAnyscaleCredentialDto := new(CreateAnyscaleCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAnyscaleCredentialDto); err == nil {
		a.typ = "CreateAnyscaleCredentialDto"
		a.CreateAnyscaleCredentialDto = valueCreateAnyscaleCredentialDto
		return nil
	}
	valueCreateAssemblyAiCredentialDto := new(CreateAssemblyAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAssemblyAiCredentialDto); err == nil {
		a.typ = "CreateAssemblyAiCredentialDto"
		a.CreateAssemblyAiCredentialDto = valueCreateAssemblyAiCredentialDto
		return nil
	}
	valueCreateAzureOpenAiCredentialDto := new(CreateAzureOpenAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAzureOpenAiCredentialDto); err == nil {
		a.typ = "CreateAzureOpenAiCredentialDto"
		a.CreateAzureOpenAiCredentialDto = valueCreateAzureOpenAiCredentialDto
		return nil
	}
	valueCreateAzureCredentialDto := new(CreateAzureCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAzureCredentialDto); err == nil {
		a.typ = "CreateAzureCredentialDto"
		a.CreateAzureCredentialDto = valueCreateAzureCredentialDto
		return nil
	}
	valueCreateByoSipTrunkCredentialDto := new(CreateByoSipTrunkCredentialDto)
	if err := json.Unmarshal(data, &valueCreateByoSipTrunkCredentialDto); err == nil {
		a.typ = "CreateByoSipTrunkCredentialDto"
		a.CreateByoSipTrunkCredentialDto = valueCreateByoSipTrunkCredentialDto
		return nil
	}
	valueCreateCartesiaCredentialDto := new(CreateCartesiaCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCartesiaCredentialDto); err == nil {
		a.typ = "CreateCartesiaCredentialDto"
		a.CreateCartesiaCredentialDto = valueCreateCartesiaCredentialDto
		return nil
	}
	valueCreateCloudflareCredentialDto := new(CreateCloudflareCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCloudflareCredentialDto); err == nil {
		a.typ = "CreateCloudflareCredentialDto"
		a.CreateCloudflareCredentialDto = valueCreateCloudflareCredentialDto
		return nil
	}
	valueCreateCustomLlmCredentialDto := new(CreateCustomLlmCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCustomLlmCredentialDto); err == nil {
		a.typ = "CreateCustomLlmCredentialDto"
		a.CreateCustomLlmCredentialDto = valueCreateCustomLlmCredentialDto
		return nil
	}
	valueCreateDeepgramCredentialDto := new(CreateDeepgramCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepgramCredentialDto); err == nil {
		a.typ = "CreateDeepgramCredentialDto"
		a.CreateDeepgramCredentialDto = valueCreateDeepgramCredentialDto
		return nil
	}
	valueCreateDeepInfraCredentialDto := new(CreateDeepInfraCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepInfraCredentialDto); err == nil {
		a.typ = "CreateDeepInfraCredentialDto"
		a.CreateDeepInfraCredentialDto = valueCreateDeepInfraCredentialDto
		return nil
	}
	valueCreateDeepSeekCredentialDto := new(CreateDeepSeekCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepSeekCredentialDto); err == nil {
		a.typ = "CreateDeepSeekCredentialDto"
		a.CreateDeepSeekCredentialDto = valueCreateDeepSeekCredentialDto
		return nil
	}
	valueCreateElevenLabsCredentialDto := new(CreateElevenLabsCredentialDto)
	if err := json.Unmarshal(data, &valueCreateElevenLabsCredentialDto); err == nil {
		a.typ = "CreateElevenLabsCredentialDto"
		a.CreateElevenLabsCredentialDto = valueCreateElevenLabsCredentialDto
		return nil
	}
	valueCreateGcpCredentialDto := new(CreateGcpCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGcpCredentialDto); err == nil {
		a.typ = "CreateGcpCredentialDto"
		a.CreateGcpCredentialDto = valueCreateGcpCredentialDto
		return nil
	}
	valueCreateGladiaCredentialDto := new(CreateGladiaCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGladiaCredentialDto); err == nil {
		a.typ = "CreateGladiaCredentialDto"
		a.CreateGladiaCredentialDto = valueCreateGladiaCredentialDto
		return nil
	}
	valueCreateGoHighLevelCredentialDto := new(CreateGoHighLevelCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCredentialDto); err == nil {
		a.typ = "CreateGoHighLevelCredentialDto"
		a.CreateGoHighLevelCredentialDto = valueCreateGoHighLevelCredentialDto
		return nil
	}
	valueCreateGroqCredentialDto := new(CreateGroqCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGroqCredentialDto); err == nil {
		a.typ = "CreateGroqCredentialDto"
		a.CreateGroqCredentialDto = valueCreateGroqCredentialDto
		return nil
	}
	valueCreateLangfuseCredentialDto := new(CreateLangfuseCredentialDto)
	if err := json.Unmarshal(data, &valueCreateLangfuseCredentialDto); err == nil {
		a.typ = "CreateLangfuseCredentialDto"
		a.CreateLangfuseCredentialDto = valueCreateLangfuseCredentialDto
		return nil
	}
	valueCreateLmntCredentialDto := new(CreateLmntCredentialDto)
	if err := json.Unmarshal(data, &valueCreateLmntCredentialDto); err == nil {
		a.typ = "CreateLmntCredentialDto"
		a.CreateLmntCredentialDto = valueCreateLmntCredentialDto
		return nil
	}
	valueCreateMakeCredentialDto := new(CreateMakeCredentialDto)
	if err := json.Unmarshal(data, &valueCreateMakeCredentialDto); err == nil {
		a.typ = "CreateMakeCredentialDto"
		a.CreateMakeCredentialDto = valueCreateMakeCredentialDto
		return nil
	}
	valueCreateOpenAiCredentialDto := new(CreateOpenAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateOpenAiCredentialDto); err == nil {
		a.typ = "CreateOpenAiCredentialDto"
		a.CreateOpenAiCredentialDto = valueCreateOpenAiCredentialDto
		return nil
	}
	valueCreateOpenRouterCredentialDto := new(CreateOpenRouterCredentialDto)
	if err := json.Unmarshal(data, &valueCreateOpenRouterCredentialDto); err == nil {
		a.typ = "CreateOpenRouterCredentialDto"
		a.CreateOpenRouterCredentialDto = valueCreateOpenRouterCredentialDto
		return nil
	}
	valueCreatePerplexityAiCredentialDto := new(CreatePerplexityAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreatePerplexityAiCredentialDto); err == nil {
		a.typ = "CreatePerplexityAiCredentialDto"
		a.CreatePerplexityAiCredentialDto = valueCreatePerplexityAiCredentialDto
		return nil
	}
	valueCreatePlayHtCredentialDto := new(CreatePlayHtCredentialDto)
	if err := json.Unmarshal(data, &valueCreatePlayHtCredentialDto); err == nil {
		a.typ = "CreatePlayHtCredentialDto"
		a.CreatePlayHtCredentialDto = valueCreatePlayHtCredentialDto
		return nil
	}
	valueCreateRimeAiCredentialDto := new(CreateRimeAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateRimeAiCredentialDto); err == nil {
		a.typ = "CreateRimeAiCredentialDto"
		a.CreateRimeAiCredentialDto = valueCreateRimeAiCredentialDto
		return nil
	}
	valueCreateRunpodCredentialDto := new(CreateRunpodCredentialDto)
	if err := json.Unmarshal(data, &valueCreateRunpodCredentialDto); err == nil {
		a.typ = "CreateRunpodCredentialDto"
		a.CreateRunpodCredentialDto = valueCreateRunpodCredentialDto
		return nil
	}
	valueCreateS3CredentialDto := new(CreateS3CredentialDto)
	if err := json.Unmarshal(data, &valueCreateS3CredentialDto); err == nil {
		a.typ = "CreateS3CredentialDto"
		a.CreateS3CredentialDto = valueCreateS3CredentialDto
		return nil
	}
	valueCreateSmallestAiCredentialDto := new(CreateSmallestAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSmallestAiCredentialDto); err == nil {
		a.typ = "CreateSmallestAiCredentialDto"
		a.CreateSmallestAiCredentialDto = valueCreateSmallestAiCredentialDto
		return nil
	}
	valueCreateTavusCredentialDto := new(CreateTavusCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTavusCredentialDto); err == nil {
		a.typ = "CreateTavusCredentialDto"
		a.CreateTavusCredentialDto = valueCreateTavusCredentialDto
		return nil
	}
	valueCreateTogetherAiCredentialDto := new(CreateTogetherAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTogetherAiCredentialDto); err == nil {
		a.typ = "CreateTogetherAiCredentialDto"
		a.CreateTogetherAiCredentialDto = valueCreateTogetherAiCredentialDto
		return nil
	}
	valueCreateTwilioCredentialDto := new(CreateTwilioCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTwilioCredentialDto); err == nil {
		a.typ = "CreateTwilioCredentialDto"
		a.CreateTwilioCredentialDto = valueCreateTwilioCredentialDto
		return nil
	}
	valueCreateVonageCredentialDto := new(CreateVonageCredentialDto)
	if err := json.Unmarshal(data, &valueCreateVonageCredentialDto); err == nil {
		a.typ = "CreateVonageCredentialDto"
		a.CreateVonageCredentialDto = valueCreateVonageCredentialDto
		return nil
	}
	valueCreateWebhookCredentialDto := new(CreateWebhookCredentialDto)
	if err := json.Unmarshal(data, &valueCreateWebhookCredentialDto); err == nil {
		a.typ = "CreateWebhookCredentialDto"
		a.CreateWebhookCredentialDto = valueCreateWebhookCredentialDto
		return nil
	}
	valueCreateXAiCredentialDto := new(CreateXAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateXAiCredentialDto); err == nil {
		a.typ = "CreateXAiCredentialDto"
		a.CreateXAiCredentialDto = valueCreateXAiCredentialDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesCredentialsItem) MarshalJSON() ([]byte, error) {
	if a.typ == "CreateAnthropicCredentialDto" || a.CreateAnthropicCredentialDto != nil {
		return json.Marshal(a.CreateAnthropicCredentialDto)
	}
	if a.typ == "CreateAnyscaleCredentialDto" || a.CreateAnyscaleCredentialDto != nil {
		return json.Marshal(a.CreateAnyscaleCredentialDto)
	}
	if a.typ == "CreateAssemblyAiCredentialDto" || a.CreateAssemblyAiCredentialDto != nil {
		return json.Marshal(a.CreateAssemblyAiCredentialDto)
	}
	if a.typ == "CreateAzureOpenAiCredentialDto" || a.CreateAzureOpenAiCredentialDto != nil {
		return json.Marshal(a.CreateAzureOpenAiCredentialDto)
	}
	if a.typ == "CreateAzureCredentialDto" || a.CreateAzureCredentialDto != nil {
		return json.Marshal(a.CreateAzureCredentialDto)
	}
	if a.typ == "CreateByoSipTrunkCredentialDto" || a.CreateByoSipTrunkCredentialDto != nil {
		return json.Marshal(a.CreateByoSipTrunkCredentialDto)
	}
	if a.typ == "CreateCartesiaCredentialDto" || a.CreateCartesiaCredentialDto != nil {
		return json.Marshal(a.CreateCartesiaCredentialDto)
	}
	if a.typ == "CreateCloudflareCredentialDto" || a.CreateCloudflareCredentialDto != nil {
		return json.Marshal(a.CreateCloudflareCredentialDto)
	}
	if a.typ == "CreateCustomLlmCredentialDto" || a.CreateCustomLlmCredentialDto != nil {
		return json.Marshal(a.CreateCustomLlmCredentialDto)
	}
	if a.typ == "CreateDeepgramCredentialDto" || a.CreateDeepgramCredentialDto != nil {
		return json.Marshal(a.CreateDeepgramCredentialDto)
	}
	if a.typ == "CreateDeepInfraCredentialDto" || a.CreateDeepInfraCredentialDto != nil {
		return json.Marshal(a.CreateDeepInfraCredentialDto)
	}
	if a.typ == "CreateDeepSeekCredentialDto" || a.CreateDeepSeekCredentialDto != nil {
		return json.Marshal(a.CreateDeepSeekCredentialDto)
	}
	if a.typ == "CreateElevenLabsCredentialDto" || a.CreateElevenLabsCredentialDto != nil {
		return json.Marshal(a.CreateElevenLabsCredentialDto)
	}
	if a.typ == "CreateGcpCredentialDto" || a.CreateGcpCredentialDto != nil {
		return json.Marshal(a.CreateGcpCredentialDto)
	}
	if a.typ == "CreateGladiaCredentialDto" || a.CreateGladiaCredentialDto != nil {
		return json.Marshal(a.CreateGladiaCredentialDto)
	}
	if a.typ == "CreateGoHighLevelCredentialDto" || a.CreateGoHighLevelCredentialDto != nil {
		return json.Marshal(a.CreateGoHighLevelCredentialDto)
	}
	if a.typ == "CreateGroqCredentialDto" || a.CreateGroqCredentialDto != nil {
		return json.Marshal(a.CreateGroqCredentialDto)
	}
	if a.typ == "CreateLangfuseCredentialDto" || a.CreateLangfuseCredentialDto != nil {
		return json.Marshal(a.CreateLangfuseCredentialDto)
	}
	if a.typ == "CreateLmntCredentialDto" || a.CreateLmntCredentialDto != nil {
		return json.Marshal(a.CreateLmntCredentialDto)
	}
	if a.typ == "CreateMakeCredentialDto" || a.CreateMakeCredentialDto != nil {
		return json.Marshal(a.CreateMakeCredentialDto)
	}
	if a.typ == "CreateOpenAiCredentialDto" || a.CreateOpenAiCredentialDto != nil {
		return json.Marshal(a.CreateOpenAiCredentialDto)
	}
	if a.typ == "CreateOpenRouterCredentialDto" || a.CreateOpenRouterCredentialDto != nil {
		return json.Marshal(a.CreateOpenRouterCredentialDto)
	}
	if a.typ == "CreatePerplexityAiCredentialDto" || a.CreatePerplexityAiCredentialDto != nil {
		return json.Marshal(a.CreatePerplexityAiCredentialDto)
	}
	if a.typ == "CreatePlayHtCredentialDto" || a.CreatePlayHtCredentialDto != nil {
		return json.Marshal(a.CreatePlayHtCredentialDto)
	}
	if a.typ == "CreateRimeAiCredentialDto" || a.CreateRimeAiCredentialDto != nil {
		return json.Marshal(a.CreateRimeAiCredentialDto)
	}
	if a.typ == "CreateRunpodCredentialDto" || a.CreateRunpodCredentialDto != nil {
		return json.Marshal(a.CreateRunpodCredentialDto)
	}
	if a.typ == "CreateS3CredentialDto" || a.CreateS3CredentialDto != nil {
		return json.Marshal(a.CreateS3CredentialDto)
	}
	if a.typ == "CreateSmallestAiCredentialDto" || a.CreateSmallestAiCredentialDto != nil {
		return json.Marshal(a.CreateSmallestAiCredentialDto)
	}
	if a.typ == "CreateTavusCredentialDto" || a.CreateTavusCredentialDto != nil {
		return json.Marshal(a.CreateTavusCredentialDto)
	}
	if a.typ == "CreateTogetherAiCredentialDto" || a.CreateTogetherAiCredentialDto != nil {
		return json.Marshal(a.CreateTogetherAiCredentialDto)
	}
	if a.typ == "CreateTwilioCredentialDto" || a.CreateTwilioCredentialDto != nil {
		return json.Marshal(a.CreateTwilioCredentialDto)
	}
	if a.typ == "CreateVonageCredentialDto" || a.CreateVonageCredentialDto != nil {
		return json.Marshal(a.CreateVonageCredentialDto)
	}
	if a.typ == "CreateWebhookCredentialDto" || a.CreateWebhookCredentialDto != nil {
		return json.Marshal(a.CreateWebhookCredentialDto)
	}
	if a.typ == "CreateXAiCredentialDto" || a.CreateXAiCredentialDto != nil {
		return json.Marshal(a.CreateXAiCredentialDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesCredentialsItemVisitor interface {
	VisitCreateAnthropicCredentialDto(*CreateAnthropicCredentialDto) error
	VisitCreateAnyscaleCredentialDto(*CreateAnyscaleCredentialDto) error
	VisitCreateAssemblyAiCredentialDto(*CreateAssemblyAiCredentialDto) error
	VisitCreateAzureOpenAiCredentialDto(*CreateAzureOpenAiCredentialDto) error
	VisitCreateAzureCredentialDto(*CreateAzureCredentialDto) error
	VisitCreateByoSipTrunkCredentialDto(*CreateByoSipTrunkCredentialDto) error
	VisitCreateCartesiaCredentialDto(*CreateCartesiaCredentialDto) error
	VisitCreateCloudflareCredentialDto(*CreateCloudflareCredentialDto) error
	VisitCreateCustomLlmCredentialDto(*CreateCustomLlmCredentialDto) error
	VisitCreateDeepgramCredentialDto(*CreateDeepgramCredentialDto) error
	VisitCreateDeepInfraCredentialDto(*CreateDeepInfraCredentialDto) error
	VisitCreateDeepSeekCredentialDto(*CreateDeepSeekCredentialDto) error
	VisitCreateElevenLabsCredentialDto(*CreateElevenLabsCredentialDto) error
	VisitCreateGcpCredentialDto(*CreateGcpCredentialDto) error
	VisitCreateGladiaCredentialDto(*CreateGladiaCredentialDto) error
	VisitCreateGoHighLevelCredentialDto(*CreateGoHighLevelCredentialDto) error
	VisitCreateGroqCredentialDto(*CreateGroqCredentialDto) error
	VisitCreateLangfuseCredentialDto(*CreateLangfuseCredentialDto) error
	VisitCreateLmntCredentialDto(*CreateLmntCredentialDto) error
	VisitCreateMakeCredentialDto(*CreateMakeCredentialDto) error
	VisitCreateOpenAiCredentialDto(*CreateOpenAiCredentialDto) error
	VisitCreateOpenRouterCredentialDto(*CreateOpenRouterCredentialDto) error
	VisitCreatePerplexityAiCredentialDto(*CreatePerplexityAiCredentialDto) error
	VisitCreatePlayHtCredentialDto(*CreatePlayHtCredentialDto) error
	VisitCreateRimeAiCredentialDto(*CreateRimeAiCredentialDto) error
	VisitCreateRunpodCredentialDto(*CreateRunpodCredentialDto) error
	VisitCreateS3CredentialDto(*CreateS3CredentialDto) error
	VisitCreateSmallestAiCredentialDto(*CreateSmallestAiCredentialDto) error
	VisitCreateTavusCredentialDto(*CreateTavusCredentialDto) error
	VisitCreateTogetherAiCredentialDto(*CreateTogetherAiCredentialDto) error
	VisitCreateTwilioCredentialDto(*CreateTwilioCredentialDto) error
	VisitCreateVonageCredentialDto(*CreateVonageCredentialDto) error
	VisitCreateWebhookCredentialDto(*CreateWebhookCredentialDto) error
	VisitCreateXAiCredentialDto(*CreateXAiCredentialDto) error
}

func (a *AssistantOverridesCredentialsItem) Accept(visitor AssistantOverridesCredentialsItemVisitor) error {
	if a.typ == "CreateAnthropicCredentialDto" || a.CreateAnthropicCredentialDto != nil {
		return visitor.VisitCreateAnthropicCredentialDto(a.CreateAnthropicCredentialDto)
	}
	if a.typ == "CreateAnyscaleCredentialDto" || a.CreateAnyscaleCredentialDto != nil {
		return visitor.VisitCreateAnyscaleCredentialDto(a.CreateAnyscaleCredentialDto)
	}
	if a.typ == "CreateAssemblyAiCredentialDto" || a.CreateAssemblyAiCredentialDto != nil {
		return visitor.VisitCreateAssemblyAiCredentialDto(a.CreateAssemblyAiCredentialDto)
	}
	if a.typ == "CreateAzureOpenAiCredentialDto" || a.CreateAzureOpenAiCredentialDto != nil {
		return visitor.VisitCreateAzureOpenAiCredentialDto(a.CreateAzureOpenAiCredentialDto)
	}
	if a.typ == "CreateAzureCredentialDto" || a.CreateAzureCredentialDto != nil {
		return visitor.VisitCreateAzureCredentialDto(a.CreateAzureCredentialDto)
	}
	if a.typ == "CreateByoSipTrunkCredentialDto" || a.CreateByoSipTrunkCredentialDto != nil {
		return visitor.VisitCreateByoSipTrunkCredentialDto(a.CreateByoSipTrunkCredentialDto)
	}
	if a.typ == "CreateCartesiaCredentialDto" || a.CreateCartesiaCredentialDto != nil {
		return visitor.VisitCreateCartesiaCredentialDto(a.CreateCartesiaCredentialDto)
	}
	if a.typ == "CreateCloudflareCredentialDto" || a.CreateCloudflareCredentialDto != nil {
		return visitor.VisitCreateCloudflareCredentialDto(a.CreateCloudflareCredentialDto)
	}
	if a.typ == "CreateCustomLlmCredentialDto" || a.CreateCustomLlmCredentialDto != nil {
		return visitor.VisitCreateCustomLlmCredentialDto(a.CreateCustomLlmCredentialDto)
	}
	if a.typ == "CreateDeepgramCredentialDto" || a.CreateDeepgramCredentialDto != nil {
		return visitor.VisitCreateDeepgramCredentialDto(a.CreateDeepgramCredentialDto)
	}
	if a.typ == "CreateDeepInfraCredentialDto" || a.CreateDeepInfraCredentialDto != nil {
		return visitor.VisitCreateDeepInfraCredentialDto(a.CreateDeepInfraCredentialDto)
	}
	if a.typ == "CreateDeepSeekCredentialDto" || a.CreateDeepSeekCredentialDto != nil {
		return visitor.VisitCreateDeepSeekCredentialDto(a.CreateDeepSeekCredentialDto)
	}
	if a.typ == "CreateElevenLabsCredentialDto" || a.CreateElevenLabsCredentialDto != nil {
		return visitor.VisitCreateElevenLabsCredentialDto(a.CreateElevenLabsCredentialDto)
	}
	if a.typ == "CreateGcpCredentialDto" || a.CreateGcpCredentialDto != nil {
		return visitor.VisitCreateGcpCredentialDto(a.CreateGcpCredentialDto)
	}
	if a.typ == "CreateGladiaCredentialDto" || a.CreateGladiaCredentialDto != nil {
		return visitor.VisitCreateGladiaCredentialDto(a.CreateGladiaCredentialDto)
	}
	if a.typ == "CreateGoHighLevelCredentialDto" || a.CreateGoHighLevelCredentialDto != nil {
		return visitor.VisitCreateGoHighLevelCredentialDto(a.CreateGoHighLevelCredentialDto)
	}
	if a.typ == "CreateGroqCredentialDto" || a.CreateGroqCredentialDto != nil {
		return visitor.VisitCreateGroqCredentialDto(a.CreateGroqCredentialDto)
	}
	if a.typ == "CreateLangfuseCredentialDto" || a.CreateLangfuseCredentialDto != nil {
		return visitor.VisitCreateLangfuseCredentialDto(a.CreateLangfuseCredentialDto)
	}
	if a.typ == "CreateLmntCredentialDto" || a.CreateLmntCredentialDto != nil {
		return visitor.VisitCreateLmntCredentialDto(a.CreateLmntCredentialDto)
	}
	if a.typ == "CreateMakeCredentialDto" || a.CreateMakeCredentialDto != nil {
		return visitor.VisitCreateMakeCredentialDto(a.CreateMakeCredentialDto)
	}
	if a.typ == "CreateOpenAiCredentialDto" || a.CreateOpenAiCredentialDto != nil {
		return visitor.VisitCreateOpenAiCredentialDto(a.CreateOpenAiCredentialDto)
	}
	if a.typ == "CreateOpenRouterCredentialDto" || a.CreateOpenRouterCredentialDto != nil {
		return visitor.VisitCreateOpenRouterCredentialDto(a.CreateOpenRouterCredentialDto)
	}
	if a.typ == "CreatePerplexityAiCredentialDto" || a.CreatePerplexityAiCredentialDto != nil {
		return visitor.VisitCreatePerplexityAiCredentialDto(a.CreatePerplexityAiCredentialDto)
	}
	if a.typ == "CreatePlayHtCredentialDto" || a.CreatePlayHtCredentialDto != nil {
		return visitor.VisitCreatePlayHtCredentialDto(a.CreatePlayHtCredentialDto)
	}
	if a.typ == "CreateRimeAiCredentialDto" || a.CreateRimeAiCredentialDto != nil {
		return visitor.VisitCreateRimeAiCredentialDto(a.CreateRimeAiCredentialDto)
	}
	if a.typ == "CreateRunpodCredentialDto" || a.CreateRunpodCredentialDto != nil {
		return visitor.VisitCreateRunpodCredentialDto(a.CreateRunpodCredentialDto)
	}
	if a.typ == "CreateS3CredentialDto" || a.CreateS3CredentialDto != nil {
		return visitor.VisitCreateS3CredentialDto(a.CreateS3CredentialDto)
	}
	if a.typ == "CreateSmallestAiCredentialDto" || a.CreateSmallestAiCredentialDto != nil {
		return visitor.VisitCreateSmallestAiCredentialDto(a.CreateSmallestAiCredentialDto)
	}
	if a.typ == "CreateTavusCredentialDto" || a.CreateTavusCredentialDto != nil {
		return visitor.VisitCreateTavusCredentialDto(a.CreateTavusCredentialDto)
	}
	if a.typ == "CreateTogetherAiCredentialDto" || a.CreateTogetherAiCredentialDto != nil {
		return visitor.VisitCreateTogetherAiCredentialDto(a.CreateTogetherAiCredentialDto)
	}
	if a.typ == "CreateTwilioCredentialDto" || a.CreateTwilioCredentialDto != nil {
		return visitor.VisitCreateTwilioCredentialDto(a.CreateTwilioCredentialDto)
	}
	if a.typ == "CreateVonageCredentialDto" || a.CreateVonageCredentialDto != nil {
		return visitor.VisitCreateVonageCredentialDto(a.CreateVonageCredentialDto)
	}
	if a.typ == "CreateWebhookCredentialDto" || a.CreateWebhookCredentialDto != nil {
		return visitor.VisitCreateWebhookCredentialDto(a.CreateWebhookCredentialDto)
	}
	if a.typ == "CreateXAiCredentialDto" || a.CreateXAiCredentialDto != nil {
		return visitor.VisitCreateXAiCredentialDto(a.CreateXAiCredentialDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type AssistantOverridesFirstMessageMode string

const (
	AssistantOverridesFirstMessageModeAssistantSpeaksFirst                          AssistantOverridesFirstMessageMode = "assistant-speaks-first"
	AssistantOverridesFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage AssistantOverridesFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	AssistantOverridesFirstMessageModeAssistantWaitsForUser                         AssistantOverridesFirstMessageMode = "assistant-waits-for-user"
)

func NewAssistantOverridesFirstMessageModeFromString(s string) (AssistantOverridesFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return AssistantOverridesFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return AssistantOverridesFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return AssistantOverridesFirstMessageModeAssistantWaitsForUser, nil
	}
	var t AssistantOverridesFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesFirstMessageMode) Ptr() *AssistantOverridesFirstMessageMode {
	return &a
}

// These are the options for the assistant's LLM.
type AssistantOverridesModel struct {
	AnyscaleModel     *AnyscaleModel
	AnthropicModel    *AnthropicModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	GoogleModel       *GoogleModel
	GroqModel         *GroqModel
	InflectionAiModel *InflectionAiModel
	DeepSeekModel     *DeepSeekModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	VapiModel         *VapiModel
	XaiModel          *XaiModel

	typ string
}

func (a *AssistantOverridesModel) GetAnyscaleModel() *AnyscaleModel {
	if a == nil {
		return nil
	}
	return a.AnyscaleModel
}

func (a *AssistantOverridesModel) GetAnthropicModel() *AnthropicModel {
	if a == nil {
		return nil
	}
	return a.AnthropicModel
}

func (a *AssistantOverridesModel) GetCustomLlmModel() *CustomLlmModel {
	if a == nil {
		return nil
	}
	return a.CustomLlmModel
}

func (a *AssistantOverridesModel) GetDeepInfraModel() *DeepInfraModel {
	if a == nil {
		return nil
	}
	return a.DeepInfraModel
}

func (a *AssistantOverridesModel) GetGoogleModel() *GoogleModel {
	if a == nil {
		return nil
	}
	return a.GoogleModel
}

func (a *AssistantOverridesModel) GetGroqModel() *GroqModel {
	if a == nil {
		return nil
	}
	return a.GroqModel
}

func (a *AssistantOverridesModel) GetInflectionAiModel() *InflectionAiModel {
	if a == nil {
		return nil
	}
	return a.InflectionAiModel
}

func (a *AssistantOverridesModel) GetDeepSeekModel() *DeepSeekModel {
	if a == nil {
		return nil
	}
	return a.DeepSeekModel
}

func (a *AssistantOverridesModel) GetOpenAiModel() *OpenAiModel {
	if a == nil {
		return nil
	}
	return a.OpenAiModel
}

func (a *AssistantOverridesModel) GetOpenRouterModel() *OpenRouterModel {
	if a == nil {
		return nil
	}
	return a.OpenRouterModel
}

func (a *AssistantOverridesModel) GetPerplexityAiModel() *PerplexityAiModel {
	if a == nil {
		return nil
	}
	return a.PerplexityAiModel
}

func (a *AssistantOverridesModel) GetTogetherAiModel() *TogetherAiModel {
	if a == nil {
		return nil
	}
	return a.TogetherAiModel
}

func (a *AssistantOverridesModel) GetVapiModel() *VapiModel {
	if a == nil {
		return nil
	}
	return a.VapiModel
}

func (a *AssistantOverridesModel) GetXaiModel() *XaiModel {
	if a == nil {
		return nil
	}
	return a.XaiModel
}

func (a *AssistantOverridesModel) UnmarshalJSON(data []byte) error {
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		a.typ = "AnyscaleModel"
		a.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		a.typ = "AnthropicModel"
		a.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		a.typ = "CustomLlmModel"
		a.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		a.typ = "DeepInfraModel"
		a.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueGoogleModel := new(GoogleModel)
	if err := json.Unmarshal(data, &valueGoogleModel); err == nil {
		a.typ = "GoogleModel"
		a.GoogleModel = valueGoogleModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		a.typ = "GroqModel"
		a.GroqModel = valueGroqModel
		return nil
	}
	valueInflectionAiModel := new(InflectionAiModel)
	if err := json.Unmarshal(data, &valueInflectionAiModel); err == nil {
		a.typ = "InflectionAiModel"
		a.InflectionAiModel = valueInflectionAiModel
		return nil
	}
	valueDeepSeekModel := new(DeepSeekModel)
	if err := json.Unmarshal(data, &valueDeepSeekModel); err == nil {
		a.typ = "DeepSeekModel"
		a.DeepSeekModel = valueDeepSeekModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		a.typ = "OpenAiModel"
		a.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		a.typ = "OpenRouterModel"
		a.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		a.typ = "PerplexityAiModel"
		a.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		a.typ = "TogetherAiModel"
		a.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueVapiModel := new(VapiModel)
	if err := json.Unmarshal(data, &valueVapiModel); err == nil {
		a.typ = "VapiModel"
		a.VapiModel = valueVapiModel
		return nil
	}
	valueXaiModel := new(XaiModel)
	if err := json.Unmarshal(data, &valueXaiModel); err == nil {
		a.typ = "XaiModel"
		a.XaiModel = valueXaiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesModel) MarshalJSON() ([]byte, error) {
	if a.typ == "AnyscaleModel" || a.AnyscaleModel != nil {
		return json.Marshal(a.AnyscaleModel)
	}
	if a.typ == "AnthropicModel" || a.AnthropicModel != nil {
		return json.Marshal(a.AnthropicModel)
	}
	if a.typ == "CustomLlmModel" || a.CustomLlmModel != nil {
		return json.Marshal(a.CustomLlmModel)
	}
	if a.typ == "DeepInfraModel" || a.DeepInfraModel != nil {
		return json.Marshal(a.DeepInfraModel)
	}
	if a.typ == "GoogleModel" || a.GoogleModel != nil {
		return json.Marshal(a.GoogleModel)
	}
	if a.typ == "GroqModel" || a.GroqModel != nil {
		return json.Marshal(a.GroqModel)
	}
	if a.typ == "InflectionAiModel" || a.InflectionAiModel != nil {
		return json.Marshal(a.InflectionAiModel)
	}
	if a.typ == "DeepSeekModel" || a.DeepSeekModel != nil {
		return json.Marshal(a.DeepSeekModel)
	}
	if a.typ == "OpenAiModel" || a.OpenAiModel != nil {
		return json.Marshal(a.OpenAiModel)
	}
	if a.typ == "OpenRouterModel" || a.OpenRouterModel != nil {
		return json.Marshal(a.OpenRouterModel)
	}
	if a.typ == "PerplexityAiModel" || a.PerplexityAiModel != nil {
		return json.Marshal(a.PerplexityAiModel)
	}
	if a.typ == "TogetherAiModel" || a.TogetherAiModel != nil {
		return json.Marshal(a.TogetherAiModel)
	}
	if a.typ == "VapiModel" || a.VapiModel != nil {
		return json.Marshal(a.VapiModel)
	}
	if a.typ == "XaiModel" || a.XaiModel != nil {
		return json.Marshal(a.XaiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesModelVisitor interface {
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitAnthropicModel(*AnthropicModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitGoogleModel(*GoogleModel) error
	VisitGroqModel(*GroqModel) error
	VisitInflectionAiModel(*InflectionAiModel) error
	VisitDeepSeekModel(*DeepSeekModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitVapiModel(*VapiModel) error
	VisitXaiModel(*XaiModel) error
}

func (a *AssistantOverridesModel) Accept(visitor AssistantOverridesModelVisitor) error {
	if a.typ == "AnyscaleModel" || a.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(a.AnyscaleModel)
	}
	if a.typ == "AnthropicModel" || a.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(a.AnthropicModel)
	}
	if a.typ == "CustomLlmModel" || a.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(a.CustomLlmModel)
	}
	if a.typ == "DeepInfraModel" || a.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(a.DeepInfraModel)
	}
	if a.typ == "GoogleModel" || a.GoogleModel != nil {
		return visitor.VisitGoogleModel(a.GoogleModel)
	}
	if a.typ == "GroqModel" || a.GroqModel != nil {
		return visitor.VisitGroqModel(a.GroqModel)
	}
	if a.typ == "InflectionAiModel" || a.InflectionAiModel != nil {
		return visitor.VisitInflectionAiModel(a.InflectionAiModel)
	}
	if a.typ == "DeepSeekModel" || a.DeepSeekModel != nil {
		return visitor.VisitDeepSeekModel(a.DeepSeekModel)
	}
	if a.typ == "OpenAiModel" || a.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(a.OpenAiModel)
	}
	if a.typ == "OpenRouterModel" || a.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(a.OpenRouterModel)
	}
	if a.typ == "PerplexityAiModel" || a.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(a.PerplexityAiModel)
	}
	if a.typ == "TogetherAiModel" || a.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(a.TogetherAiModel)
	}
	if a.typ == "VapiModel" || a.VapiModel != nil {
		return visitor.VisitVapiModel(a.VapiModel)
	}
	if a.typ == "XaiModel" || a.XaiModel != nil {
		return visitor.VisitXaiModel(a.XaiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesServerMessagesItem string

const (
	AssistantOverridesServerMessagesItemConversationUpdate         AssistantOverridesServerMessagesItem = "conversation-update"
	AssistantOverridesServerMessagesItemEndOfCallReport            AssistantOverridesServerMessagesItem = "end-of-call-report"
	AssistantOverridesServerMessagesItemFunctionCall               AssistantOverridesServerMessagesItem = "function-call"
	AssistantOverridesServerMessagesItemHang                       AssistantOverridesServerMessagesItem = "hang"
	AssistantOverridesServerMessagesItemLanguageChanged            AssistantOverridesServerMessagesItem = "language-changed"
	AssistantOverridesServerMessagesItemLanguageChangeDetected     AssistantOverridesServerMessagesItem = "language-change-detected"
	AssistantOverridesServerMessagesItemModelOutput                AssistantOverridesServerMessagesItem = "model-output"
	AssistantOverridesServerMessagesItemPhoneCallControl           AssistantOverridesServerMessagesItem = "phone-call-control"
	AssistantOverridesServerMessagesItemSpeechUpdate               AssistantOverridesServerMessagesItem = "speech-update"
	AssistantOverridesServerMessagesItemStatusUpdate               AssistantOverridesServerMessagesItem = "status-update"
	AssistantOverridesServerMessagesItemTranscript                 AssistantOverridesServerMessagesItem = "transcript"
	AssistantOverridesServerMessagesItemToolCalls                  AssistantOverridesServerMessagesItem = "tool-calls"
	AssistantOverridesServerMessagesItemTransferDestinationRequest AssistantOverridesServerMessagesItem = "transfer-destination-request"
	AssistantOverridesServerMessagesItemTransferUpdate             AssistantOverridesServerMessagesItem = "transfer-update"
	AssistantOverridesServerMessagesItemUserInterrupted            AssistantOverridesServerMessagesItem = "user-interrupted"
	AssistantOverridesServerMessagesItemVoiceInput                 AssistantOverridesServerMessagesItem = "voice-input"
)

func NewAssistantOverridesServerMessagesItemFromString(s string) (AssistantOverridesServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return AssistantOverridesServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return AssistantOverridesServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return AssistantOverridesServerMessagesItemFunctionCall, nil
	case "hang":
		return AssistantOverridesServerMessagesItemHang, nil
	case "language-changed":
		return AssistantOverridesServerMessagesItemLanguageChanged, nil
	case "language-change-detected":
		return AssistantOverridesServerMessagesItemLanguageChangeDetected, nil
	case "model-output":
		return AssistantOverridesServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return AssistantOverridesServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return AssistantOverridesServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return AssistantOverridesServerMessagesItemStatusUpdate, nil
	case "transcript":
		return AssistantOverridesServerMessagesItemTranscript, nil
	case "tool-calls":
		return AssistantOverridesServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return AssistantOverridesServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return AssistantOverridesServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return AssistantOverridesServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return AssistantOverridesServerMessagesItemVoiceInput, nil
	}
	var t AssistantOverridesServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssistantOverridesServerMessagesItem) Ptr() *AssistantOverridesServerMessagesItem {
	return &a
}

// These are the options for the assistant's transcriber.
type AssistantOverridesTranscriber struct {
	AssemblyAiTranscriber  *AssemblyAiTranscriber
	AzureSpeechTranscriber *AzureSpeechTranscriber
	CustomTranscriber      *CustomTranscriber
	DeepgramTranscriber    *DeepgramTranscriber
	GladiaTranscriber      *GladiaTranscriber
	TalkscriberTranscriber *TalkscriberTranscriber

	typ string
}

func (a *AssistantOverridesTranscriber) GetAssemblyAiTranscriber() *AssemblyAiTranscriber {
	if a == nil {
		return nil
	}
	return a.AssemblyAiTranscriber
}

func (a *AssistantOverridesTranscriber) GetAzureSpeechTranscriber() *AzureSpeechTranscriber {
	if a == nil {
		return nil
	}
	return a.AzureSpeechTranscriber
}

func (a *AssistantOverridesTranscriber) GetCustomTranscriber() *CustomTranscriber {
	if a == nil {
		return nil
	}
	return a.CustomTranscriber
}

func (a *AssistantOverridesTranscriber) GetDeepgramTranscriber() *DeepgramTranscriber {
	if a == nil {
		return nil
	}
	return a.DeepgramTranscriber
}

func (a *AssistantOverridesTranscriber) GetGladiaTranscriber() *GladiaTranscriber {
	if a == nil {
		return nil
	}
	return a.GladiaTranscriber
}

func (a *AssistantOverridesTranscriber) GetTalkscriberTranscriber() *TalkscriberTranscriber {
	if a == nil {
		return nil
	}
	return a.TalkscriberTranscriber
}

func (a *AssistantOverridesTranscriber) UnmarshalJSON(data []byte) error {
	valueAssemblyAiTranscriber := new(AssemblyAiTranscriber)
	if err := json.Unmarshal(data, &valueAssemblyAiTranscriber); err == nil {
		a.typ = "AssemblyAiTranscriber"
		a.AssemblyAiTranscriber = valueAssemblyAiTranscriber
		return nil
	}
	valueAzureSpeechTranscriber := new(AzureSpeechTranscriber)
	if err := json.Unmarshal(data, &valueAzureSpeechTranscriber); err == nil {
		a.typ = "AzureSpeechTranscriber"
		a.AzureSpeechTranscriber = valueAzureSpeechTranscriber
		return nil
	}
	valueCustomTranscriber := new(CustomTranscriber)
	if err := json.Unmarshal(data, &valueCustomTranscriber); err == nil {
		a.typ = "CustomTranscriber"
		a.CustomTranscriber = valueCustomTranscriber
		return nil
	}
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		a.typ = "DeepgramTranscriber"
		a.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		a.typ = "GladiaTranscriber"
		a.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		a.typ = "TalkscriberTranscriber"
		a.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesTranscriber) MarshalJSON() ([]byte, error) {
	if a.typ == "AssemblyAiTranscriber" || a.AssemblyAiTranscriber != nil {
		return json.Marshal(a.AssemblyAiTranscriber)
	}
	if a.typ == "AzureSpeechTranscriber" || a.AzureSpeechTranscriber != nil {
		return json.Marshal(a.AzureSpeechTranscriber)
	}
	if a.typ == "CustomTranscriber" || a.CustomTranscriber != nil {
		return json.Marshal(a.CustomTranscriber)
	}
	if a.typ == "DeepgramTranscriber" || a.DeepgramTranscriber != nil {
		return json.Marshal(a.DeepgramTranscriber)
	}
	if a.typ == "GladiaTranscriber" || a.GladiaTranscriber != nil {
		return json.Marshal(a.GladiaTranscriber)
	}
	if a.typ == "TalkscriberTranscriber" || a.TalkscriberTranscriber != nil {
		return json.Marshal(a.TalkscriberTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesTranscriberVisitor interface {
	VisitAssemblyAiTranscriber(*AssemblyAiTranscriber) error
	VisitAzureSpeechTranscriber(*AzureSpeechTranscriber) error
	VisitCustomTranscriber(*CustomTranscriber) error
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
}

func (a *AssistantOverridesTranscriber) Accept(visitor AssistantOverridesTranscriberVisitor) error {
	if a.typ == "AssemblyAiTranscriber" || a.AssemblyAiTranscriber != nil {
		return visitor.VisitAssemblyAiTranscriber(a.AssemblyAiTranscriber)
	}
	if a.typ == "AzureSpeechTranscriber" || a.AzureSpeechTranscriber != nil {
		return visitor.VisitAzureSpeechTranscriber(a.AzureSpeechTranscriber)
	}
	if a.typ == "CustomTranscriber" || a.CustomTranscriber != nil {
		return visitor.VisitCustomTranscriber(a.CustomTranscriber)
	}
	if a.typ == "DeepgramTranscriber" || a.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(a.DeepgramTranscriber)
	}
	if a.typ == "GladiaTranscriber" || a.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(a.GladiaTranscriber)
	}
	if a.typ == "TalkscriberTranscriber" || a.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(a.TalkscriberTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// These are the options for the assistant's voice.
type AssistantOverridesVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	CustomVoice     *CustomVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	LmntVoice       *LmntVoice
	NeetsVoice      *NeetsVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
	SmallestAiVoice *SmallestAiVoice
	TavusVoice      *TavusVoice

	typ string
}

func (a *AssistantOverridesVoice) GetAzureVoice() *AzureVoice {
	if a == nil {
		return nil
	}
	return a.AzureVoice
}

func (a *AssistantOverridesVoice) GetCartesiaVoice() *CartesiaVoice {
	if a == nil {
		return nil
	}
	return a.CartesiaVoice
}

func (a *AssistantOverridesVoice) GetCustomVoice() *CustomVoice {
	if a == nil {
		return nil
	}
	return a.CustomVoice
}

func (a *AssistantOverridesVoice) GetDeepgramVoice() *DeepgramVoice {
	if a == nil {
		return nil
	}
	return a.DeepgramVoice
}

func (a *AssistantOverridesVoice) GetElevenLabsVoice() *ElevenLabsVoice {
	if a == nil {
		return nil
	}
	return a.ElevenLabsVoice
}

func (a *AssistantOverridesVoice) GetLmntVoice() *LmntVoice {
	if a == nil {
		return nil
	}
	return a.LmntVoice
}

func (a *AssistantOverridesVoice) GetNeetsVoice() *NeetsVoice {
	if a == nil {
		return nil
	}
	return a.NeetsVoice
}

func (a *AssistantOverridesVoice) GetOpenAiVoice() *OpenAiVoice {
	if a == nil {
		return nil
	}
	return a.OpenAiVoice
}

func (a *AssistantOverridesVoice) GetPlayHtVoice() *PlayHtVoice {
	if a == nil {
		return nil
	}
	return a.PlayHtVoice
}

func (a *AssistantOverridesVoice) GetRimeAiVoice() *RimeAiVoice {
	if a == nil {
		return nil
	}
	return a.RimeAiVoice
}

func (a *AssistantOverridesVoice) GetSmallestAiVoice() *SmallestAiVoice {
	if a == nil {
		return nil
	}
	return a.SmallestAiVoice
}

func (a *AssistantOverridesVoice) GetTavusVoice() *TavusVoice {
	if a == nil {
		return nil
	}
	return a.TavusVoice
}

func (a *AssistantOverridesVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		a.typ = "AzureVoice"
		a.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		a.typ = "CartesiaVoice"
		a.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueCustomVoice := new(CustomVoice)
	if err := json.Unmarshal(data, &valueCustomVoice); err == nil {
		a.typ = "CustomVoice"
		a.CustomVoice = valueCustomVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		a.typ = "DeepgramVoice"
		a.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		a.typ = "ElevenLabsVoice"
		a.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		a.typ = "LmntVoice"
		a.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeetsVoice := new(NeetsVoice)
	if err := json.Unmarshal(data, &valueNeetsVoice); err == nil {
		a.typ = "NeetsVoice"
		a.NeetsVoice = valueNeetsVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		a.typ = "OpenAiVoice"
		a.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		a.typ = "PlayHtVoice"
		a.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		a.typ = "RimeAiVoice"
		a.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	valueSmallestAiVoice := new(SmallestAiVoice)
	if err := json.Unmarshal(data, &valueSmallestAiVoice); err == nil {
		a.typ = "SmallestAiVoice"
		a.SmallestAiVoice = valueSmallestAiVoice
		return nil
	}
	valueTavusVoice := new(TavusVoice)
	if err := json.Unmarshal(data, &valueTavusVoice); err == nil {
		a.typ = "TavusVoice"
		a.TavusVoice = valueTavusVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantOverridesVoice) MarshalJSON() ([]byte, error) {
	if a.typ == "AzureVoice" || a.AzureVoice != nil {
		return json.Marshal(a.AzureVoice)
	}
	if a.typ == "CartesiaVoice" || a.CartesiaVoice != nil {
		return json.Marshal(a.CartesiaVoice)
	}
	if a.typ == "CustomVoice" || a.CustomVoice != nil {
		return json.Marshal(a.CustomVoice)
	}
	if a.typ == "DeepgramVoice" || a.DeepgramVoice != nil {
		return json.Marshal(a.DeepgramVoice)
	}
	if a.typ == "ElevenLabsVoice" || a.ElevenLabsVoice != nil {
		return json.Marshal(a.ElevenLabsVoice)
	}
	if a.typ == "LmntVoice" || a.LmntVoice != nil {
		return json.Marshal(a.LmntVoice)
	}
	if a.typ == "NeetsVoice" || a.NeetsVoice != nil {
		return json.Marshal(a.NeetsVoice)
	}
	if a.typ == "OpenAiVoice" || a.OpenAiVoice != nil {
		return json.Marshal(a.OpenAiVoice)
	}
	if a.typ == "PlayHtVoice" || a.PlayHtVoice != nil {
		return json.Marshal(a.PlayHtVoice)
	}
	if a.typ == "RimeAiVoice" || a.RimeAiVoice != nil {
		return json.Marshal(a.RimeAiVoice)
	}
	if a.typ == "SmallestAiVoice" || a.SmallestAiVoice != nil {
		return json.Marshal(a.SmallestAiVoice)
	}
	if a.typ == "TavusVoice" || a.TavusVoice != nil {
		return json.Marshal(a.TavusVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantOverridesVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitCustomVoice(*CustomVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeetsVoice(*NeetsVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
	VisitSmallestAiVoice(*SmallestAiVoice) error
	VisitTavusVoice(*TavusVoice) error
}

func (a *AssistantOverridesVoice) Accept(visitor AssistantOverridesVoiceVisitor) error {
	if a.typ == "AzureVoice" || a.AzureVoice != nil {
		return visitor.VisitAzureVoice(a.AzureVoice)
	}
	if a.typ == "CartesiaVoice" || a.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(a.CartesiaVoice)
	}
	if a.typ == "CustomVoice" || a.CustomVoice != nil {
		return visitor.VisitCustomVoice(a.CustomVoice)
	}
	if a.typ == "DeepgramVoice" || a.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(a.DeepgramVoice)
	}
	if a.typ == "ElevenLabsVoice" || a.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(a.ElevenLabsVoice)
	}
	if a.typ == "LmntVoice" || a.LmntVoice != nil {
		return visitor.VisitLmntVoice(a.LmntVoice)
	}
	if a.typ == "NeetsVoice" || a.NeetsVoice != nil {
		return visitor.VisitNeetsVoice(a.NeetsVoice)
	}
	if a.typ == "OpenAiVoice" || a.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(a.OpenAiVoice)
	}
	if a.typ == "PlayHtVoice" || a.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(a.PlayHtVoice)
	}
	if a.typ == "RimeAiVoice" || a.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(a.RimeAiVoice)
	}
	if a.typ == "SmallestAiVoice" || a.SmallestAiVoice != nil {
		return visitor.VisitSmallestAiVoice(a.SmallestAiVoice)
	}
	if a.typ == "TavusVoice" || a.TavusVoice != nil {
		return visitor.VisitTavusVoice(a.TavusVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AutoReloadPlan struct {
	// This the amount of credits to reload.
	Credits float64 `json:"credits" url:"credits"`
	// This is the limit at which the reload is triggered.
	Threshold float64 `json:"threshold" url:"threshold"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AutoReloadPlan) GetCredits() float64 {
	if a == nil {
		return 0
	}
	return a.Credits
}

func (a *AutoReloadPlan) GetThreshold() float64 {
	if a == nil {
		return 0
	}
	return a.Threshold
}

func (a *AutoReloadPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AutoReloadPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AutoReloadPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutoReloadPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutoReloadPlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AzureBlobStorageBucketPlan struct {
	// This is the blob storage connection string for the Azure resource.
	ConnectionString string `json:"connectionString" url:"connectionString"`
	// This is the container name for the Azure blob storage.
	ContainerName string `json:"containerName" url:"containerName"`
	// This is the path where call artifacts will be stored.
	//
	// Usage:
	// - To store call artifacts in a specific folder, set this to the full path. Eg. "/folder-name1/folder-name2".
	// - To store call artifacts in the root of the bucket, leave this blank.
	//
	// @default "/"
	Path *string `json:"path,omitempty" url:"path,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureBlobStorageBucketPlan) GetConnectionString() string {
	if a == nil {
		return ""
	}
	return a.ConnectionString
}

func (a *AzureBlobStorageBucketPlan) GetContainerName() string {
	if a == nil {
		return ""
	}
	return a.ContainerName
}

func (a *AzureBlobStorageBucketPlan) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

func (a *AzureBlobStorageBucketPlan) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureBlobStorageBucketPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler AzureBlobStorageBucketPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AzureBlobStorageBucketPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureBlobStorageBucketPlan) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AzureCredential struct {
	// This is the service being used in Azure.
	Service AzureCredentialService `json:"service" url:"service"`
	// This is the region of the Azure resource.
	Region *AzureCredentialRegion `json:"region,omitempty" url:"region,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.
	BucketPlan *AzureBlobStorageBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureCredential) GetService() AzureCredentialService {
	if a == nil {
		return ""
	}
	return a.Service
}

func (a *AzureCredential) GetRegion() *AzureCredentialRegion {
	if a == nil {
		return nil
	}
	return a.Region
}

func (a *AzureCredential) GetApiKey() *string {
	if a == nil {
		return nil
	}
	return a.ApiKey
}

func (a *AzureCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AzureCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AzureCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AzureCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AzureCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AzureCredential) GetBucketPlan() *AzureBlobStorageBucketPlan {
	if a == nil {
		return nil
	}
	return a.BucketPlan
}

func (a *AzureCredential) Provider() string {
	return a.provider
}

func (a *AzureCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureCredential) UnmarshalJSON(data []byte) error {
	type embed AzureCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureCredential) MarshalJSON() ([]byte, error) {
	type embed AzureCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "azure",
	}
	return json.Marshal(marshaler)
}

func (a *AzureCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the region of the Azure resource.
type AzureCredentialRegion string

const (
	AzureCredentialRegionAustralia      AzureCredentialRegion = "australia"
	AzureCredentialRegionCanada         AzureCredentialRegion = "canada"
	AzureCredentialRegionEastus2        AzureCredentialRegion = "eastus2"
	AzureCredentialRegionEastus         AzureCredentialRegion = "eastus"
	AzureCredentialRegionFrance         AzureCredentialRegion = "france"
	AzureCredentialRegionIndia          AzureCredentialRegion = "india"
	AzureCredentialRegionJapan          AzureCredentialRegion = "japan"
	AzureCredentialRegionUaenorth       AzureCredentialRegion = "uaenorth"
	AzureCredentialRegionNorthcentralus AzureCredentialRegion = "northcentralus"
	AzureCredentialRegionNorway         AzureCredentialRegion = "norway"
	AzureCredentialRegionSouthcentralus AzureCredentialRegion = "southcentralus"
	AzureCredentialRegionSwedencentral  AzureCredentialRegion = "swedencentral"
	AzureCredentialRegionSwitzerland    AzureCredentialRegion = "switzerland"
	AzureCredentialRegionUk             AzureCredentialRegion = "uk"
	AzureCredentialRegionWestus         AzureCredentialRegion = "westus"
	AzureCredentialRegionWestus3        AzureCredentialRegion = "westus3"
)

func NewAzureCredentialRegionFromString(s string) (AzureCredentialRegion, error) {
	switch s {
	case "australia":
		return AzureCredentialRegionAustralia, nil
	case "canada":
		return AzureCredentialRegionCanada, nil
	case "eastus2":
		return AzureCredentialRegionEastus2, nil
	case "eastus":
		return AzureCredentialRegionEastus, nil
	case "france":
		return AzureCredentialRegionFrance, nil
	case "india":
		return AzureCredentialRegionIndia, nil
	case "japan":
		return AzureCredentialRegionJapan, nil
	case "uaenorth":
		return AzureCredentialRegionUaenorth, nil
	case "northcentralus":
		return AzureCredentialRegionNorthcentralus, nil
	case "norway":
		return AzureCredentialRegionNorway, nil
	case "southcentralus":
		return AzureCredentialRegionSouthcentralus, nil
	case "swedencentral":
		return AzureCredentialRegionSwedencentral, nil
	case "switzerland":
		return AzureCredentialRegionSwitzerland, nil
	case "uk":
		return AzureCredentialRegionUk, nil
	case "westus":
		return AzureCredentialRegionWestus, nil
	case "westus3":
		return AzureCredentialRegionWestus3, nil
	}
	var t AzureCredentialRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureCredentialRegion) Ptr() *AzureCredentialRegion {
	return &a
}

// This is the service being used in Azure.
type AzureCredentialService string

const (
	AzureCredentialServiceSpeech      AzureCredentialService = "speech"
	AzureCredentialServiceBlobStorage AzureCredentialService = "blob_storage"
)

func NewAzureCredentialServiceFromString(s string) (AzureCredentialService, error) {
	switch s {
	case "speech":
		return AzureCredentialServiceSpeech, nil
	case "blob_storage":
		return AzureCredentialServiceBlobStorage, nil
	}
	var t AzureCredentialService
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureCredentialService) Ptr() *AzureCredentialService {
	return &a
}

type AzureOpenAiCredential struct {
	Region AzureOpenAiCredentialRegion       `json:"region" url:"region"`
	Models []AzureOpenAiCredentialModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey string `json:"openAIKey" url:"openAIKey"`
	// This is not returned in the API.
	OcpApimSubscriptionKey *string `json:"ocpApimSubscriptionKey,omitempty" url:"ocpApimSubscriptionKey,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name           *string `json:"name,omitempty" url:"name,omitempty"`
	OpenAiEndpoint string  `json:"openAIEndpoint" url:"openAIEndpoint"`
	provider       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureOpenAiCredential) GetRegion() AzureOpenAiCredentialRegion {
	if a == nil {
		return ""
	}
	return a.Region
}

func (a *AzureOpenAiCredential) GetModels() []AzureOpenAiCredentialModelsItem {
	if a == nil {
		return nil
	}
	return a.Models
}

func (a *AzureOpenAiCredential) GetOpenAiKey() string {
	if a == nil {
		return ""
	}
	return a.OpenAiKey
}

func (a *AzureOpenAiCredential) GetOcpApimSubscriptionKey() *string {
	if a == nil {
		return nil
	}
	return a.OcpApimSubscriptionKey
}

func (a *AzureOpenAiCredential) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AzureOpenAiCredential) GetOrgId() string {
	if a == nil {
		return ""
	}
	return a.OrgId
}

func (a *AzureOpenAiCredential) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *AzureOpenAiCredential) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *AzureOpenAiCredential) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AzureOpenAiCredential) GetOpenAiEndpoint() string {
	if a == nil {
		return ""
	}
	return a.OpenAiEndpoint
}

func (a *AzureOpenAiCredential) Provider() string {
	return a.provider
}

func (a *AzureOpenAiCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureOpenAiCredential) UnmarshalJSON(data []byte) error {
	type embed AzureOpenAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureOpenAiCredential(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "azure-openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure-openai", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureOpenAiCredential) MarshalJSON() ([]byte, error) {
	type embed AzureOpenAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
		Provider:  "azure-openai",
	}
	return json.Marshal(marshaler)
}

func (a *AzureOpenAiCredential) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AzureOpenAiCredentialModelsItem string

const (
	AzureOpenAiCredentialModelsItemGpt4O20240806     AzureOpenAiCredentialModelsItem = "gpt-4o-2024-08-06"
	AzureOpenAiCredentialModelsItemGpt4OMini20240718 AzureOpenAiCredentialModelsItem = "gpt-4o-mini-2024-07-18"
	AzureOpenAiCredentialModelsItemGpt4O20240513     AzureOpenAiCredentialModelsItem = "gpt-4o-2024-05-13"
	AzureOpenAiCredentialModelsItemGpt4Turbo20240409 AzureOpenAiCredentialModelsItem = "gpt-4-turbo-2024-04-09"
	AzureOpenAiCredentialModelsItemGpt40125Preview   AzureOpenAiCredentialModelsItem = "gpt-4-0125-preview"
	AzureOpenAiCredentialModelsItemGpt41106Preview   AzureOpenAiCredentialModelsItem = "gpt-4-1106-preview"
	AzureOpenAiCredentialModelsItemGpt40613          AzureOpenAiCredentialModelsItem = "gpt-4-0613"
	AzureOpenAiCredentialModelsItemGpt35Turbo0125    AzureOpenAiCredentialModelsItem = "gpt-35-turbo-0125"
	AzureOpenAiCredentialModelsItemGpt35Turbo1106    AzureOpenAiCredentialModelsItem = "gpt-35-turbo-1106"
)

func NewAzureOpenAiCredentialModelsItemFromString(s string) (AzureOpenAiCredentialModelsItem, error) {
	switch s {
	case "gpt-4o-2024-08-06":
		return AzureOpenAiCredentialModelsItemGpt4O20240806, nil
	case "gpt-4o-mini-2024-07-18":
		return AzureOpenAiCredentialModelsItemGpt4OMini20240718, nil
	case "gpt-4o-2024-05-13":
		return AzureOpenAiCredentialModelsItemGpt4O20240513, nil
	case "gpt-4-turbo-2024-04-09":
		return AzureOpenAiCredentialModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return AzureOpenAiCredentialModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return AzureOpenAiCredentialModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return AzureOpenAiCredentialModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return AzureOpenAiCredentialModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return AzureOpenAiCredentialModelsItemGpt35Turbo1106, nil
	}
	var t AzureOpenAiCredentialModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureOpenAiCredentialModelsItem) Ptr() *AzureOpenAiCredentialModelsItem {
	return &a
}

type AzureOpenAiCredentialRegion string

const (
	AzureOpenAiCredentialRegionAustralia      AzureOpenAiCredentialRegion = "australia"
	AzureOpenAiCredentialRegionCanada         AzureOpenAiCredentialRegion = "canada"
	AzureOpenAiCredentialRegionEastus2        AzureOpenAiCredentialRegion = "eastus2"
	AzureOpenAiCredentialRegionEastus         AzureOpenAiCredentialRegion = "eastus"
	AzureOpenAiCredentialRegionFrance         AzureOpenAiCredentialRegion = "france"
	AzureOpenAiCredentialRegionIndia          AzureOpenAiCredentialRegion = "india"
	AzureOpenAiCredentialRegionJapan          AzureOpenAiCredentialRegion = "japan"
	AzureOpenAiCredentialRegionUaenorth       AzureOpenAiCredentialRegion = "uaenorth"
	AzureOpenAiCredentialRegionNorthcentralus AzureOpenAiCredentialRegion = "northcentralus"
	AzureOpenAiCredentialRegionNorway         AzureOpenAiCredentialRegion = "norway"
	AzureOpenAiCredentialRegionSouthcentralus AzureOpenAiCredentialRegion = "southcentralus"
	AzureOpenAiCredentialRegionSwedencentral  AzureOpenAiCredentialRegion = "swedencentral"
	AzureOpenAiCredentialRegionSwitzerland    AzureOpenAiCredentialRegion = "switzerland"
	AzureOpenAiCredentialRegionUk             AzureOpenAiCredentialRegion = "uk"
	AzureOpenAiCredentialRegionWestus         AzureOpenAiCredentialRegion = "westus"
	AzureOpenAiCredentialRegionWestus3        AzureOpenAiCredentialRegion = "westus3"
)

func NewAzureOpenAiCredentialRegionFromString(s string) (AzureOpenAiCredentialRegion, error) {
	switch s {
	case "australia":
		return AzureOpenAiCredentialRegionAustralia, nil
	case "canada":
		return AzureOpenAiCredentialRegionCanada, nil
	case "eastus2":
		return AzureOpenAiCredentialRegionEastus2, nil
	case "eastus":
		return AzureOpenAiCredentialRegionEastus, nil
	case "france":
		return AzureOpenAiCredentialRegionFrance, nil
	case "india":
		return AzureOpenAiCredentialRegionIndia, nil
	case "japan":
		return AzureOpenAiCredentialRegionJapan, nil
	case "uaenorth":
		return AzureOpenAiCredentialRegionUaenorth, nil
	case "northcentralus":
		return AzureOpenAiCredentialRegionNorthcentralus, nil
	case "norway":
		return AzureOpenAiCredentialRegionNorway, nil
	case "southcentralus":
		return AzureOpenAiCredentialRegionSouthcentralus, nil
	case "swedencentral":
		return AzureOpenAiCredentialRegionSwedencentral, nil
	case "switzerland":
		return AzureOpenAiCredentialRegionSwitzerland, nil
	case "uk":
		return AzureOpenAiCredentialRegionUk, nil
	case "westus":
		return AzureOpenAiCredentialRegionWestus, nil
	case "westus3":
		return AzureOpenAiCredentialRegionWestus3, nil
	}
	var t AzureOpenAiCredentialRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureOpenAiCredentialRegion) Ptr() *AzureOpenAiCredentialRegion {
	return &a
}

type AzureSpeechTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the language that will be set for the transcription. The list of languages Azure supports can be found here: https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=stt
	Language *AzureSpeechTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureSpeechTranscriber) GetLanguage() *AzureSpeechTranscriberLanguage {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *AzureSpeechTranscriber) Provider() string {
	return a.provider
}

func (a *AzureSpeechTranscriber) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureSpeechTranscriber) UnmarshalJSON(data []byte) error {
	type embed AzureSpeechTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureSpeechTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureSpeechTranscriber) MarshalJSON() ([]byte, error) {
	type embed AzureSpeechTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (a *AzureSpeechTranscriber) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the language that will be set for the transcription. The list of languages Azure supports can be found here: https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=stt
type AzureSpeechTranscriberLanguage string

const (
	AzureSpeechTranscriberLanguageAfZa         AzureSpeechTranscriberLanguage = "af-ZA"
	AzureSpeechTranscriberLanguageAmEt         AzureSpeechTranscriberLanguage = "am-ET"
	AzureSpeechTranscriberLanguageArAe         AzureSpeechTranscriberLanguage = "ar-AE"
	AzureSpeechTranscriberLanguageArBh         AzureSpeechTranscriberLanguage = "ar-BH"
	AzureSpeechTranscriberLanguageArDz         AzureSpeechTranscriberLanguage = "ar-DZ"
	AzureSpeechTranscriberLanguageArEg         AzureSpeechTranscriberLanguage = "ar-EG"
	AzureSpeechTranscriberLanguageArIl         AzureSpeechTranscriberLanguage = "ar-IL"
	AzureSpeechTranscriberLanguageArIq         AzureSpeechTranscriberLanguage = "ar-IQ"
	AzureSpeechTranscriberLanguageArJo         AzureSpeechTranscriberLanguage = "ar-JO"
	AzureSpeechTranscriberLanguageArKw         AzureSpeechTranscriberLanguage = "ar-KW"
	AzureSpeechTranscriberLanguageArLb         AzureSpeechTranscriberLanguage = "ar-LB"
	AzureSpeechTranscriberLanguageArLy         AzureSpeechTranscriberLanguage = "ar-LY"
	AzureSpeechTranscriberLanguageArMa         AzureSpeechTranscriberLanguage = "ar-MA"
	AzureSpeechTranscriberLanguageArOm         AzureSpeechTranscriberLanguage = "ar-OM"
	AzureSpeechTranscriberLanguageArPs         AzureSpeechTranscriberLanguage = "ar-PS"
	AzureSpeechTranscriberLanguageArQa         AzureSpeechTranscriberLanguage = "ar-QA"
	AzureSpeechTranscriberLanguageArSa         AzureSpeechTranscriberLanguage = "ar-SA"
	AzureSpeechTranscriberLanguageArSy         AzureSpeechTranscriberLanguage = "ar-SY"
	AzureSpeechTranscriberLanguageArTn         AzureSpeechTranscriberLanguage = "ar-TN"
	AzureSpeechTranscriberLanguageArYe         AzureSpeechTranscriberLanguage = "ar-YE"
	AzureSpeechTranscriberLanguageAzAz         AzureSpeechTranscriberLanguage = "az-AZ"
	AzureSpeechTranscriberLanguageBgBg         AzureSpeechTranscriberLanguage = "bg-BG"
	AzureSpeechTranscriberLanguageBnIn         AzureSpeechTranscriberLanguage = "bn-IN"
	AzureSpeechTranscriberLanguageBsBa         AzureSpeechTranscriberLanguage = "bs-BA"
	AzureSpeechTranscriberLanguageCaEs         AzureSpeechTranscriberLanguage = "ca-ES"
	AzureSpeechTranscriberLanguageCsCz         AzureSpeechTranscriberLanguage = "cs-CZ"
	AzureSpeechTranscriberLanguageCyGb         AzureSpeechTranscriberLanguage = "cy-GB"
	AzureSpeechTranscriberLanguageDaDk         AzureSpeechTranscriberLanguage = "da-DK"
	AzureSpeechTranscriberLanguageDeAt         AzureSpeechTranscriberLanguage = "de-AT"
	AzureSpeechTranscriberLanguageDeCh         AzureSpeechTranscriberLanguage = "de-CH"
	AzureSpeechTranscriberLanguageDeDe         AzureSpeechTranscriberLanguage = "de-DE"
	AzureSpeechTranscriberLanguageElGr         AzureSpeechTranscriberLanguage = "el-GR"
	AzureSpeechTranscriberLanguageEnAu         AzureSpeechTranscriberLanguage = "en-AU"
	AzureSpeechTranscriberLanguageEnCa         AzureSpeechTranscriberLanguage = "en-CA"
	AzureSpeechTranscriberLanguageEnGb         AzureSpeechTranscriberLanguage = "en-GB"
	AzureSpeechTranscriberLanguageEnGh         AzureSpeechTranscriberLanguage = "en-GH"
	AzureSpeechTranscriberLanguageEnHk         AzureSpeechTranscriberLanguage = "en-HK"
	AzureSpeechTranscriberLanguageEnIe         AzureSpeechTranscriberLanguage = "en-IE"
	AzureSpeechTranscriberLanguageEnIn         AzureSpeechTranscriberLanguage = "en-IN"
	AzureSpeechTranscriberLanguageEnKe         AzureSpeechTranscriberLanguage = "en-KE"
	AzureSpeechTranscriberLanguageEnNg         AzureSpeechTranscriberLanguage = "en-NG"
	AzureSpeechTranscriberLanguageEnNz         AzureSpeechTranscriberLanguage = "en-NZ"
	AzureSpeechTranscriberLanguageEnPh         AzureSpeechTranscriberLanguage = "en-PH"
	AzureSpeechTranscriberLanguageEnSg         AzureSpeechTranscriberLanguage = "en-SG"
	AzureSpeechTranscriberLanguageEnTz         AzureSpeechTranscriberLanguage = "en-TZ"
	AzureSpeechTranscriberLanguageEnUs         AzureSpeechTranscriberLanguage = "en-US"
	AzureSpeechTranscriberLanguageEnZa         AzureSpeechTranscriberLanguage = "en-ZA"
	AzureSpeechTranscriberLanguageEsAr         AzureSpeechTranscriberLanguage = "es-AR"
	AzureSpeechTranscriberLanguageEsBo         AzureSpeechTranscriberLanguage = "es-BO"
	AzureSpeechTranscriberLanguageEsCl         AzureSpeechTranscriberLanguage = "es-CL"
	AzureSpeechTranscriberLanguageEsCo         AzureSpeechTranscriberLanguage = "es-CO"
	AzureSpeechTranscriberLanguageEsCr         AzureSpeechTranscriberLanguage = "es-CR"
	AzureSpeechTranscriberLanguageEsCu         AzureSpeechTranscriberLanguage = "es-CU"
	AzureSpeechTranscriberLanguageEsDo         AzureSpeechTranscriberLanguage = "es-DO"
	AzureSpeechTranscriberLanguageEsEc         AzureSpeechTranscriberLanguage = "es-EC"
	AzureSpeechTranscriberLanguageEsEs         AzureSpeechTranscriberLanguage = "es-ES"
	AzureSpeechTranscriberLanguageEsGq         AzureSpeechTranscriberLanguage = "es-GQ"
	AzureSpeechTranscriberLanguageEsGt         AzureSpeechTranscriberLanguage = "es-GT"
	AzureSpeechTranscriberLanguageEsHn         AzureSpeechTranscriberLanguage = "es-HN"
	AzureSpeechTranscriberLanguageEsMx         AzureSpeechTranscriberLanguage = "es-MX"
	AzureSpeechTranscriberLanguageEsNi         AzureSpeechTranscriberLanguage = "es-NI"
	AzureSpeechTranscriberLanguageEsPa         AzureSpeechTranscriberLanguage = "es-PA"
	AzureSpeechTranscriberLanguageEsPe         AzureSpeechTranscriberLanguage = "es-PE"
	AzureSpeechTranscriberLanguageEsPr         AzureSpeechTranscriberLanguage = "es-PR"
	AzureSpeechTranscriberLanguageEsPy         AzureSpeechTranscriberLanguage = "es-PY"
	AzureSpeechTranscriberLanguageEsSv         AzureSpeechTranscriberLanguage = "es-SV"
	AzureSpeechTranscriberLanguageEsUs         AzureSpeechTranscriberLanguage = "es-US"
	AzureSpeechTranscriberLanguageEsUy         AzureSpeechTranscriberLanguage = "es-UY"
	AzureSpeechTranscriberLanguageEsVe         AzureSpeechTranscriberLanguage = "es-VE"
	AzureSpeechTranscriberLanguageEtEe         AzureSpeechTranscriberLanguage = "et-EE"
	AzureSpeechTranscriberLanguageEuEs         AzureSpeechTranscriberLanguage = "eu-ES"
	AzureSpeechTranscriberLanguageFaIr         AzureSpeechTranscriberLanguage = "fa-IR"
	AzureSpeechTranscriberLanguageFiFi         AzureSpeechTranscriberLanguage = "fi-FI"
	AzureSpeechTranscriberLanguageFilPh        AzureSpeechTranscriberLanguage = "fil-PH"
	AzureSpeechTranscriberLanguageFrBe         AzureSpeechTranscriberLanguage = "fr-BE"
	AzureSpeechTranscriberLanguageFrCa         AzureSpeechTranscriberLanguage = "fr-CA"
	AzureSpeechTranscriberLanguageFrCh         AzureSpeechTranscriberLanguage = "fr-CH"
	AzureSpeechTranscriberLanguageFrFr         AzureSpeechTranscriberLanguage = "fr-FR"
	AzureSpeechTranscriberLanguageGaIe         AzureSpeechTranscriberLanguage = "ga-IE"
	AzureSpeechTranscriberLanguageGlEs         AzureSpeechTranscriberLanguage = "gl-ES"
	AzureSpeechTranscriberLanguageGuIn         AzureSpeechTranscriberLanguage = "gu-IN"
	AzureSpeechTranscriberLanguageHeIl         AzureSpeechTranscriberLanguage = "he-IL"
	AzureSpeechTranscriberLanguageHiIn         AzureSpeechTranscriberLanguage = "hi-IN"
	AzureSpeechTranscriberLanguageHrHr         AzureSpeechTranscriberLanguage = "hr-HR"
	AzureSpeechTranscriberLanguageHuHu         AzureSpeechTranscriberLanguage = "hu-HU"
	AzureSpeechTranscriberLanguageHyAm         AzureSpeechTranscriberLanguage = "hy-AM"
	AzureSpeechTranscriberLanguageIdId         AzureSpeechTranscriberLanguage = "id-ID"
	AzureSpeechTranscriberLanguageIsIs         AzureSpeechTranscriberLanguage = "is-IS"
	AzureSpeechTranscriberLanguageItCh         AzureSpeechTranscriberLanguage = "it-CH"
	AzureSpeechTranscriberLanguageItIt         AzureSpeechTranscriberLanguage = "it-IT"
	AzureSpeechTranscriberLanguageJaJp         AzureSpeechTranscriberLanguage = "ja-JP"
	AzureSpeechTranscriberLanguageJvId         AzureSpeechTranscriberLanguage = "jv-ID"
	AzureSpeechTranscriberLanguageKaGe         AzureSpeechTranscriberLanguage = "ka-GE"
	AzureSpeechTranscriberLanguageKkKz         AzureSpeechTranscriberLanguage = "kk-KZ"
	AzureSpeechTranscriberLanguageKmKh         AzureSpeechTranscriberLanguage = "km-KH"
	AzureSpeechTranscriberLanguageKnIn         AzureSpeechTranscriberLanguage = "kn-IN"
	AzureSpeechTranscriberLanguageKoKr         AzureSpeechTranscriberLanguage = "ko-KR"
	AzureSpeechTranscriberLanguageLoLa         AzureSpeechTranscriberLanguage = "lo-LA"
	AzureSpeechTranscriberLanguageLtLt         AzureSpeechTranscriberLanguage = "lt-LT"
	AzureSpeechTranscriberLanguageLvLv         AzureSpeechTranscriberLanguage = "lv-LV"
	AzureSpeechTranscriberLanguageMkMk         AzureSpeechTranscriberLanguage = "mk-MK"
	AzureSpeechTranscriberLanguageMlIn         AzureSpeechTranscriberLanguage = "ml-IN"
	AzureSpeechTranscriberLanguageMnMn         AzureSpeechTranscriberLanguage = "mn-MN"
	AzureSpeechTranscriberLanguageMrIn         AzureSpeechTranscriberLanguage = "mr-IN"
	AzureSpeechTranscriberLanguageMsMy         AzureSpeechTranscriberLanguage = "ms-MY"
	AzureSpeechTranscriberLanguageMtMt         AzureSpeechTranscriberLanguage = "mt-MT"
	AzureSpeechTranscriberLanguageMyMm         AzureSpeechTranscriberLanguage = "my-MM"
	AzureSpeechTranscriberLanguageNbNo         AzureSpeechTranscriberLanguage = "nb-NO"
	AzureSpeechTranscriberLanguageNeNp         AzureSpeechTranscriberLanguage = "ne-NP"
	AzureSpeechTranscriberLanguageNlBe         AzureSpeechTranscriberLanguage = "nl-BE"
	AzureSpeechTranscriberLanguageNlNl         AzureSpeechTranscriberLanguage = "nl-NL"
	AzureSpeechTranscriberLanguagePaIn         AzureSpeechTranscriberLanguage = "pa-IN"
	AzureSpeechTranscriberLanguagePlPl         AzureSpeechTranscriberLanguage = "pl-PL"
	AzureSpeechTranscriberLanguagePsAf         AzureSpeechTranscriberLanguage = "ps-AF"
	AzureSpeechTranscriberLanguagePtBr         AzureSpeechTranscriberLanguage = "pt-BR"
	AzureSpeechTranscriberLanguagePtPt         AzureSpeechTranscriberLanguage = "pt-PT"
	AzureSpeechTranscriberLanguageRoRo         AzureSpeechTranscriberLanguage = "ro-RO"
	AzureSpeechTranscriberLanguageRuRu         AzureSpeechTranscriberLanguage = "ru-RU"
	AzureSpeechTranscriberLanguageSiLk         AzureSpeechTranscriberLanguage = "si-LK"
	AzureSpeechTranscriberLanguageSkSk         AzureSpeechTranscriberLanguage = "sk-SK"
	AzureSpeechTranscriberLanguageSlSi         AzureSpeechTranscriberLanguage = "sl-SI"
	AzureSpeechTranscriberLanguageSoSo         AzureSpeechTranscriberLanguage = "so-SO"
	AzureSpeechTranscriberLanguageSqAl         AzureSpeechTranscriberLanguage = "sq-AL"
	AzureSpeechTranscriberLanguageSrRs         AzureSpeechTranscriberLanguage = "sr-RS"
	AzureSpeechTranscriberLanguageSvSe         AzureSpeechTranscriberLanguage = "sv-SE"
	AzureSpeechTranscriberLanguageSwKe         AzureSpeechTranscriberLanguage = "sw-KE"
	AzureSpeechTranscriberLanguageSwTz         AzureSpeechTranscriberLanguage = "sw-TZ"
	AzureSpeechTranscriberLanguageTaIn         AzureSpeechTranscriberLanguage = "ta-IN"
	AzureSpeechTranscriberLanguageTeIn         AzureSpeechTranscriberLanguage = "te-IN"
	AzureSpeechTranscriberLanguageThTh         AzureSpeechTranscriberLanguage = "th-TH"
	AzureSpeechTranscriberLanguageTrTr         AzureSpeechTranscriberLanguage = "tr-TR"
	AzureSpeechTranscriberLanguageUkUa         AzureSpeechTranscriberLanguage = "uk-UA"
	AzureSpeechTranscriberLanguageUrIn         AzureSpeechTranscriberLanguage = "ur-IN"
	AzureSpeechTranscriberLanguageUzUz         AzureSpeechTranscriberLanguage = "uz-UZ"
	AzureSpeechTranscriberLanguageViVn         AzureSpeechTranscriberLanguage = "vi-VN"
	AzureSpeechTranscriberLanguageWuuCn        AzureSpeechTranscriberLanguage = "wuu-CN"
	AzureSpeechTranscriberLanguageYueCn        AzureSpeechTranscriberLanguage = "yue-CN"
	AzureSpeechTranscriberLanguageZhCn         AzureSpeechTranscriberLanguage = "zh-CN"
	AzureSpeechTranscriberLanguageZhCnShandong AzureSpeechTranscriberLanguage = "zh-CN-shandong"
	AzureSpeechTranscriberLanguageZhCnSichuan  AzureSpeechTranscriberLanguage = "zh-CN-sichuan"
	AzureSpeechTranscriberLanguageZhHk         AzureSpeechTranscriberLanguage = "zh-HK"
	AzureSpeechTranscriberLanguageZhTw         AzureSpeechTranscriberLanguage = "zh-TW"
	AzureSpeechTranscriberLanguageZuZa         AzureSpeechTranscriberLanguage = "zu-ZA"
)

func NewAzureSpeechTranscriberLanguageFromString(s string) (AzureSpeechTranscriberLanguage, error) {
	switch s {
	case "af-ZA":
		return AzureSpeechTranscriberLanguageAfZa, nil
	case "am-ET":
		return AzureSpeechTranscriberLanguageAmEt, nil
	case "ar-AE":
		return AzureSpeechTranscriberLanguageArAe, nil
	case "ar-BH":
		return AzureSpeechTranscriberLanguageArBh, nil
	case "ar-DZ":
		return AzureSpeechTranscriberLanguageArDz, nil
	case "ar-EG":
		return AzureSpeechTranscriberLanguageArEg, nil
	case "ar-IL":
		return AzureSpeechTranscriberLanguageArIl, nil
	case "ar-IQ":
		return AzureSpeechTranscriberLanguageArIq, nil
	case "ar-JO":
		return AzureSpeechTranscriberLanguageArJo, nil
	case "ar-KW":
		return AzureSpeechTranscriberLanguageArKw, nil
	case "ar-LB":
		return AzureSpeechTranscriberLanguageArLb, nil
	case "ar-LY":
		return AzureSpeechTranscriberLanguageArLy, nil
	case "ar-MA":
		return AzureSpeechTranscriberLanguageArMa, nil
	case "ar-OM":
		return AzureSpeechTranscriberLanguageArOm, nil
	case "ar-PS":
		return AzureSpeechTranscriberLanguageArPs, nil
	case "ar-QA":
		return AzureSpeechTranscriberLanguageArQa, nil
	case "ar-SA":
		return AzureSpeechTranscriberLanguageArSa, nil
	case "ar-SY":
		return AzureSpeechTranscriberLanguageArSy, nil
	case "ar-TN":
		return AzureSpeechTranscriberLanguageArTn, nil
	case "ar-YE":
		return AzureSpeechTranscriberLanguageArYe, nil
	case "az-AZ":
		return AzureSpeechTranscriberLanguageAzAz, nil
	case "bg-BG":
		return AzureSpeechTranscriberLanguageBgBg, nil
	case "bn-IN":
		return AzureSpeechTranscriberLanguageBnIn, nil
	case "bs-BA":
		return AzureSpeechTranscriberLanguageBsBa, nil
	case "ca-ES":
		return AzureSpeechTranscriberLanguageCaEs, nil
	case "cs-CZ":
		return AzureSpeechTranscriberLanguageCsCz, nil
	case "cy-GB":
		return AzureSpeechTranscriberLanguageCyGb, nil
	case "da-DK":
		return AzureSpeechTranscriberLanguageDaDk, nil
	case "de-AT":
		return AzureSpeechTranscriberLanguageDeAt, nil
	case "de-CH":
		return AzureSpeechTranscriberLanguageDeCh, nil
	case "de-DE":
		return AzureSpeechTranscriberLanguageDeDe, nil
	case "el-GR":
		return AzureSpeechTranscriberLanguageElGr, nil
	case "en-AU":
		return AzureSpeechTranscriberLanguageEnAu, nil
	case "en-CA":
		return AzureSpeechTranscriberLanguageEnCa, nil
	case "en-GB":
		return AzureSpeechTranscriberLanguageEnGb, nil
	case "en-GH":
		return AzureSpeechTranscriberLanguageEnGh, nil
	case "en-HK":
		return AzureSpeechTranscriberLanguageEnHk, nil
	case "en-IE":
		return AzureSpeechTranscriberLanguageEnIe, nil
	case "en-IN":
		return AzureSpeechTranscriberLanguageEnIn, nil
	case "en-KE":
		return AzureSpeechTranscriberLanguageEnKe, nil
	case "en-NG":
		return AzureSpeechTranscriberLanguageEnNg, nil
	case "en-NZ":
		return AzureSpeechTranscriberLanguageEnNz, nil
	case "en-PH":
		return AzureSpeechTranscriberLanguageEnPh, nil
	case "en-SG":
		return AzureSpeechTranscriberLanguageEnSg, nil
	case "en-TZ":
		return AzureSpeechTranscriberLanguageEnTz, nil
	case "en-US":
		return AzureSpeechTranscriberLanguageEnUs, nil
	case "en-ZA":
		return AzureSpeechTranscriberLanguageEnZa, nil
	case "es-AR":
		return AzureSpeechTranscriberLanguageEsAr, nil
	case "es-BO":
		return AzureSpeechTranscriberLanguageEsBo, nil
	case "es-CL":
		return AzureSpeechTranscriberLanguageEsCl, nil
	case "es-CO":
		return AzureSpeechTranscriberLanguageEsCo, nil
	case "es-CR":
		return AzureSpeechTranscriberLanguageEsCr, nil
	case "es-CU":
		return AzureSpeechTranscriberLanguageEsCu, nil
	case "es-DO":
		return AzureSpeechTranscriberLanguageEsDo, nil
	case "es-EC":
		return AzureSpeechTranscriberLanguageEsEc, nil
	case "es-ES":
		return AzureSpeechTranscriberLanguageEsEs, nil
	case "es-GQ":
		return AzureSpeechTranscriberLanguageEsGq, nil
	case "es-GT":
		return AzureSpeechTranscriberLanguageEsGt, nil
	case "es-HN":
		return AzureSpeechTranscriberLanguageEsHn, nil
	case "es-MX":
		return AzureSpeechTranscriberLanguageEsMx, nil
	case "es-NI":
		return AzureSpeechTranscriberLanguageEsNi, nil
	case "es-PA":
		return AzureSpeechTranscriberLanguageEsPa, nil
	case "es-PE":
		return AzureSpeechTranscriberLanguageEsPe, nil
	case "es-PR":
		return AzureSpeechTranscriberLanguageEsPr, nil
	case "es-PY":
		return AzureSpeechTranscriberLanguageEsPy, nil
	case "es-SV":
		return AzureSpeechTranscriberLanguageEsSv, nil
	case "es-US":
		return AzureSpeechTranscriberLanguageEsUs, nil
	case "es-UY":
		return AzureSpeechTranscriberLanguageEsUy, nil
	case "es-VE":
		return AzureSpeechTranscriberLanguageEsVe, nil
	case "et-EE":
		return AzureSpeechTranscriberLanguageEtEe, nil
	case "eu-ES":
		return AzureSpeechTranscriberLanguageEuEs, nil
	case "fa-IR":
		return AzureSpeechTranscriberLanguageFaIr, nil
	case "fi-FI":
		return AzureSpeechTranscriberLanguageFiFi, nil
	case "fil-PH":
		return AzureSpeechTranscriberLanguageFilPh, nil
	case "fr-BE":
		return AzureSpeechTranscriberLanguageFrBe, nil
	case "fr-CA":
		return AzureSpeechTranscriberLanguageFrCa, nil
	case "fr-CH":
		return AzureSpeechTranscriberLanguageFrCh, nil
	case "fr-FR":
		return AzureSpeechTranscriberLanguageFrFr, nil
	case "ga-IE":
		return AzureSpeechTranscriberLanguageGaIe, nil
	case "gl-ES":
		return AzureSpeechTranscriberLanguageGlEs, nil
	case "gu-IN":
		return AzureSpeechTranscriberLanguageGuIn, nil
	case "he-IL":
		return AzureSpeechTranscriberLanguageHeIl, nil
	case "hi-IN":
		return AzureSpeechTranscriberLanguageHiIn, nil
	case "hr-HR":
		return AzureSpeechTranscriberLanguageHrHr, nil
	case "hu-HU":
		return AzureSpeechTranscriberLanguageHuHu, nil
	case "hy-AM":
		return AzureSpeechTranscriberLanguageHyAm, nil
	case "id-ID":
		return AzureSpeechTranscriberLanguageIdId, nil
	case "is-IS":
		return AzureSpeechTranscriberLanguageIsIs, nil
	case "it-CH":
		return AzureSpeechTranscriberLanguageItCh, nil
	case "it-IT":
		return AzureSpeechTranscriberLanguageItIt, nil
	case "ja-JP":
		return AzureSpeechTranscriberLanguageJaJp, nil
	case "jv-ID":
		return AzureSpeechTranscriberLanguageJvId, nil
	case "ka-GE":
		return AzureSpeechTranscriberLanguageKaGe, nil
	case "kk-KZ":
		return AzureSpeechTranscriberLanguageKkKz, nil
	case "km-KH":
		return AzureSpeechTranscriberLanguageKmKh, nil
	case "kn-IN":
		return AzureSpeechTranscriberLanguageKnIn, nil
	case "ko-KR":
		return AzureSpeechTranscriberLanguageKoKr, nil
	case "lo-LA":
		return AzureSpeechTranscriberLanguageLoLa, nil
	case "lt-LT":
		return AzureSpeechTranscriberLanguageLtLt, nil
	case "lv-LV":
		return AzureSpeechTranscriberLanguageLvLv, nil
	case "mk-MK":
		return AzureSpeechTranscriberLanguageMkMk, nil
	case "ml-IN":
		return AzureSpeechTranscriberLanguageMlIn, nil
	case "mn-MN":
		return AzureSpeechTranscriberLanguageMnMn, nil
	case "mr-IN":
		return AzureSpeechTranscriberLanguageMrIn, nil
	case "ms-MY":
		return AzureSpeechTranscriberLanguageMsMy, nil
	case "mt-MT":
		return AzureSpeechTranscriberLanguageMtMt, nil
	case "my-MM":
		return AzureSpeechTranscriberLanguageMyMm, nil
	case "nb-NO":
		return AzureSpeechTranscriberLanguageNbNo, nil
	case "ne-NP":
		return AzureSpeechTranscriberLanguageNeNp, nil
	case "nl-BE":
		return AzureSpeechTranscriberLanguageNlBe, nil
	case "nl-NL":
		return AzureSpeechTranscriberLanguageNlNl, nil
	case "pa-IN":
		return AzureSpeechTranscriberLanguagePaIn, nil
	case "pl-PL":
		return AzureSpeechTranscriberLanguagePlPl, nil
	case "ps-AF":
		return AzureSpeechTranscriberLanguagePsAf, nil
	case "pt-BR":
		return AzureSpeechTranscriberLanguagePtBr, nil
	case "pt-PT":
		return AzureSpeechTranscriberLanguagePtPt, nil
	case "ro-RO":
		return AzureSpeechTranscriberLanguageRoRo, nil
	case "ru-RU":
		return AzureSpeechTranscriberLanguageRuRu, nil
	case "si-LK":
		return AzureSpeechTranscriberLanguageSiLk, nil
	case "sk-SK":
		return AzureSpeechTranscriberLanguageSkSk, nil
	case "sl-SI":
		return AzureSpeechTranscriberLanguageSlSi, nil
	case "so-SO":
		return AzureSpeechTranscriberLanguageSoSo, nil
	case "sq-AL":
		return AzureSpeechTranscriberLanguageSqAl, nil
	case "sr-RS":
		return AzureSpeechTranscriberLanguageSrRs, nil
	case "sv-SE":
		return AzureSpeechTranscriberLanguageSvSe, nil
	case "sw-KE":
		return AzureSpeechTranscriberLanguageSwKe, nil
	case "sw-TZ":
		return AzureSpeechTranscriberLanguageSwTz, nil
	case "ta-IN":
		return AzureSpeechTranscriberLanguageTaIn, nil
	case "te-IN":
		return AzureSpeechTranscriberLanguageTeIn, nil
	case "th-TH":
		return AzureSpeechTranscriberLanguageThTh, nil
	case "tr-TR":
		return AzureSpeechTranscriberLanguageTrTr, nil
	case "uk-UA":
		return AzureSpeechTranscriberLanguageUkUa, nil
	case "ur-IN":
		return AzureSpeechTranscriberLanguageUrIn, nil
	case "uz-UZ":
		return AzureSpeechTranscriberLanguageUzUz, nil
	case "vi-VN":
		return AzureSpeechTranscriberLanguageViVn, nil
	case "wuu-CN":
		return AzureSpeechTranscriberLanguageWuuCn, nil
	case "yue-CN":
		return AzureSpeechTranscriberLanguageYueCn, nil
	case "zh-CN":
		return AzureSpeechTranscriberLanguageZhCn, nil
	case "zh-CN-shandong":
		return AzureSpeechTranscriberLanguageZhCnShandong, nil
	case "zh-CN-sichuan":
		return AzureSpeechTranscriberLanguageZhCnSichuan, nil
	case "zh-HK":
		return AzureSpeechTranscriberLanguageZhHk, nil
	case "zh-TW":
		return AzureSpeechTranscriberLanguageZhTw, nil
	case "zu-ZA":
		return AzureSpeechTranscriberLanguageZuZa, nil
	}
	var t AzureSpeechTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureSpeechTranscriberLanguage) Ptr() *AzureSpeechTranscriberLanguage {
	return &a
}

type AzureVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *AzureVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AzureVoice) GetVoiceId() *AzureVoiceId {
	if a == nil {
		return nil
	}
	return a.VoiceId
}

func (a *AzureVoice) GetChunkPlan() *ChunkPlan {
	if a == nil {
		return nil
	}
	return a.ChunkPlan
}

func (a *AzureVoice) GetSpeed() *float64 {
	if a == nil {
		return nil
	}
	return a.Speed
}

func (a *AzureVoice) GetFallbackPlan() *FallbackPlan {
	if a == nil {
		return nil
	}
	return a.FallbackPlan
}

func (a *AzureVoice) Provider() string {
	return a.provider
}

func (a *AzureVoice) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AzureVoice) UnmarshalJSON(data []byte) error {
	type embed AzureVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AzureVoice(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "azure", unmarshaler.Provider)
	}
	a.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "provider")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AzureVoice) MarshalJSON() ([]byte, error) {
	type embed AzureVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*a),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (a *AzureVoice) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// This is the provider-specific ID that will be used.
type AzureVoiceId struct {
	AzureVoiceIdEnum AzureVoiceIdEnum
	String           string

	typ string
}

func (a *AzureVoiceId) GetAzureVoiceIdEnum() AzureVoiceIdEnum {
	if a == nil {
		return ""
	}
	return a.AzureVoiceIdEnum
}

func (a *AzureVoiceId) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *AzureVoiceId) UnmarshalJSON(data []byte) error {
	var valueAzureVoiceIdEnum AzureVoiceIdEnum
	if err := json.Unmarshal(data, &valueAzureVoiceIdEnum); err == nil {
		a.typ = "AzureVoiceIdEnum"
		a.AzureVoiceIdEnum = valueAzureVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AzureVoiceId) MarshalJSON() ([]byte, error) {
	if a.typ == "AzureVoiceIdEnum" || a.AzureVoiceIdEnum != "" {
		return json.Marshal(a.AzureVoiceIdEnum)
	}
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AzureVoiceIdVisitor interface {
	VisitAzureVoiceIdEnum(AzureVoiceIdEnum) error
	VisitString(string) error
}

func (a *AzureVoiceId) Accept(visitor AzureVoiceIdVisitor) error {
	if a.typ == "AzureVoiceIdEnum" || a.AzureVoiceIdEnum != "" {
		return visitor.VisitAzureVoiceIdEnum(a.AzureVoiceIdEnum)
	}
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AzureVoiceIdEnum string

const (
	AzureVoiceIdEnumAndrew AzureVoiceIdEnum = "andrew"
	AzureVoiceIdEnumBrian  AzureVoiceIdEnum = "brian"
	AzureVoiceIdEnumEmma   AzureVoiceIdEnum = "emma"
)

func NewAzureVoiceIdEnumFromString(s string) (AzureVoiceIdEnum, error) {
	switch s {
	case "andrew":
		return AzureVoiceIdEnumAndrew, nil
	case "brian":
		return AzureVoiceIdEnumBrian, nil
	case "emma":
		return AzureVoiceIdEnumEmma, nil
	}
	var t AzureVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AzureVoiceIdEnum) Ptr() *AzureVoiceIdEnum {
	return &a
}

type BlockCompleteMessage struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This is an optional array of conditions that must be met for this message to be triggered.
	Conditions []*BlockCompleteMessageConditionsItem `json:"conditions,omitempty" url:"conditions,omitempty"`
	// This is the message type that is triggered when the block completes.
	// This is the content that the assistant will say when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BlockCompleteMessage) GetContents() []*TextContent {
	if b == nil {
		return nil
	}
	return b.Contents
}

func (b *BlockCompleteMessage) GetConditions() []*BlockCompleteMessageConditionsItem {
	if b == nil {
		return nil
	}
	return b.Conditions
}

func (b *BlockCompleteMessage) GetContent() *string {
	if b == nil {
		return nil
	}
	return b.Content
}

func (b *BlockCompleteMessage) Type() string {
	return b.type_
}

func (b *BlockCompleteMessage) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BlockCompleteMessage) UnmarshalJSON(data []byte) error {
	type embed BlockCompleteMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BlockCompleteMessage(unmarshaler.embed)
	if unmarshaler.Type != "block-complete" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "block-complete", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "type")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BlockCompleteMessage) MarshalJSON() ([]byte, error) {
	type embed BlockCompleteMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "block-complete",
	}
	return json.Marshal(marshaler)
}

func (b *BlockCompleteMessage) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BlockCompleteMessageConditionsItem struct {
	ModelBasedCondition *ModelBasedCondition
	RuleBasedCondition  *RuleBasedCondition

	typ string
}

func (b *BlockCompleteMessageConditionsItem) GetModelBasedCondition() *ModelBasedCondition {
	if b == nil {
		return nil
	}
	return b.ModelBasedCondition
}

func (b *BlockCompleteMessageConditionsItem) GetRuleBasedCondition() *RuleBasedCondition {
	if b == nil {
		return nil
	}
	return b.RuleBasedCondition
}

func (b *BlockCompleteMessageConditionsItem) UnmarshalJSON(data []byte) error {
	valueModelBasedCondition := new(ModelBasedCondition)
	if err := json.Unmarshal(data, &valueModelBasedCondition); err == nil {
		b.typ = "ModelBasedCondition"
		b.ModelBasedCondition = valueModelBasedCondition
		return nil
	}
	valueRuleBasedCondition := new(RuleBasedCondition)
	if err := json.Unmarshal(data, &valueRuleBasedCondition); err == nil {
		b.typ = "RuleBasedCondition"
		b.RuleBasedCondition = valueRuleBasedCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BlockCompleteMessageConditionsItem) MarshalJSON() ([]byte, error) {
	if b.typ == "ModelBasedCondition" || b.ModelBasedCondition != nil {
		return json.Marshal(b.ModelBasedCondition)
	}
	if b.typ == "RuleBasedCondition" || b.RuleBasedCondition != nil {
		return json.Marshal(b.RuleBasedCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BlockCompleteMessageConditionsItemVisitor interface {
	VisitModelBasedCondition(*ModelBasedCondition) error
	VisitRuleBasedCondition(*RuleBasedCondition) error
}

func (b *BlockCompleteMessageConditionsItem) Accept(visitor BlockCompleteMessageConditionsItemVisitor) error {
	if b.typ == "ModelBasedCondition" || b.ModelBasedCondition != nil {
		return visitor.VisitModelBasedCondition(b.ModelBasedCondition)
	}
	if b.typ == "RuleBasedCondition" || b.RuleBasedCondition != nil {
		return visitor.VisitRuleBasedCondition(b.RuleBasedCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BlockStartMessage struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This is an optional array of conditions that must be met for this message to be triggered.
	Conditions []*BlockStartMessageConditionsItem `json:"conditions,omitempty" url:"conditions,omitempty"`
	// This is the message type that is triggered when the block starts.
	// This is the content that the assistant will say when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BlockStartMessage) GetContents() []*TextContent {
	if b == nil {
		return nil
	}
	return b.Contents
}

func (b *BlockStartMessage) GetConditions() []*BlockStartMessageConditionsItem {
	if b == nil {
		return nil
	}
	return b.Conditions
}

func (b *BlockStartMessage) GetContent() *string {
	if b == nil {
		return nil
	}
	return b.Content
}

func (b *BlockStartMessage) Type() string {
	return b.type_
}

func (b *BlockStartMessage) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BlockStartMessage) UnmarshalJSON(data []byte) error {
	type embed BlockStartMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BlockStartMessage(unmarshaler.embed)
	if unmarshaler.Type != "block-start" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "block-start", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "type")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BlockStartMessage) MarshalJSON() ([]byte, error) {
	type embed BlockStartMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "block-start",
	}
	return json.Marshal(marshaler)
}

func (b *BlockStartMessage) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BlockStartMessageConditionsItem struct {
	ModelBasedCondition *ModelBasedCondition
	RuleBasedCondition  *RuleBasedCondition

	typ string
}

func (b *BlockStartMessageConditionsItem) GetModelBasedCondition() *ModelBasedCondition {
	if b == nil {
		return nil
	}
	return b.ModelBasedCondition
}

func (b *BlockStartMessageConditionsItem) GetRuleBasedCondition() *RuleBasedCondition {
	if b == nil {
		return nil
	}
	return b.RuleBasedCondition
}

func (b *BlockStartMessageConditionsItem) UnmarshalJSON(data []byte) error {
	valueModelBasedCondition := new(ModelBasedCondition)
	if err := json.Unmarshal(data, &valueModelBasedCondition); err == nil {
		b.typ = "ModelBasedCondition"
		b.ModelBasedCondition = valueModelBasedCondition
		return nil
	}
	valueRuleBasedCondition := new(RuleBasedCondition)
	if err := json.Unmarshal(data, &valueRuleBasedCondition); err == nil {
		b.typ = "RuleBasedCondition"
		b.RuleBasedCondition = valueRuleBasedCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BlockStartMessageConditionsItem) MarshalJSON() ([]byte, error) {
	if b.typ == "ModelBasedCondition" || b.ModelBasedCondition != nil {
		return json.Marshal(b.ModelBasedCondition)
	}
	if b.typ == "RuleBasedCondition" || b.RuleBasedCondition != nil {
		return json.Marshal(b.RuleBasedCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BlockStartMessageConditionsItemVisitor interface {
	VisitModelBasedCondition(*ModelBasedCondition) error
	VisitRuleBasedCondition(*RuleBasedCondition) error
}

func (b *BlockStartMessageConditionsItem) Accept(visitor BlockStartMessageConditionsItemVisitor) error {
	if b.typ == "ModelBasedCondition" || b.ModelBasedCondition != nil {
		return visitor.VisitModelBasedCondition(b.ModelBasedCondition)
	}
	if b.typ == "RuleBasedCondition" || b.RuleBasedCondition != nil {
		return visitor.VisitRuleBasedCondition(b.RuleBasedCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BothCustomEndpointingRule struct {
	// This endpointing rule is based on both the last assistant message and the current customer message as they are speaking.
	//
	// Flow:
	// - Assistant speaks
	// - Customer starts speaking
	// - Customer transcription comes in
	// - This rule is evaluated on the last assistant message and the current customer transcription
	// - If assistant message matches `assistantRegex` AND customer message matches `customerRegex`, the endpointing timeout is set to `timeoutSeconds`
	//
	// Usage:
	// - If you want to wait longer while customer is speaking numbers, you can set a longer timeout.
	// This is the regex pattern to match the assistant's message.
	//
	// Note:
	// - This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test("hello there")` will return `true`.
	//
	// Hot tip:
	// - In JavaScript, escape `\` when sending the regex pattern. Eg. `"hello\sthere"` will be sent over the wire as `"hellosthere"`. Send `"hello\\sthere"` instead.
	// - `RegExp.test` does substring matching, so `/cat/.test("I love cats")` will return `true`. To do full string matching, send "^cat$".
	AssistantRegex string `json:"assistantRegex" url:"assistantRegex"`
	// These are the options for the assistant's message regex match. Defaults to all disabled.
	//
	// @default []
	AssistantRegexOptions []*RegexOption `json:"assistantRegexOptions,omitempty" url:"assistantRegexOptions,omitempty"`
	CustomerRegex         string         `json:"customerRegex" url:"customerRegex"`
	// These are the options for the customer's message regex match. Defaults to all disabled.
	//
	// @default []
	CustomerRegexOptions []*RegexOption `json:"customerRegexOptions,omitempty" url:"customerRegexOptions,omitempty"`
	// This is the endpointing timeout in seconds, if the rule is matched.
	TimeoutSeconds float64 `json:"timeoutSeconds" url:"timeoutSeconds"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BothCustomEndpointingRule) GetAssistantRegex() string {
	if b == nil {
		return ""
	}
	return b.AssistantRegex
}

func (b *BothCustomEndpointingRule) GetAssistantRegexOptions() []*RegexOption {
	if b == nil {
		return nil
	}
	return b.AssistantRegexOptions
}

func (b *BothCustomEndpointingRule) GetCustomerRegex() string {
	if b == nil {
		return ""
	}
	return b.CustomerRegex
}

func (b *BothCustomEndpointingRule) GetCustomerRegexOptions() []*RegexOption {
	if b == nil {
		return nil
	}
	return b.CustomerRegexOptions
}

func (b *BothCustomEndpointingRule) GetTimeoutSeconds() float64 {
	if b == nil {
		return 0
	}
	return b.TimeoutSeconds
}

func (b *BothCustomEndpointingRule) Type() string {
	return b.type_
}

func (b *BothCustomEndpointingRule) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BothCustomEndpointingRule) UnmarshalJSON(data []byte) error {
	type embed BothCustomEndpointingRule
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BothCustomEndpointingRule(unmarshaler.embed)
	if unmarshaler.Type != "both" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "both", unmarshaler.Type)
	}
	b.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "type")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BothCustomEndpointingRule) MarshalJSON() ([]byte, error) {
	type embed BothCustomEndpointingRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "both",
	}
	return json.Marshal(marshaler)
}

func (b *BothCustomEndpointingRule) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BucketPlan struct {
	// This is the name of the bucket.
	Name string `json:"name" url:"name"`
	// This is the region of the bucket.
	//
	// Usage:
	// - If `credential.type` is `aws`, then this is required.
	// - If `credential.type` is `gcp`, then this is optional since GCP allows buckets to be accessed without a region but region is required for data residency requirements. Read here: https://cloud.google.com/storage/docs/request-endpoints
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// This is the path where call artifacts will be stored.
	//
	// Usage:
	// - To store call artifacts in a specific folder, set this to the full path. Eg. "/folder-name1/folder-name2".
	// - To store call artifacts in the root of the bucket, leave this blank.
	//
	// @default "/"
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// This is the HMAC access key offered by GCP for interoperability with S3 clients. Here is the guide on how to create: https://cloud.google.com/storage/docs/authentication/managing-hmackeys#console
	//
	// Usage:
	// - If `credential.type` is `gcp`, then this is required.
	// - If `credential.type` is `aws`, then this is not required since credential.awsAccessKeyId is used instead.
	HmacAccessKey *string `json:"hmacAccessKey,omitempty" url:"hmacAccessKey,omitempty"`
	// This is the secret for the HMAC access key. Here is the guide on how to create: https://cloud.google.com/storage/docs/authentication/managing-hmackeys#console
	//
	// Usage:
	// - If `credential.type` is `gcp`, then this is required.
	// - If `credential.type` is `aws`, then this is not required since credential.awsSecretAccessKey is used instead.
	//
	// Note: This is not returned in the API.
	HmacSecret *string `json:"hmacSecret,omitempty" url:"hmacSecret,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BucketPlan) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *BucketPlan) GetRegion() *string {
	if b == nil {
		return nil
	}
	return b.Region
}

func (b *BucketPlan) GetPath() *string {
	if b == nil {
		return nil
	}
	return b.Path
}

func (b *BucketPlan) GetHmacAccessKey() *string {
	if b == nil {
		return nil
	}
	return b.HmacAccessKey
}

func (b *BucketPlan) GetHmacSecret() *string {
	if b == nil {
		return nil
	}
	return b.HmacSecret
}

func (b *BucketPlan) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BucketPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler BucketPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BucketPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BucketPlan) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BuyPhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *BuyPhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// This is the area code of the phone number to purchase.
	AreaCode string `json:"areaCode" url:"areaCode"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BuyPhoneNumberDto) GetFallbackDestination() *BuyPhoneNumberDtoFallbackDestination {
	if b == nil {
		return nil
	}
	return b.FallbackDestination
}

func (b *BuyPhoneNumberDto) GetAreaCode() string {
	if b == nil {
		return ""
	}
	return b.AreaCode
}

func (b *BuyPhoneNumberDto) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BuyPhoneNumberDto) GetAssistantId() *string {
	if b == nil {
		return nil
	}
	return b.AssistantId
}

func (b *BuyPhoneNumberDto) GetSquadId() *string {
	if b == nil {
		return nil
	}
	return b.SquadId
}

func (b *BuyPhoneNumberDto) GetServer() *Server {
	if b == nil {
		return nil
	}
	return b.Server
}

func (b *BuyPhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BuyPhoneNumberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler BuyPhoneNumberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BuyPhoneNumberDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BuyPhoneNumberDto) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// This is the fallback destination an inbound call will be transferred to if:
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type BuyPhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (b *BuyPhoneNumberDtoFallbackDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if b == nil {
		return nil
	}
	return b.TransferDestinationNumber
}

func (b *BuyPhoneNumberDtoFallbackDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if b == nil {
		return nil
	}
	return b.TransferDestinationSip
}

func (b *BuyPhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		b.typ = "TransferDestinationNumber"
		b.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		b.typ = "TransferDestinationSip"
		b.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BuyPhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if b.typ == "TransferDestinationNumber" || b.TransferDestinationNumber != nil {
		return json.Marshal(b.TransferDestinationNumber)
	}
	if b.typ == "TransferDestinationSip" || b.TransferDestinationSip != nil {
		return json.Marshal(b.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BuyPhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (b *BuyPhoneNumberDtoFallbackDestination) Accept(visitor BuyPhoneNumberDtoFallbackDestinationVisitor) error {
	if b.typ == "TransferDestinationNumber" || b.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(b.TransferDestinationNumber)
	}
	if b.typ == "TransferDestinationSip" || b.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(b.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type ByoSipTrunkCredential struct {
	// This can be used to bring your own SIP trunks or to connect to a Carrier.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This can be used to configure the tech prefix on outbound calls. This is an advanced property.
	TechPrefix *string `json:"techPrefix,omitempty" url:"techPrefix,omitempty"`
	// This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.
	SipDiversionHeader *string `json:"sipDiversionHeader,omitempty" url:"sipDiversionHeader,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *ByoSipTrunkCredential) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *ByoSipTrunkCredential) GetOrgId() string {
	if b == nil {
		return ""
	}
	return b.OrgId
}

func (b *ByoSipTrunkCredential) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *ByoSipTrunkCredential) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *ByoSipTrunkCredential) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *ByoSipTrunkCredential) GetGateways() []*SipTrunkGateway {
	if b == nil {
		return nil
	}
	return b.Gateways
}

func (b *ByoSipTrunkCredential) GetOutboundAuthenticationPlan() *SipTrunkOutboundAuthenticationPlan {
	if b == nil {
		return nil
	}
	return b.OutboundAuthenticationPlan
}

func (b *ByoSipTrunkCredential) GetOutboundLeadingPlusEnabled() *bool {
	if b == nil {
		return nil
	}
	return b.OutboundLeadingPlusEnabled
}

func (b *ByoSipTrunkCredential) GetTechPrefix() *string {
	if b == nil {
		return nil
	}
	return b.TechPrefix
}

func (b *ByoSipTrunkCredential) GetSipDiversionHeader() *string {
	if b == nil {
		return nil
	}
	return b.SipDiversionHeader
}

func (b *ByoSipTrunkCredential) GetSbcConfiguration() *SbcConfiguration {
	if b == nil {
		return nil
	}
	return b.SbcConfiguration
}

func (b *ByoSipTrunkCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *ByoSipTrunkCredential) UnmarshalJSON(data []byte) error {
	type embed ByoSipTrunkCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = ByoSipTrunkCredential(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *ByoSipTrunkCredential) MarshalJSON() ([]byte, error) {
	type embed ByoSipTrunkCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewDateTime(b.CreatedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *ByoSipTrunkCredential) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CallLogPrivileged struct {
	// This is the unique identifier for the call.
	CallId string `json:"callId" url:"callId"`
	// This is the unique identifier for the org that this call log belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the log message associated with the call.
	Log string `json:"log" url:"log"`
	// This is the level of the log message.
	Level CallLogPrivilegedLevel `json:"level" url:"level"`
	// This is the ISO 8601 date-time string of when the log was created.
	Time time.Time `json:"time" url:"time"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CallLogPrivileged) GetCallId() string {
	if c == nil {
		return ""
	}
	return c.CallId
}

func (c *CallLogPrivileged) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CallLogPrivileged) GetLog() string {
	if c == nil {
		return ""
	}
	return c.Log
}

func (c *CallLogPrivileged) GetLevel() CallLogPrivilegedLevel {
	if c == nil {
		return ""
	}
	return c.Level
}

func (c *CallLogPrivileged) GetTime() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Time
}

func (c *CallLogPrivileged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallLogPrivileged) UnmarshalJSON(data []byte) error {
	type embed CallLogPrivileged
	var unmarshaler = struct {
		embed
		Time *internal.DateTime `json:"time"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CallLogPrivileged(unmarshaler.embed)
	c.Time = unmarshaler.Time.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallLogPrivileged) MarshalJSON() ([]byte, error) {
	type embed CallLogPrivileged
	var marshaler = struct {
		embed
		Time *internal.DateTime `json:"time"`
	}{
		embed: embed(*c),
		Time:  internal.NewDateTime(c.Time),
	}
	return json.Marshal(marshaler)
}

func (c *CallLogPrivileged) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the level of the log message.
type CallLogPrivilegedLevel string

const (
	CallLogPrivilegedLevelInfo       CallLogPrivilegedLevel = "INFO"
	CallLogPrivilegedLevelLog        CallLogPrivilegedLevel = "LOG"
	CallLogPrivilegedLevelWarn       CallLogPrivilegedLevel = "WARN"
	CallLogPrivilegedLevelError      CallLogPrivilegedLevel = "ERROR"
	CallLogPrivilegedLevelCheckpoint CallLogPrivilegedLevel = "CHECKPOINT"
)

func NewCallLogPrivilegedLevelFromString(s string) (CallLogPrivilegedLevel, error) {
	switch s {
	case "INFO":
		return CallLogPrivilegedLevelInfo, nil
	case "LOG":
		return CallLogPrivilegedLevelLog, nil
	case "WARN":
		return CallLogPrivilegedLevelWarn, nil
	case "ERROR":
		return CallLogPrivilegedLevelError, nil
	case "CHECKPOINT":
		return CallLogPrivilegedLevelCheckpoint, nil
	}
	var t CallLogPrivilegedLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CallLogPrivilegedLevel) Ptr() *CallLogPrivilegedLevel {
	return &c
}

type CallLogsPaginatedResponse struct {
	Results  []*CallLogPrivileged `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta      `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CallLogsPaginatedResponse) GetResults() []*CallLogPrivileged {
	if c == nil {
		return nil
	}
	return c.Results
}

func (c *CallLogsPaginatedResponse) GetMetadata() *PaginationMeta {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CallLogsPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallLogsPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CallLogsPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CallLogsPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallLogsPaginatedResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CallPaginatedResponse struct {
	Results  []*Call         `json:"results,omitempty" url:"results,omitempty"`
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CallPaginatedResponse) GetResults() []*Call {
	if c == nil {
		return nil
	}
	return c.Results
}

func (c *CallPaginatedResponse) GetMetadata() *PaginationMeta {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CallPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CallPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CallPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallPaginatedResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CallbackStep struct {
	// This is the block to use. To use an existing block, use `blockId`.
	Block *CallbackStepBlock `json:"block,omitempty" url:"block,omitempty"`
	// This is a step that calls back to the previous step after it's done. This effectively means we're spawning a new conversation thread. The previous conversation thread will resume where it left off once this step is done.
	//
	// Use case:
	// - You are collecting a customer's order and while they were on one item, they start a new item or try to modify a previous one. You would make a OrderUpdate block which calls the same block repeatedly when a new update starts.
	// This is the mutations to apply to the context after the step is done.
	Mutations []*AssignmentMutation `json:"mutations,omitempty" url:"mutations,omitempty"`
	// This is the name of the step.
	Name string `json:"name" url:"name"`
	// This is the id of the block to use. To use a transient block, use `block`.
	BlockId *string `json:"blockId,omitempty" url:"blockId,omitempty"`
	// This is the input to the block. You can use any key-value map as input to the block.
	//
	// Example:
	//
	//	{
	//	  "name": "John Doe",
	//	  "age": 20
	//	}
	//
	// You can reference any variable in the context of the current block:
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// Example:
	//
	//	{
	//	  "name": "{{my-tool-call-step.output.name}}",
	//	  "age": "{{my-tool-call-step.input.age}}",
	//	  "date": "{{workflow.input.date}}"
	//	}
	//
	// You can dynamically change the key name.
	//
	// Example:
	//
	//	{
	//	  "{{my-tool-call-step.output.key-name-for-name}}": "{{name}}",
	//	  "{{my-tool-call-step.input.key-name-for-age}}": "{{age}}",
	//	  "{{workflow.input.key-name-for-date}}": "{{date}}"
	//	}
	//
	// You can represent the value as a string, number, boolean, array, or object.
	//
	// Example:
	//
	//	{
	//	  "name": "john",
	//	  "age": 20,
	//	  "date": "2021-01-01",
	//	  "metadata": {
	//	    "unique-key": "{{my-tool-call-step.output.unique-key}}"
	//	  },
	//	  "array": ["A", "B", "C"],
	//	}
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.
	Input map[string]interface{} `json:"input,omitempty" url:"input,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CallbackStep) GetBlock() *CallbackStepBlock {
	if c == nil {
		return nil
	}
	return c.Block
}

func (c *CallbackStep) GetMutations() []*AssignmentMutation {
	if c == nil {
		return nil
	}
	return c.Mutations
}

func (c *CallbackStep) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CallbackStep) GetBlockId() *string {
	if c == nil {
		return nil
	}
	return c.BlockId
}

func (c *CallbackStep) GetInput() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Input
}

func (c *CallbackStep) Type() string {
	return c.type_
}

func (c *CallbackStep) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CallbackStep) UnmarshalJSON(data []byte) error {
	type embed CallbackStep
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CallbackStep(unmarshaler.embed)
	if unmarshaler.Type != "callback" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "callback", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallbackStep) MarshalJSON() ([]byte, error) {
	type embed CallbackStep
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "callback",
	}
	return json.Marshal(marshaler)
}

func (c *CallbackStep) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the block to use. To use an existing block, use `blockId`.
type CallbackStepBlock struct {
	CreateConversationBlockDto *CreateConversationBlockDto
	CreateToolCallBlockDto     *CreateToolCallBlockDto
	// This is the CreateWorkflowBlockDTO object but Swagger does not display nested schemas correctly.
	CreateWorkflowBlockDto *CreateWorkflowBlockDto

	typ string
}

func (c *CallbackStepBlock) GetCreateConversationBlockDto() *CreateConversationBlockDto {
	if c == nil {
		return nil
	}
	return c.CreateConversationBlockDto
}

func (c *CallbackStepBlock) GetCreateToolCallBlockDto() *CreateToolCallBlockDto {
	if c == nil {
		return nil
	}
	return c.CreateToolCallBlockDto
}

func (c *CallbackStepBlock) GetCreateWorkflowBlockDto() *CreateWorkflowBlockDto {
	if c == nil {
		return nil
	}
	return c.CreateWorkflowBlockDto
}

func (c *CallbackStepBlock) UnmarshalJSON(data []byte) error {
	valueCreateConversationBlockDto := new(CreateConversationBlockDto)
	if err := json.Unmarshal(data, &valueCreateConversationBlockDto); err == nil {
		c.typ = "CreateConversationBlockDto"
		c.CreateConversationBlockDto = valueCreateConversationBlockDto
		return nil
	}
	valueCreateToolCallBlockDto := new(CreateToolCallBlockDto)
	if err := json.Unmarshal(data, &valueCreateToolCallBlockDto); err == nil {
		c.typ = "CreateToolCallBlockDto"
		c.CreateToolCallBlockDto = valueCreateToolCallBlockDto
		return nil
	}
	valueCreateWorkflowBlockDto := new(CreateWorkflowBlockDto)
	if err := json.Unmarshal(data, &valueCreateWorkflowBlockDto); err == nil {
		c.typ = "CreateWorkflowBlockDto"
		c.CreateWorkflowBlockDto = valueCreateWorkflowBlockDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CallbackStepBlock) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateConversationBlockDto" || c.CreateConversationBlockDto != nil {
		return json.Marshal(c.CreateConversationBlockDto)
	}
	if c.typ == "CreateToolCallBlockDto" || c.CreateToolCallBlockDto != nil {
		return json.Marshal(c.CreateToolCallBlockDto)
	}
	if c.typ == "CreateWorkflowBlockDto" || c.CreateWorkflowBlockDto != nil {
		return json.Marshal(c.CreateWorkflowBlockDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CallbackStepBlockVisitor interface {
	VisitCreateConversationBlockDto(*CreateConversationBlockDto) error
	VisitCreateToolCallBlockDto(*CreateToolCallBlockDto) error
	VisitCreateWorkflowBlockDto(*CreateWorkflowBlockDto) error
}

func (c *CallbackStepBlock) Accept(visitor CallbackStepBlockVisitor) error {
	if c.typ == "CreateConversationBlockDto" || c.CreateConversationBlockDto != nil {
		return visitor.VisitCreateConversationBlockDto(c.CreateConversationBlockDto)
	}
	if c.typ == "CreateToolCallBlockDto" || c.CreateToolCallBlockDto != nil {
		return visitor.VisitCreateToolCallBlockDto(c.CreateToolCallBlockDto)
	}
	if c.typ == "CreateWorkflowBlockDto" || c.CreateWorkflowBlockDto != nil {
		return visitor.VisitCreateWorkflowBlockDto(c.CreateWorkflowBlockDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CartesiaCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CartesiaCredential) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CartesiaCredential) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CartesiaCredential) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CartesiaCredential) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CartesiaCredential) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CartesiaCredential) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CartesiaCredential) Provider() string {
	return c.provider
}

func (c *CartesiaCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CartesiaCredential) UnmarshalJSON(data []byte) error {
	type embed CartesiaCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CartesiaCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CartesiaCredential) MarshalJSON() ([]byte, error) {
	type embed CartesiaCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Provider:  "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CartesiaCredential) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CartesiaVoice struct {
	// This is the voice provider that will be used.
	// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
	Model *CartesiaVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
	Language *CartesiaVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the provider-specific ID that will be used.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CartesiaVoice) GetModel() *CartesiaVoiceModel {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *CartesiaVoice) GetLanguage() *CartesiaVoiceLanguage {
	if c == nil {
		return nil
	}
	return c.Language
}

func (c *CartesiaVoice) GetChunkPlan() *ChunkPlan {
	if c == nil {
		return nil
	}
	return c.ChunkPlan
}

func (c *CartesiaVoice) GetVoiceId() string {
	if c == nil {
		return ""
	}
	return c.VoiceId
}

func (c *CartesiaVoice) GetFallbackPlan() *FallbackPlan {
	if c == nil {
		return nil
	}
	return c.FallbackPlan
}

func (c *CartesiaVoice) Provider() string {
	return c.provider
}

func (c *CartesiaVoice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CartesiaVoice) UnmarshalJSON(data []byte) error {
	type embed CartesiaVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CartesiaVoice(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CartesiaVoice) MarshalJSON() ([]byte, error) {
	type embed CartesiaVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CartesiaVoice) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
type CartesiaVoiceLanguage string

const (
	CartesiaVoiceLanguageEn CartesiaVoiceLanguage = "en"
	CartesiaVoiceLanguageDe CartesiaVoiceLanguage = "de"
	CartesiaVoiceLanguageEs CartesiaVoiceLanguage = "es"
	CartesiaVoiceLanguageFr CartesiaVoiceLanguage = "fr"
	CartesiaVoiceLanguageJa CartesiaVoiceLanguage = "ja"
	CartesiaVoiceLanguagePt CartesiaVoiceLanguage = "pt"
	CartesiaVoiceLanguageZh CartesiaVoiceLanguage = "zh"
	CartesiaVoiceLanguageHi CartesiaVoiceLanguage = "hi"
	CartesiaVoiceLanguageIt CartesiaVoiceLanguage = "it"
	CartesiaVoiceLanguageKo CartesiaVoiceLanguage = "ko"
	CartesiaVoiceLanguageNl CartesiaVoiceLanguage = "nl"
	CartesiaVoiceLanguagePl CartesiaVoiceLanguage = "pl"
	CartesiaVoiceLanguageRu CartesiaVoiceLanguage = "ru"
	CartesiaVoiceLanguageSv CartesiaVoiceLanguage = "sv"
	CartesiaVoiceLanguageTr CartesiaVoiceLanguage = "tr"
)

func NewCartesiaVoiceLanguageFromString(s string) (CartesiaVoiceLanguage, error) {
	switch s {
	case "en":
		return CartesiaVoiceLanguageEn, nil
	case "de":
		return CartesiaVoiceLanguageDe, nil
	case "es":
		return CartesiaVoiceLanguageEs, nil
	case "fr":
		return CartesiaVoiceLanguageFr, nil
	case "ja":
		return CartesiaVoiceLanguageJa, nil
	case "pt":
		return CartesiaVoiceLanguagePt, nil
	case "zh":
		return CartesiaVoiceLanguageZh, nil
	case "hi":
		return CartesiaVoiceLanguageHi, nil
	case "it":
		return CartesiaVoiceLanguageIt, nil
	case "ko":
		return CartesiaVoiceLanguageKo, nil
	case "nl":
		return CartesiaVoiceLanguageNl, nil
	case "pl":
		return CartesiaVoiceLanguagePl, nil
	case "ru":
		return CartesiaVoiceLanguageRu, nil
	case "sv":
		return CartesiaVoiceLanguageSv, nil
	case "tr":
		return CartesiaVoiceLanguageTr, nil
	}
	var t CartesiaVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CartesiaVoiceLanguage) Ptr() *CartesiaVoiceLanguage {
	return &c
}

// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
type CartesiaVoiceModel string

const (
	CartesiaVoiceModelSonicEnglish      CartesiaVoiceModel = "sonic-english"
	CartesiaVoiceModelSonicMultilingual CartesiaVoiceModel = "sonic-multilingual"
	CartesiaVoiceModelSonicPreview      CartesiaVoiceModel = "sonic-preview"
	CartesiaVoiceModelSonic             CartesiaVoiceModel = "sonic"
)

func NewCartesiaVoiceModelFromString(s string) (CartesiaVoiceModel, error) {
	switch s {
	case "sonic-english":
		return CartesiaVoiceModelSonicEnglish, nil
	case "sonic-multilingual":
		return CartesiaVoiceModelSonicMultilingual, nil
	case "sonic-preview":
		return CartesiaVoiceModelSonicPreview, nil
	case "sonic":
		return CartesiaVoiceModelSonic, nil
	}
	var t CartesiaVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CartesiaVoiceModel) Ptr() *CartesiaVoiceModel {
	return &c
}

type CerebrasCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CerebrasCredential) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CerebrasCredential) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CerebrasCredential) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CerebrasCredential) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CerebrasCredential) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CerebrasCredential) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CerebrasCredential) Provider() string {
	return c.provider
}

func (c *CerebrasCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CerebrasCredential) UnmarshalJSON(data []byte) error {
	type embed CerebrasCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CerebrasCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "cerebras" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cerebras", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CerebrasCredential) MarshalJSON() ([]byte, error) {
	type embed CerebrasCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Provider:  "cerebras",
	}
	return json.Marshal(marshaler)
}

func (c *CerebrasCredential) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatDto struct {
	Messages           []*OpenAiMessage    `json:"messages,omitempty" url:"messages,omitempty"`
	AssistantId        *string             `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	Assistant          *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatDto) GetMessages() []*OpenAiMessage {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ChatDto) GetAssistantId() *string {
	if c == nil {
		return nil
	}
	return c.AssistantId
}

func (c *ChatDto) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ChatDto) GetAssistantOverrides() *AssistantOverrides {
	if c == nil {
		return nil
	}
	return c.AssistantOverrides
}

func (c *ChatDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatDto) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatServiceResponse struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatServiceResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatServiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatServiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatServiceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatServiceResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChunkPlan struct {
	// This determines whether the model output is chunked before being sent to the voice provider. Default `true`.
	//
	// Usage:
	// - To rely on the voice provider's audio generation logic, set this to `false`.
	// - If seeing issues with quality, set this to `true`.
	//
	// If disabled, Vapi-provided audio control tokens like <flush /> will not work.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the minimum number of characters in a chunk.
	//
	// Usage:
	// - To increase quality, set this to a higher value.
	// - To decrease latency, set this to a lower value.
	//
	// @default 30
	MinCharacters *float64 `json:"minCharacters,omitempty" url:"minCharacters,omitempty"`
	// These are the punctuations that are considered valid boundaries for a chunk to be created.
	//
	// Usage:
	// - To increase quality, constrain to fewer boundaries.
	// - To decrease latency, enable all.
	//
	// Default is automatically set to balance the trade-off between quality and latency based on the provider.
	PunctuationBoundaries []PunctuationBoundary `json:"punctuationBoundaries,omitempty" url:"punctuationBoundaries,omitempty"`
	// This is the plan for formatting the chunk before it is sent to the voice provider.
	FormatPlan *FormatPlan `json:"formatPlan,omitempty" url:"formatPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChunkPlan) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *ChunkPlan) GetMinCharacters() *float64 {
	if c == nil {
		return nil
	}
	return c.MinCharacters
}

func (c *ChunkPlan) GetPunctuationBoundaries() []PunctuationBoundary {
	if c == nil {
		return nil
	}
	return c.PunctuationBoundaries
}

func (c *ChunkPlan) GetFormatPlan() *FormatPlan {
	if c == nil {
		return nil
	}
	return c.FormatPlan
}

func (c *ChunkPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChunkPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler ChunkPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChunkPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChunkPlan) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessage struct {
	// These are the messages that can be sent from client-side SDKs to control the call.
	Message *ClientInboundMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessage) GetMessage() *ClientInboundMessageMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ClientInboundMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientInboundMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientInboundMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessageAddMessage struct {
	// This is the type of the message. Send "add-message" message to add a message to the conversation history.
	// This is the message to add to the conversation.
	Message *OpenAiMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the flag to trigger a response, or to insert the message into the conversation history silently. Defaults to `true`.
	//
	// Usage:
	// - Use `true` to trigger a response.
	// - Use `false` to insert the message into the conversation history silently.
	//
	// @default true
	TriggerResponseEnabled *bool `json:"triggerResponseEnabled,omitempty" url:"triggerResponseEnabled,omitempty"`
	type_                  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageAddMessage) GetMessage() *OpenAiMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ClientInboundMessageAddMessage) GetTriggerResponseEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.TriggerResponseEnabled
}

func (c *ClientInboundMessageAddMessage) Type() string {
	return c.type_
}

func (c *ClientInboundMessageAddMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageAddMessage) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageAddMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageAddMessage(unmarshaler.embed)
	if unmarshaler.Type != "add-message" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "add-message", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageAddMessage) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageAddMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "add-message",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageAddMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessageControl struct {
	// This is the type of the message. Send "control" message to control the assistant. `control` options are:
	// - "mute-assistant" - mute the assistant
	// - "unmute-assistant" - unmute the assistant
	// - "say-first-message" - say the first message (this is used when video recording is enabled and the conversation is only started once the client side kicks off the recording)
	// This is the control action
	Control ClientInboundMessageControlControl `json:"control" url:"control"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageControl) GetControl() ClientInboundMessageControlControl {
	if c == nil {
		return ""
	}
	return c.Control
}

func (c *ClientInboundMessageControl) Type() string {
	return c.type_
}

func (c *ClientInboundMessageControl) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageControl) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageControl
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageControl(unmarshaler.embed)
	if unmarshaler.Type != "control" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "control", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageControl) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageControl
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "control",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageControl) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the control action
type ClientInboundMessageControlControl string

const (
	ClientInboundMessageControlControlMuteAssistant   ClientInboundMessageControlControl = "mute-assistant"
	ClientInboundMessageControlControlUnmuteAssistant ClientInboundMessageControlControl = "unmute-assistant"
	ClientInboundMessageControlControlSayFirstMessage ClientInboundMessageControlControl = "say-first-message"
)

func NewClientInboundMessageControlControlFromString(s string) (ClientInboundMessageControlControl, error) {
	switch s {
	case "mute-assistant":
		return ClientInboundMessageControlControlMuteAssistant, nil
	case "unmute-assistant":
		return ClientInboundMessageControlControlUnmuteAssistant, nil
	case "say-first-message":
		return ClientInboundMessageControlControlSayFirstMessage, nil
	}
	var t ClientInboundMessageControlControl
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientInboundMessageControlControl) Ptr() *ClientInboundMessageControlControl {
	return &c
}

// These are the messages that can be sent from client-side SDKs to control the call.
type ClientInboundMessageMessage struct {
	ClientInboundMessageAddMessage *ClientInboundMessageAddMessage
	ClientInboundMessageControl    *ClientInboundMessageControl
	ClientInboundMessageSay        *ClientInboundMessageSay
	ClientInboundMessageTransfer   *ClientInboundMessageTransfer

	typ string
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageAddMessage() *ClientInboundMessageAddMessage {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageAddMessage
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageControl() *ClientInboundMessageControl {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageControl
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageSay() *ClientInboundMessageSay {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageSay
}

func (c *ClientInboundMessageMessage) GetClientInboundMessageTransfer() *ClientInboundMessageTransfer {
	if c == nil {
		return nil
	}
	return c.ClientInboundMessageTransfer
}

func (c *ClientInboundMessageMessage) UnmarshalJSON(data []byte) error {
	valueClientInboundMessageAddMessage := new(ClientInboundMessageAddMessage)
	if err := json.Unmarshal(data, &valueClientInboundMessageAddMessage); err == nil {
		c.typ = "ClientInboundMessageAddMessage"
		c.ClientInboundMessageAddMessage = valueClientInboundMessageAddMessage
		return nil
	}
	valueClientInboundMessageControl := new(ClientInboundMessageControl)
	if err := json.Unmarshal(data, &valueClientInboundMessageControl); err == nil {
		c.typ = "ClientInboundMessageControl"
		c.ClientInboundMessageControl = valueClientInboundMessageControl
		return nil
	}
	valueClientInboundMessageSay := new(ClientInboundMessageSay)
	if err := json.Unmarshal(data, &valueClientInboundMessageSay); err == nil {
		c.typ = "ClientInboundMessageSay"
		c.ClientInboundMessageSay = valueClientInboundMessageSay
		return nil
	}
	valueClientInboundMessageTransfer := new(ClientInboundMessageTransfer)
	if err := json.Unmarshal(data, &valueClientInboundMessageTransfer); err == nil {
		c.typ = "ClientInboundMessageTransfer"
		c.ClientInboundMessageTransfer = valueClientInboundMessageTransfer
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientInboundMessageMessage) MarshalJSON() ([]byte, error) {
	if c.typ == "ClientInboundMessageAddMessage" || c.ClientInboundMessageAddMessage != nil {
		return json.Marshal(c.ClientInboundMessageAddMessage)
	}
	if c.typ == "ClientInboundMessageControl" || c.ClientInboundMessageControl != nil {
		return json.Marshal(c.ClientInboundMessageControl)
	}
	if c.typ == "ClientInboundMessageSay" || c.ClientInboundMessageSay != nil {
		return json.Marshal(c.ClientInboundMessageSay)
	}
	if c.typ == "ClientInboundMessageTransfer" || c.ClientInboundMessageTransfer != nil {
		return json.Marshal(c.ClientInboundMessageTransfer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientInboundMessageMessageVisitor interface {
	VisitClientInboundMessageAddMessage(*ClientInboundMessageAddMessage) error
	VisitClientInboundMessageControl(*ClientInboundMessageControl) error
	VisitClientInboundMessageSay(*ClientInboundMessageSay) error
	VisitClientInboundMessageTransfer(*ClientInboundMessageTransfer) error
}

func (c *ClientInboundMessageMessage) Accept(visitor ClientInboundMessageMessageVisitor) error {
	if c.typ == "ClientInboundMessageAddMessage" || c.ClientInboundMessageAddMessage != nil {
		return visitor.VisitClientInboundMessageAddMessage(c.ClientInboundMessageAddMessage)
	}
	if c.typ == "ClientInboundMessageControl" || c.ClientInboundMessageControl != nil {
		return visitor.VisitClientInboundMessageControl(c.ClientInboundMessageControl)
	}
	if c.typ == "ClientInboundMessageSay" || c.ClientInboundMessageSay != nil {
		return visitor.VisitClientInboundMessageSay(c.ClientInboundMessageSay)
	}
	if c.typ == "ClientInboundMessageTransfer" || c.ClientInboundMessageTransfer != nil {
		return visitor.VisitClientInboundMessageTransfer(c.ClientInboundMessageTransfer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientInboundMessageSay struct {
	// This is the type of the message. Send "say" message to make the assistant say something.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the content to say.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is the flag to end call after content is spoken.
	EndCallAfterSpoken *bool `json:"endCallAfterSpoken,omitempty" url:"endCallAfterSpoken,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageSay) GetContent() *string {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ClientInboundMessageSay) GetEndCallAfterSpoken() *bool {
	if c == nil {
		return nil
	}
	return c.EndCallAfterSpoken
}

func (c *ClientInboundMessageSay) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageSay) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientInboundMessageSay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientInboundMessageSay(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageSay) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientInboundMessageTransfer struct {
	// This is the type of the message. Send "transfer" message to transfer the call to a destination.
	// This is the destination to transfer the call to.
	Destination *ClientInboundMessageTransferDestination `json:"destination,omitempty" url:"destination,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientInboundMessageTransfer) GetDestination() *ClientInboundMessageTransferDestination {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *ClientInboundMessageTransfer) Type() string {
	return c.type_
}

func (c *ClientInboundMessageTransfer) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientInboundMessageTransfer) UnmarshalJSON(data []byte) error {
	type embed ClientInboundMessageTransfer
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientInboundMessageTransfer(unmarshaler.embed)
	if unmarshaler.Type != "transfer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transfer", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientInboundMessageTransfer) MarshalJSON() ([]byte, error) {
	type embed ClientInboundMessageTransfer
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transfer",
	}
	return json.Marshal(marshaler)
}

func (c *ClientInboundMessageTransfer) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the destination to transfer the call to.
type ClientInboundMessageTransferDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (c *ClientInboundMessageTransferDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if c == nil {
		return nil
	}
	return c.TransferDestinationNumber
}

func (c *ClientInboundMessageTransferDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if c == nil {
		return nil
	}
	return c.TransferDestinationSip
}

func (c *ClientInboundMessageTransferDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.typ = "TransferDestinationNumber"
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.typ = "TransferDestinationSip"
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientInboundMessageTransferDestination) MarshalJSON() ([]byte, error) {
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientInboundMessageTransferDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *ClientInboundMessageTransferDestination) Accept(visitor ClientInboundMessageTransferDestinationVisitor) error {
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessage struct {
	// These are all the messages that can be sent to the client-side SDKs during the call. Configure the messages you'd like to receive in `assistant.clientMessages`.
	Message *ClientMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessage) GetMessage() *ClientMessageMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ClientMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageConversationUpdate struct {
	// This is the type of the message. "conversation-update" is sent when an update is committed to the conversation history.
	// This is the most up-to-date conversation history at the time the message is sent.
	Messages []*ClientMessageConversationUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the most up-to-date conversation history at the time the message is sent, formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	type_                   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageConversationUpdate) GetMessages() []*ClientMessageConversationUpdateMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ClientMessageConversationUpdate) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if c == nil {
		return nil
	}
	return c.MessagesOpenAiFormatted
}

func (c *ClientMessageConversationUpdate) Type() string {
	return c.type_
}

func (c *ClientMessageConversationUpdate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageConversationUpdate) UnmarshalJSON(data []byte) error {
	type embed ClientMessageConversationUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageConversationUpdate(unmarshaler.embed)
	if unmarshaler.Type != "conversation-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation-update", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageConversationUpdate) MarshalJSON() ([]byte, error) {
	type embed ClientMessageConversationUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "conversation-update",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageConversationUpdate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageConversationUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (c *ClientMessageConversationUpdateMessagesItem) GetUserMessage() *UserMessage {
	if c == nil {
		return nil
	}
	return c.UserMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) GetSystemMessage() *SystemMessage {
	if c == nil {
		return nil
	}
	return c.SystemMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) GetBotMessage() *BotMessage {
	if c == nil {
		return nil
	}
	return c.BotMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if c == nil {
		return nil
	}
	return c.ToolCallMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if c == nil {
		return nil
	}
	return c.ToolCallResultMessage
}

func (c *ClientMessageConversationUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		c.typ = "UserMessage"
		c.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		c.typ = "SystemMessage"
		c.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		c.typ = "BotMessage"
		c.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		c.typ = "ToolCallMessage"
		c.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		c.typ = "ToolCallResultMessage"
		c.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageConversationUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return json.Marshal(c.UserMessage)
	}
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return json.Marshal(c.SystemMessage)
	}
	if c.typ == "BotMessage" || c.BotMessage != nil {
		return json.Marshal(c.BotMessage)
	}
	if c.typ == "ToolCallMessage" || c.ToolCallMessage != nil {
		return json.Marshal(c.ToolCallMessage)
	}
	if c.typ == "ToolCallResultMessage" || c.ToolCallResultMessage != nil {
		return json.Marshal(c.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageConversationUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (c *ClientMessageConversationUpdateMessagesItem) Accept(visitor ClientMessageConversationUpdateMessagesItemVisitor) error {
	if c.typ == "UserMessage" || c.UserMessage != nil {
		return visitor.VisitUserMessage(c.UserMessage)
	}
	if c.typ == "SystemMessage" || c.SystemMessage != nil {
		return visitor.VisitSystemMessage(c.SystemMessage)
	}
	if c.typ == "BotMessage" || c.BotMessage != nil {
		return visitor.VisitBotMessage(c.BotMessage)
	}
	if c.typ == "ToolCallMessage" || c.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(c.ToolCallMessage)
	}
	if c.typ == "ToolCallResultMessage" || c.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(c.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageHang struct {
	// This is the type of the message. "hang" is sent when the assistant is hanging due to a delay. The delay can be caused by many factors, such as:
	// - the model is too slow to respond
	// - the voice is too slow to respond
	// - the tool call is still waiting for a response from your server
	// - etc.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageHang) Type() string {
	return c.type_
}

func (c *ClientMessageHang) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageHang) UnmarshalJSON(data []byte) error {
	type embed ClientMessageHang
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageHang(unmarshaler.embed)
	if unmarshaler.Type != "hang" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "hang", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageHang) MarshalJSON() ([]byte, error) {
	type embed ClientMessageHang
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "hang",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageHang) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageLanguageChangeDetected struct {
	// This is the type of the message. "language-change-detected" is sent when the transcriber is automatically switched based on the detected language.
	// This is the language the transcriber is switched to.
	Language string `json:"language" url:"language"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageLanguageChangeDetected) GetLanguage() string {
	if c == nil {
		return ""
	}
	return c.Language
}

func (c *ClientMessageLanguageChangeDetected) Type() string {
	return c.type_
}

func (c *ClientMessageLanguageChangeDetected) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageLanguageChangeDetected) UnmarshalJSON(data []byte) error {
	type embed ClientMessageLanguageChangeDetected
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageLanguageChangeDetected(unmarshaler.embed)
	if unmarshaler.Type != "language-change-detected" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "language-change-detected", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageLanguageChangeDetected) MarshalJSON() ([]byte, error) {
	type embed ClientMessageLanguageChangeDetected
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "language-change-detected",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageLanguageChangeDetected) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// These are all the messages that can be sent to the client-side SDKs during the call. Configure the messages you'd like to receive in `assistant.clientMessages`.
type ClientMessageMessage struct {
	ClientMessageConversationUpdate     *ClientMessageConversationUpdate
	ClientMessageHang                   *ClientMessageHang
	ClientMessageMetadata               *ClientMessageMetadata
	ClientMessageModelOutput            *ClientMessageModelOutput
	ClientMessageSpeechUpdate           *ClientMessageSpeechUpdate
	ClientMessageTranscript             *ClientMessageTranscript
	ClientMessageToolCalls              *ClientMessageToolCalls
	ClientMessageToolCallsResult        *ClientMessageToolCallsResult
	ClientMessageTransferUpdate         *ClientMessageTransferUpdate
	ClientMessageUserInterrupted        *ClientMessageUserInterrupted
	ClientMessageLanguageChangeDetected *ClientMessageLanguageChangeDetected
	ClientMessageVoiceInput             *ClientMessageVoiceInput

	typ string
}

func (c *ClientMessageMessage) GetClientMessageConversationUpdate() *ClientMessageConversationUpdate {
	if c == nil {
		return nil
	}
	return c.ClientMessageConversationUpdate
}

func (c *ClientMessageMessage) GetClientMessageHang() *ClientMessageHang {
	if c == nil {
		return nil
	}
	return c.ClientMessageHang
}

func (c *ClientMessageMessage) GetClientMessageMetadata() *ClientMessageMetadata {
	if c == nil {
		return nil
	}
	return c.ClientMessageMetadata
}

func (c *ClientMessageMessage) GetClientMessageModelOutput() *ClientMessageModelOutput {
	if c == nil {
		return nil
	}
	return c.ClientMessageModelOutput
}

func (c *ClientMessageMessage) GetClientMessageSpeechUpdate() *ClientMessageSpeechUpdate {
	if c == nil {
		return nil
	}
	return c.ClientMessageSpeechUpdate
}

func (c *ClientMessageMessage) GetClientMessageTranscript() *ClientMessageTranscript {
	if c == nil {
		return nil
	}
	return c.ClientMessageTranscript
}

func (c *ClientMessageMessage) GetClientMessageToolCalls() *ClientMessageToolCalls {
	if c == nil {
		return nil
	}
	return c.ClientMessageToolCalls
}

func (c *ClientMessageMessage) GetClientMessageToolCallsResult() *ClientMessageToolCallsResult {
	if c == nil {
		return nil
	}
	return c.ClientMessageToolCallsResult
}

func (c *ClientMessageMessage) GetClientMessageTransferUpdate() *ClientMessageTransferUpdate {
	if c == nil {
		return nil
	}
	return c.ClientMessageTransferUpdate
}

func (c *ClientMessageMessage) GetClientMessageUserInterrupted() *ClientMessageUserInterrupted {
	if c == nil {
		return nil
	}
	return c.ClientMessageUserInterrupted
}

func (c *ClientMessageMessage) GetClientMessageLanguageChangeDetected() *ClientMessageLanguageChangeDetected {
	if c == nil {
		return nil
	}
	return c.ClientMessageLanguageChangeDetected
}

func (c *ClientMessageMessage) GetClientMessageVoiceInput() *ClientMessageVoiceInput {
	if c == nil {
		return nil
	}
	return c.ClientMessageVoiceInput
}

func (c *ClientMessageMessage) UnmarshalJSON(data []byte) error {
	valueClientMessageConversationUpdate := new(ClientMessageConversationUpdate)
	if err := json.Unmarshal(data, &valueClientMessageConversationUpdate); err == nil {
		c.typ = "ClientMessageConversationUpdate"
		c.ClientMessageConversationUpdate = valueClientMessageConversationUpdate
		return nil
	}
	valueClientMessageHang := new(ClientMessageHang)
	if err := json.Unmarshal(data, &valueClientMessageHang); err == nil {
		c.typ = "ClientMessageHang"
		c.ClientMessageHang = valueClientMessageHang
		return nil
	}
	valueClientMessageMetadata := new(ClientMessageMetadata)
	if err := json.Unmarshal(data, &valueClientMessageMetadata); err == nil {
		c.typ = "ClientMessageMetadata"
		c.ClientMessageMetadata = valueClientMessageMetadata
		return nil
	}
	valueClientMessageModelOutput := new(ClientMessageModelOutput)
	if err := json.Unmarshal(data, &valueClientMessageModelOutput); err == nil {
		c.typ = "ClientMessageModelOutput"
		c.ClientMessageModelOutput = valueClientMessageModelOutput
		return nil
	}
	valueClientMessageSpeechUpdate := new(ClientMessageSpeechUpdate)
	if err := json.Unmarshal(data, &valueClientMessageSpeechUpdate); err == nil {
		c.typ = "ClientMessageSpeechUpdate"
		c.ClientMessageSpeechUpdate = valueClientMessageSpeechUpdate
		return nil
	}
	valueClientMessageTranscript := new(ClientMessageTranscript)
	if err := json.Unmarshal(data, &valueClientMessageTranscript); err == nil {
		c.typ = "ClientMessageTranscript"
		c.ClientMessageTranscript = valueClientMessageTranscript
		return nil
	}
	valueClientMessageToolCalls := new(ClientMessageToolCalls)
	if err := json.Unmarshal(data, &valueClientMessageToolCalls); err == nil {
		c.typ = "ClientMessageToolCalls"
		c.ClientMessageToolCalls = valueClientMessageToolCalls
		return nil
	}
	valueClientMessageToolCallsResult := new(ClientMessageToolCallsResult)
	if err := json.Unmarshal(data, &valueClientMessageToolCallsResult); err == nil {
		c.typ = "ClientMessageToolCallsResult"
		c.ClientMessageToolCallsResult = valueClientMessageToolCallsResult
		return nil
	}
	valueClientMessageTransferUpdate := new(ClientMessageTransferUpdate)
	if err := json.Unmarshal(data, &valueClientMessageTransferUpdate); err == nil {
		c.typ = "ClientMessageTransferUpdate"
		c.ClientMessageTransferUpdate = valueClientMessageTransferUpdate
		return nil
	}
	valueClientMessageUserInterrupted := new(ClientMessageUserInterrupted)
	if err := json.Unmarshal(data, &valueClientMessageUserInterrupted); err == nil {
		c.typ = "ClientMessageUserInterrupted"
		c.ClientMessageUserInterrupted = valueClientMessageUserInterrupted
		return nil
	}
	valueClientMessageLanguageChangeDetected := new(ClientMessageLanguageChangeDetected)
	if err := json.Unmarshal(data, &valueClientMessageLanguageChangeDetected); err == nil {
		c.typ = "ClientMessageLanguageChangeDetected"
		c.ClientMessageLanguageChangeDetected = valueClientMessageLanguageChangeDetected
		return nil
	}
	valueClientMessageVoiceInput := new(ClientMessageVoiceInput)
	if err := json.Unmarshal(data, &valueClientMessageVoiceInput); err == nil {
		c.typ = "ClientMessageVoiceInput"
		c.ClientMessageVoiceInput = valueClientMessageVoiceInput
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageMessage) MarshalJSON() ([]byte, error) {
	if c.typ == "ClientMessageConversationUpdate" || c.ClientMessageConversationUpdate != nil {
		return json.Marshal(c.ClientMessageConversationUpdate)
	}
	if c.typ == "ClientMessageHang" || c.ClientMessageHang != nil {
		return json.Marshal(c.ClientMessageHang)
	}
	if c.typ == "ClientMessageMetadata" || c.ClientMessageMetadata != nil {
		return json.Marshal(c.ClientMessageMetadata)
	}
	if c.typ == "ClientMessageModelOutput" || c.ClientMessageModelOutput != nil {
		return json.Marshal(c.ClientMessageModelOutput)
	}
	if c.typ == "ClientMessageSpeechUpdate" || c.ClientMessageSpeechUpdate != nil {
		return json.Marshal(c.ClientMessageSpeechUpdate)
	}
	if c.typ == "ClientMessageTranscript" || c.ClientMessageTranscript != nil {
		return json.Marshal(c.ClientMessageTranscript)
	}
	if c.typ == "ClientMessageToolCalls" || c.ClientMessageToolCalls != nil {
		return json.Marshal(c.ClientMessageToolCalls)
	}
	if c.typ == "ClientMessageToolCallsResult" || c.ClientMessageToolCallsResult != nil {
		return json.Marshal(c.ClientMessageToolCallsResult)
	}
	if c.typ == "ClientMessageTransferUpdate" || c.ClientMessageTransferUpdate != nil {
		return json.Marshal(c.ClientMessageTransferUpdate)
	}
	if c.typ == "ClientMessageUserInterrupted" || c.ClientMessageUserInterrupted != nil {
		return json.Marshal(c.ClientMessageUserInterrupted)
	}
	if c.typ == "ClientMessageLanguageChangeDetected" || c.ClientMessageLanguageChangeDetected != nil {
		return json.Marshal(c.ClientMessageLanguageChangeDetected)
	}
	if c.typ == "ClientMessageVoiceInput" || c.ClientMessageVoiceInput != nil {
		return json.Marshal(c.ClientMessageVoiceInput)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageMessageVisitor interface {
	VisitClientMessageConversationUpdate(*ClientMessageConversationUpdate) error
	VisitClientMessageHang(*ClientMessageHang) error
	VisitClientMessageMetadata(*ClientMessageMetadata) error
	VisitClientMessageModelOutput(*ClientMessageModelOutput) error
	VisitClientMessageSpeechUpdate(*ClientMessageSpeechUpdate) error
	VisitClientMessageTranscript(*ClientMessageTranscript) error
	VisitClientMessageToolCalls(*ClientMessageToolCalls) error
	VisitClientMessageToolCallsResult(*ClientMessageToolCallsResult) error
	VisitClientMessageTransferUpdate(*ClientMessageTransferUpdate) error
	VisitClientMessageUserInterrupted(*ClientMessageUserInterrupted) error
	VisitClientMessageLanguageChangeDetected(*ClientMessageLanguageChangeDetected) error
	VisitClientMessageVoiceInput(*ClientMessageVoiceInput) error
}

func (c *ClientMessageMessage) Accept(visitor ClientMessageMessageVisitor) error {
	if c.typ == "ClientMessageConversationUpdate" || c.ClientMessageConversationUpdate != nil {
		return visitor.VisitClientMessageConversationUpdate(c.ClientMessageConversationUpdate)
	}
	if c.typ == "ClientMessageHang" || c.ClientMessageHang != nil {
		return visitor.VisitClientMessageHang(c.ClientMessageHang)
	}
	if c.typ == "ClientMessageMetadata" || c.ClientMessageMetadata != nil {
		return visitor.VisitClientMessageMetadata(c.ClientMessageMetadata)
	}
	if c.typ == "ClientMessageModelOutput" || c.ClientMessageModelOutput != nil {
		return visitor.VisitClientMessageModelOutput(c.ClientMessageModelOutput)
	}
	if c.typ == "ClientMessageSpeechUpdate" || c.ClientMessageSpeechUpdate != nil {
		return visitor.VisitClientMessageSpeechUpdate(c.ClientMessageSpeechUpdate)
	}
	if c.typ == "ClientMessageTranscript" || c.ClientMessageTranscript != nil {
		return visitor.VisitClientMessageTranscript(c.ClientMessageTranscript)
	}
	if c.typ == "ClientMessageToolCalls" || c.ClientMessageToolCalls != nil {
		return visitor.VisitClientMessageToolCalls(c.ClientMessageToolCalls)
	}
	if c.typ == "ClientMessageToolCallsResult" || c.ClientMessageToolCallsResult != nil {
		return visitor.VisitClientMessageToolCallsResult(c.ClientMessageToolCallsResult)
	}
	if c.typ == "ClientMessageTransferUpdate" || c.ClientMessageTransferUpdate != nil {
		return visitor.VisitClientMessageTransferUpdate(c.ClientMessageTransferUpdate)
	}
	if c.typ == "ClientMessageUserInterrupted" || c.ClientMessageUserInterrupted != nil {
		return visitor.VisitClientMessageUserInterrupted(c.ClientMessageUserInterrupted)
	}
	if c.typ == "ClientMessageLanguageChangeDetected" || c.ClientMessageLanguageChangeDetected != nil {
		return visitor.VisitClientMessageLanguageChangeDetected(c.ClientMessageLanguageChangeDetected)
	}
	if c.typ == "ClientMessageVoiceInput" || c.ClientMessageVoiceInput != nil {
		return visitor.VisitClientMessageVoiceInput(c.ClientMessageVoiceInput)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageMetadata struct {
	// This is the type of the message. "metadata" is sent to forward metadata to the client.
	// This is the metadata content
	Metadata string `json:"metadata" url:"metadata"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageMetadata) GetMetadata() string {
	if c == nil {
		return ""
	}
	return c.Metadata
}

func (c *ClientMessageMetadata) Type() string {
	return c.type_
}

func (c *ClientMessageMetadata) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageMetadata) UnmarshalJSON(data []byte) error {
	type embed ClientMessageMetadata
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageMetadata(unmarshaler.embed)
	if unmarshaler.Type != "metadata" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "metadata", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageMetadata) MarshalJSON() ([]byte, error) {
	type embed ClientMessageMetadata
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "metadata",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageMetadata) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageModelOutput struct {
	// This is the type of the message. "model-output" is sent as the model outputs tokens.
	// This is the output of the model. It can be a token or tool call.
	Output map[string]interface{} `json:"output,omitempty" url:"output,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageModelOutput) GetOutput() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Output
}

func (c *ClientMessageModelOutput) Type() string {
	return c.type_
}

func (c *ClientMessageModelOutput) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageModelOutput) UnmarshalJSON(data []byte) error {
	type embed ClientMessageModelOutput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageModelOutput(unmarshaler.embed)
	if unmarshaler.Type != "model-output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "model-output", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageModelOutput) MarshalJSON() ([]byte, error) {
	type embed ClientMessageModelOutput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "model-output",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageModelOutput) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageSpeechUpdate struct {
	// This is the type of the message. "speech-update" is sent whenever assistant or user start or stop speaking.
	// This is the status of the speech update.
	Status ClientMessageSpeechUpdateStatus `json:"status" url:"status"`
	// This is the role which the speech update is for.
	Role  ClientMessageSpeechUpdateRole `json:"role" url:"role"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageSpeechUpdate) GetStatus() ClientMessageSpeechUpdateStatus {
	if c == nil {
		return ""
	}
	return c.Status
}

func (c *ClientMessageSpeechUpdate) GetRole() ClientMessageSpeechUpdateRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ClientMessageSpeechUpdate) Type() string {
	return c.type_
}

func (c *ClientMessageSpeechUpdate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageSpeechUpdate) UnmarshalJSON(data []byte) error {
	type embed ClientMessageSpeechUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageSpeechUpdate(unmarshaler.embed)
	if unmarshaler.Type != "speech-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "speech-update", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageSpeechUpdate) MarshalJSON() ([]byte, error) {
	type embed ClientMessageSpeechUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "speech-update",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageSpeechUpdate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role which the speech update is for.
type ClientMessageSpeechUpdateRole string

const (
	ClientMessageSpeechUpdateRoleAssistant ClientMessageSpeechUpdateRole = "assistant"
	ClientMessageSpeechUpdateRoleUser      ClientMessageSpeechUpdateRole = "user"
)

func NewClientMessageSpeechUpdateRoleFromString(s string) (ClientMessageSpeechUpdateRole, error) {
	switch s {
	case "assistant":
		return ClientMessageSpeechUpdateRoleAssistant, nil
	case "user":
		return ClientMessageSpeechUpdateRoleUser, nil
	}
	var t ClientMessageSpeechUpdateRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageSpeechUpdateRole) Ptr() *ClientMessageSpeechUpdateRole {
	return &c
}

// This is the status of the speech update.
type ClientMessageSpeechUpdateStatus string

const (
	ClientMessageSpeechUpdateStatusStarted ClientMessageSpeechUpdateStatus = "started"
	ClientMessageSpeechUpdateStatusStopped ClientMessageSpeechUpdateStatus = "stopped"
)

func NewClientMessageSpeechUpdateStatusFromString(s string) (ClientMessageSpeechUpdateStatus, error) {
	switch s {
	case "started":
		return ClientMessageSpeechUpdateStatusStarted, nil
	case "stopped":
		return ClientMessageSpeechUpdateStatusStopped, nil
	}
	var t ClientMessageSpeechUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageSpeechUpdateStatus) Ptr() *ClientMessageSpeechUpdateStatus {
	return &c
}

type ClientMessageToolCalls struct {
	// This is the type of the message. "tool-calls" is sent to call a tool.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the list of tools calls that the model is requesting along with the original tool configuration.
	ToolWithToolCallList []*ClientMessageToolCallsToolWithToolCallListItem `json:"toolWithToolCallList,omitempty" url:"toolWithToolCallList,omitempty"`
	// This is the list of tool calls that the model is requesting.
	ToolCallList []*ToolCall `json:"toolCallList,omitempty" url:"toolCallList,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageToolCalls) GetToolWithToolCallList() []*ClientMessageToolCallsToolWithToolCallListItem {
	if c == nil {
		return nil
	}
	return c.ToolWithToolCallList
}

func (c *ClientMessageToolCalls) GetToolCallList() []*ToolCall {
	if c == nil {
		return nil
	}
	return c.ToolCallList
}

func (c *ClientMessageToolCalls) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientMessageToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientMessageToolCalls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageToolCalls) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageToolCallsResult struct {
	// This is the type of the message. "tool-calls-result" is sent to forward the result of a tool call to the client.
	// This is the result of the tool call.
	ToolCallResult map[string]interface{} `json:"toolCallResult,omitempty" url:"toolCallResult,omitempty"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageToolCallsResult) GetToolCallResult() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.ToolCallResult
}

func (c *ClientMessageToolCallsResult) Type() string {
	return c.type_
}

func (c *ClientMessageToolCallsResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageToolCallsResult) UnmarshalJSON(data []byte) error {
	type embed ClientMessageToolCallsResult
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageToolCallsResult(unmarshaler.embed)
	if unmarshaler.Type != "tool-calls-result" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool-calls-result", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageToolCallsResult) MarshalJSON() ([]byte, error) {
	type embed ClientMessageToolCallsResult
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "tool-calls-result",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageToolCallsResult) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageToolCallsToolWithToolCallListItem struct {
	FunctionToolWithToolCall *FunctionToolWithToolCall
	GhlToolWithToolCall      *GhlToolWithToolCall
	MakeToolWithToolCall     *MakeToolWithToolCall
	Unknown                  interface{}
	Unknown                  interface{}
	Unknown                  interface{}

	typ string
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetFunctionToolWithToolCall() *FunctionToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.FunctionToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetGhlToolWithToolCall() *GhlToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.GhlToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetMakeToolWithToolCall() *MakeToolWithToolCall {
	if c == nil {
		return nil
	}
	return c.MakeToolWithToolCall
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetUnknown() interface{} {
	if c == nil {
		return nil
	}
	return c.Unknown
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetUnknown() interface{} {
	if c == nil {
		return nil
	}
	return c.Unknown
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) GetUnknown() interface{} {
	if c == nil {
		return nil
	}
	return c.Unknown
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) UnmarshalJSON(data []byte) error {
	valueFunctionToolWithToolCall := new(FunctionToolWithToolCall)
	if err := json.Unmarshal(data, &valueFunctionToolWithToolCall); err == nil {
		c.typ = "FunctionToolWithToolCall"
		c.FunctionToolWithToolCall = valueFunctionToolWithToolCall
		return nil
	}
	valueGhlToolWithToolCall := new(GhlToolWithToolCall)
	if err := json.Unmarshal(data, &valueGhlToolWithToolCall); err == nil {
		c.typ = "GhlToolWithToolCall"
		c.GhlToolWithToolCall = valueGhlToolWithToolCall
		return nil
	}
	valueMakeToolWithToolCall := new(MakeToolWithToolCall)
	if err := json.Unmarshal(data, &valueMakeToolWithToolCall); err == nil {
		c.typ = "MakeToolWithToolCall"
		c.MakeToolWithToolCall = valueMakeToolWithToolCall
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typ = "Unknown"
		c.Unknown = valueUnknown
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typ = "Unknown"
		c.Unknown = valueUnknown
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typ = "Unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageToolCallsToolWithToolCallListItem) MarshalJSON() ([]byte, error) {
	if c.typ == "FunctionToolWithToolCall" || c.FunctionToolWithToolCall != nil {
		return json.Marshal(c.FunctionToolWithToolCall)
	}
	if c.typ == "GhlToolWithToolCall" || c.GhlToolWithToolCall != nil {
		return json.Marshal(c.GhlToolWithToolCall)
	}
	if c.typ == "MakeToolWithToolCall" || c.MakeToolWithToolCall != nil {
		return json.Marshal(c.MakeToolWithToolCall)
	}
	if c.typ == "Unknown" || c.Unknown != nil {
		return json.Marshal(c.Unknown)
	}
	if c.typ == "Unknown" || c.Unknown != nil {
		return json.Marshal(c.Unknown)
	}
	if c.typ == "Unknown" || c.Unknown != nil {
		return json.Marshal(c.Unknown)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageToolCallsToolWithToolCallListItemVisitor interface {
	VisitFunctionToolWithToolCall(*FunctionToolWithToolCall) error
	VisitGhlToolWithToolCall(*GhlToolWithToolCall) error
	VisitMakeToolWithToolCall(*MakeToolWithToolCall) error
	VisitUnknown(interface{}) error
	VisitUnknown(interface{}) error
	VisitUnknown(interface{}) error
}

func (c *ClientMessageToolCallsToolWithToolCallListItem) Accept(visitor ClientMessageToolCallsToolWithToolCallListItemVisitor) error {
	if c.typ == "FunctionToolWithToolCall" || c.FunctionToolWithToolCall != nil {
		return visitor.VisitFunctionToolWithToolCall(c.FunctionToolWithToolCall)
	}
	if c.typ == "GhlToolWithToolCall" || c.GhlToolWithToolCall != nil {
		return visitor.VisitGhlToolWithToolCall(c.GhlToolWithToolCall)
	}
	if c.typ == "MakeToolWithToolCall" || c.MakeToolWithToolCall != nil {
		return visitor.VisitMakeToolWithToolCall(c.MakeToolWithToolCall)
	}
	if c.typ == "Unknown" || c.Unknown != nil {
		return visitor.VisitUnknown(c.Unknown)
	}
	if c.typ == "Unknown" || c.Unknown != nil {
		return visitor.VisitUnknown(c.Unknown)
	}
	if c.typ == "Unknown" || c.Unknown != nil {
		return visitor.VisitUnknown(c.Unknown)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageTranscript struct {
	// This is the type of the message. "transcript" is sent as transcriber outputs partial or final transcript.
	// This is the role for which the transcript is for.
	Role ClientMessageTranscriptRole `json:"role" url:"role"`
	// This is the type of the transcript.
	TranscriptType ClientMessageTranscriptTranscriptType `json:"transcriptType" url:"transcriptType"`
	// This is the transcript content.
	Transcript string `json:"transcript" url:"transcript"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageTranscript) GetRole() ClientMessageTranscriptRole {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ClientMessageTranscript) GetTranscriptType() ClientMessageTranscriptTranscriptType {
	if c == nil {
		return ""
	}
	return c.TranscriptType
}

func (c *ClientMessageTranscript) GetTranscript() string {
	if c == nil {
		return ""
	}
	return c.Transcript
}

func (c *ClientMessageTranscript) Type() string {
	return c.type_
}

func (c *ClientMessageTranscript) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageTranscript) UnmarshalJSON(data []byte) error {
	type embed ClientMessageTranscript
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageTranscript(unmarshaler.embed)
	if unmarshaler.Type != "transcript" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transcript", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageTranscript) MarshalJSON() ([]byte, error) {
	type embed ClientMessageTranscript
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transcript",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageTranscript) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the role for which the transcript is for.
type ClientMessageTranscriptRole string

const (
	ClientMessageTranscriptRoleAssistant ClientMessageTranscriptRole = "assistant"
	ClientMessageTranscriptRoleUser      ClientMessageTranscriptRole = "user"
)

func NewClientMessageTranscriptRoleFromString(s string) (ClientMessageTranscriptRole, error) {
	switch s {
	case "assistant":
		return ClientMessageTranscriptRoleAssistant, nil
	case "user":
		return ClientMessageTranscriptRoleUser, nil
	}
	var t ClientMessageTranscriptRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageTranscriptRole) Ptr() *ClientMessageTranscriptRole {
	return &c
}

// This is the type of the transcript.
type ClientMessageTranscriptTranscriptType string

const (
	ClientMessageTranscriptTranscriptTypePartial ClientMessageTranscriptTranscriptType = "partial"
	ClientMessageTranscriptTranscriptTypeFinal   ClientMessageTranscriptTranscriptType = "final"
)

func NewClientMessageTranscriptTranscriptTypeFromString(s string) (ClientMessageTranscriptTranscriptType, error) {
	switch s {
	case "partial":
		return ClientMessageTranscriptTranscriptTypePartial, nil
	case "final":
		return ClientMessageTranscriptTranscriptTypeFinal, nil
	}
	var t ClientMessageTranscriptTranscriptType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientMessageTranscriptTranscriptType) Ptr() *ClientMessageTranscriptTranscriptType {
	return &c
}

type ClientMessageTransferUpdate struct {
	// This is the type of the message. "transfer-update" is sent whenever a transfer happens.
	// This is the destination of the transfer.
	Destination *ClientMessageTransferUpdateDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the assistant that the call is being transferred to. This is only sent if `destination.type` is "assistant".
	ToAssistant *CreateAssistantDto `json:"toAssistant,omitempty" url:"toAssistant,omitempty"`
	// This is the assistant that the call is being transferred from. This is only sent if `destination.type` is "assistant".
	FromAssistant *CreateAssistantDto `json:"fromAssistant,omitempty" url:"fromAssistant,omitempty"`
	// This is the step that the conversation moved to.
	ToStepRecord map[string]interface{} `json:"toStepRecord,omitempty" url:"toStepRecord,omitempty"`
	// This is the step that the conversation moved from. =
	FromStepRecord map[string]interface{} `json:"fromStepRecord,omitempty" url:"fromStepRecord,omitempty"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageTransferUpdate) GetDestination() *ClientMessageTransferUpdateDestination {
	if c == nil {
		return nil
	}
	return c.Destination
}

func (c *ClientMessageTransferUpdate) GetToAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.ToAssistant
}

func (c *ClientMessageTransferUpdate) GetFromAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.FromAssistant
}

func (c *ClientMessageTransferUpdate) GetToStepRecord() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.ToStepRecord
}

func (c *ClientMessageTransferUpdate) GetFromStepRecord() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.FromStepRecord
}

func (c *ClientMessageTransferUpdate) Type() string {
	return c.type_
}

func (c *ClientMessageTransferUpdate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageTransferUpdate) UnmarshalJSON(data []byte) error {
	type embed ClientMessageTransferUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageTransferUpdate(unmarshaler.embed)
	if unmarshaler.Type != "transfer-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transfer-update", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageTransferUpdate) MarshalJSON() ([]byte, error) {
	type embed ClientMessageTransferUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transfer-update",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageTransferUpdate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the destination of the transfer.
type ClientMessageTransferUpdateDestination struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationStep      *TransferDestinationStep
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (c *ClientMessageTransferUpdateDestination) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if c == nil {
		return nil
	}
	return c.TransferDestinationAssistant
}

func (c *ClientMessageTransferUpdateDestination) GetTransferDestinationStep() *TransferDestinationStep {
	if c == nil {
		return nil
	}
	return c.TransferDestinationStep
}

func (c *ClientMessageTransferUpdateDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if c == nil {
		return nil
	}
	return c.TransferDestinationNumber
}

func (c *ClientMessageTransferUpdateDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if c == nil {
		return nil
	}
	return c.TransferDestinationSip
}

func (c *ClientMessageTransferUpdateDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		c.typ = "TransferDestinationAssistant"
		c.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationStep := new(TransferDestinationStep)
	if err := json.Unmarshal(data, &valueTransferDestinationStep); err == nil {
		c.typ = "TransferDestinationStep"
		c.TransferDestinationStep = valueTransferDestinationStep
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.typ = "TransferDestinationNumber"
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.typ = "TransferDestinationSip"
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientMessageTransferUpdateDestination) MarshalJSON() ([]byte, error) {
	if c.typ == "TransferDestinationAssistant" || c.TransferDestinationAssistant != nil {
		return json.Marshal(c.TransferDestinationAssistant)
	}
	if c.typ == "TransferDestinationStep" || c.TransferDestinationStep != nil {
		return json.Marshal(c.TransferDestinationStep)
	}
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageTransferUpdateDestinationVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationStep(*TransferDestinationStep) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *ClientMessageTransferUpdateDestination) Accept(visitor ClientMessageTransferUpdateDestinationVisitor) error {
	if c.typ == "TransferDestinationAssistant" || c.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(c.TransferDestinationAssistant)
	}
	if c.typ == "TransferDestinationStep" || c.TransferDestinationStep != nil {
		return visitor.VisitTransferDestinationStep(c.TransferDestinationStep)
	}
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientMessageUserInterrupted struct {
	// This is the type of the message. "user-interrupted" is sent when the user interrupts the assistant.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageUserInterrupted) Type() string {
	return c.type_
}

func (c *ClientMessageUserInterrupted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageUserInterrupted) UnmarshalJSON(data []byte) error {
	type embed ClientMessageUserInterrupted
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageUserInterrupted(unmarshaler.embed)
	if unmarshaler.Type != "user-interrupted" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "user-interrupted", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageUserInterrupted) MarshalJSON() ([]byte, error) {
	type embed ClientMessageUserInterrupted
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "user-interrupted",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageUserInterrupted) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientMessageVoiceInput struct {
	// This is the type of the message. "voice-input" is sent when a generation is requested from voice provider.
	// This is the voice input content
	Input string `json:"input" url:"input"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientMessageVoiceInput) GetInput() string {
	if c == nil {
		return ""
	}
	return c.Input
}

func (c *ClientMessageVoiceInput) Type() string {
	return c.type_
}

func (c *ClientMessageVoiceInput) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientMessageVoiceInput) UnmarshalJSON(data []byte) error {
	type embed ClientMessageVoiceInput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientMessageVoiceInput(unmarshaler.embed)
	if unmarshaler.Type != "voice-input" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "voice-input", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientMessageVoiceInput) MarshalJSON() ([]byte, error) {
	type embed ClientMessageVoiceInput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "voice-input",
	}
	return json.Marshal(marshaler)
}

func (c *ClientMessageVoiceInput) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CloneVoiceDto struct {
	// This is the name of the cloned voice in the provider account.
	Name string `json:"name" url:"name"`
	// This is the description of your cloned voice.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Serialized labels dictionary for the voice.
	Labels *string `json:"labels,omitempty" url:"labels,omitempty"`
	// These are the files you want to use to clone your voice. Only Audio files are supported.
	Files []string `json:"files,omitempty" url:"files,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CloneVoiceDto) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CloneVoiceDto) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CloneVoiceDto) GetLabels() *string {
	if c == nil {
		return nil
	}
	return c.Labels
}

func (c *CloneVoiceDto) GetFiles() []string {
	if c == nil {
		return nil
	}
	return c.Files
}

func (c *CloneVoiceDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloneVoiceDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CloneVoiceDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloneVoiceDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloneVoiceDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CloudflareCredential struct {
	// Credential provider. Only allowed value is cloudflare
	// Cloudflare Account Id.
	AccountId *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Cloudflare API Key / Token.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// Cloudflare Account Email.
	AccountEmail *string `json:"accountEmail,omitempty" url:"accountEmail,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in R2
	BucketPlan *CloudflareR2BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CloudflareCredential) GetAccountId() *string {
	if c == nil {
		return nil
	}
	return c.AccountId
}

func (c *CloudflareCredential) GetApiKey() *string {
	if c == nil {
		return nil
	}
	return c.ApiKey
}

func (c *CloudflareCredential) GetAccountEmail() *string {
	if c == nil {
		return nil
	}
	return c.AccountEmail
}

func (c *CloudflareCredential) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CloudflareCredential) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CloudflareCredential) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CloudflareCredential) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CloudflareCredential) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CloudflareCredential) GetBucketPlan() *CloudflareR2BucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CloudflareCredential) Provider() string {
	return c.provider
}

func (c *CloudflareCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloudflareCredential) UnmarshalJSON(data []byte) error {
	type embed CloudflareCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CloudflareCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "cloudflare" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cloudflare", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloudflareCredential) MarshalJSON() ([]byte, error) {
	type embed CloudflareCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Provider:  "cloudflare",
	}
	return json.Marshal(marshaler)
}

func (c *CloudflareCredential) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CloudflareR2BucketPlan struct {
	// Cloudflare R2 Access key ID.
	AccessKeyId *string `json:"accessKeyId,omitempty" url:"accessKeyId,omitempty"`
	// Cloudflare R2 access key secret. This is not returned in the API.
	SecretAccessKey *string `json:"secretAccessKey,omitempty" url:"secretAccessKey,omitempty"`
	// Cloudflare R2 base url.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// This is the name of the bucket.
	Name string `json:"name" url:"name"`
	// This is the path where call artifacts will be stored.
	//
	// Usage:
	// - To store call artifacts in a specific folder, set this to the full path. Eg. "/folder-name1/folder-name2".
	// - To store call artifacts in the root of the bucket, leave this blank.
	//
	// @default "/"
	Path *string `json:"path,omitempty" url:"path,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CloudflareR2BucketPlan) GetAccessKeyId() *string {
	if c == nil {
		return nil
	}
	return c.AccessKeyId
}

func (c *CloudflareR2BucketPlan) GetSecretAccessKey() *string {
	if c == nil {
		return nil
	}
	return c.SecretAccessKey
}

func (c *CloudflareR2BucketPlan) GetUrl() *string {
	if c == nil {
		return nil
	}
	return c.Url
}

func (c *CloudflareR2BucketPlan) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CloudflareR2BucketPlan) GetPath() *string {
	if c == nil {
		return nil
	}
	return c.Path
}

func (c *CloudflareR2BucketPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloudflareR2BucketPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CloudflareR2BucketPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloudflareR2BucketPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloudflareR2BucketPlan) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Condition struct {
	// This is the operator you want to use to compare the parameter and value.
	Operator ConditionOperator `json:"operator" url:"operator"`
	// This is the name of the parameter that you want to check.
	Param string `json:"param" url:"param"`
	// This is the value you want to compare against the parameter.
	Value map[string]interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Condition) GetOperator() ConditionOperator {
	if c == nil {
		return ""
	}
	return c.Operator
}

func (c *Condition) GetParam() string {
	if c == nil {
		return ""
	}
	return c.Param
}

func (c *Condition) GetValue() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Value
}

func (c *Condition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Condition) UnmarshalJSON(data []byte) error {
	type unmarshaler Condition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Condition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Condition) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the operator you want to use to compare the parameter and value.
type ConditionOperator string

const (
	ConditionOperatorEq  ConditionOperator = "eq"
	ConditionOperatorNeq ConditionOperator = "neq"
	ConditionOperatorGt  ConditionOperator = "gt"
	ConditionOperatorGte ConditionOperator = "gte"
	ConditionOperatorLt  ConditionOperator = "lt"
	ConditionOperatorLte ConditionOperator = "lte"
)

func NewConditionOperatorFromString(s string) (ConditionOperator, error) {
	switch s {
	case "eq":
		return ConditionOperatorEq, nil
	case "neq":
		return ConditionOperatorNeq, nil
	case "gt":
		return ConditionOperatorGt, nil
	case "gte":
		return ConditionOperatorGte, nil
	case "lt":
		return ConditionOperatorLt, nil
	case "lte":
		return ConditionOperatorLte, nil
	}
	var t ConditionOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConditionOperator) Ptr() *ConditionOperator {
	return &c
}

type CreateAnthropicCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAnthropicCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateAnthropicCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAnthropicCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAnthropicCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAnthropicCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAnthropicCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAnthropicCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "anthropic" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "anthropic", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAnthropicCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAnthropicCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "anthropic",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAnthropicCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAnyscaleCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAnyscaleCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateAnyscaleCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAnyscaleCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAnyscaleCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAnyscaleCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAnyscaleCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAnyscaleCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "anyscale" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "anyscale", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAnyscaleCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAnyscaleCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "anyscale",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAnyscaleCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAssemblyAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAssemblyAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateAssemblyAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAssemblyAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAssemblyAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAssemblyAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAssemblyAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAssemblyAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "assembly-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "assembly-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAssemblyAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAssemblyAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "assembly-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAssemblyAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAssistantDto struct {
	// These are the options for the assistant's transcriber.
	Transcriber *CreateAssistantDtoTranscriber `json:"transcriber,omitempty" url:"transcriber,omitempty"`
	// These are the options for the assistant's LLM.
	Model *CreateAssistantDtoModel `json:"model,omitempty" url:"model,omitempty"`
	// These are the options for the assistant's voice.
	Voice *CreateAssistantDtoVoice `json:"voice,omitempty" url:"voice,omitempty"`
	// This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).
	//
	// If unspecified, assistant will wait for user to speak and use the model to respond once they speak.
	FirstMessage *string `json:"firstMessage,omitempty" url:"firstMessage,omitempty"`
	// This is the mode for the first message. Default is 'assistant-speaks-first'.
	//
	// Use:
	// - 'assistant-speaks-first' to have the assistant speak first.
	// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
	// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
	//
	// @default 'assistant-speaks-first'
	FirstMessageMode *CreateAssistantDtoFirstMessageMode `json:"firstMessageMode,omitempty" url:"firstMessageMode,omitempty"`
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input. You can check the shape of the messages in ClientMessage schema.
	ClientMessages []CreateAssistantDtoClientMessagesItem `json:"clientMessages,omitempty" url:"clientMessages,omitempty"`
	// These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.
	ServerMessages []CreateAssistantDtoServerMessagesItem `json:"serverMessages,omitempty" url:"serverMessages,omitempty"`
	// How many seconds of silence to wait before ending the call. Defaults to 30.
	//
	// @default 30
	SilenceTimeoutSeconds *float64 `json:"silenceTimeoutSeconds,omitempty" url:"silenceTimeoutSeconds,omitempty"`
	// This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.
	//
	// @default 600 (10 minutes)
	MaxDurationSeconds *float64 `json:"maxDurationSeconds,omitempty" url:"maxDurationSeconds,omitempty"`
	// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
	BackgroundSound *CreateAssistantDtoBackgroundSound `json:"backgroundSound,omitempty" url:"backgroundSound,omitempty"`
	// This enables filtering of noise and background speech while the user is talking.
	//
	// Default `false` while in beta.
	//
	// @default false
	BackgroundDenoisingEnabled *bool `json:"backgroundDenoisingEnabled,omitempty" url:"backgroundDenoisingEnabled,omitempty"`
	// This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.
	//
	// Default `false` while in beta.
	//
	// @default false
	ModelOutputInMessagesEnabled *bool `json:"modelOutputInMessagesEnabled,omitempty" url:"modelOutputInMessagesEnabled,omitempty"`
	// These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.
	TransportConfigurations []*TransportConfigurationTwilio `json:"transportConfigurations,omitempty" url:"transportConfigurations,omitempty"`
	// These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.
	Credentials []*CreateAssistantDtoCredentialsItem `json:"credentials,omitempty" url:"credentials,omitempty"`
	// This is the name of the assistant.
	//
	// This is required when you want to transfer between assistants in a call.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].
	// This uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.
	// You can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.
	VoicemailDetection *TwilioVoicemailDetection `json:"voicemailDetection,omitempty" url:"voicemailDetection,omitempty"`
	// This is the message that the assistant will say if the call is forwarded to voicemail.
	//
	// If unspecified, it will hang up.
	VoicemailMessage *string `json:"voicemailMessage,omitempty" url:"voicemailMessage,omitempty"`
	// This is the message that the assistant will say if it ends the call.
	//
	// If unspecified, it will hang up without saying anything.
	EndCallMessage *string `json:"endCallMessage,omitempty" url:"endCallMessage,omitempty"`
	// This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.
	EndCallPhrases []string `json:"endCallPhrases,omitempty" url:"endCallPhrases,omitempty"`
	// This is for metadata you want to store on the assistant.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the plan for analysis of assistant's calls. Stored in `call.analysis`.
	AnalysisPlan *AnalysisPlan `json:"analysisPlan,omitempty" url:"analysisPlan,omitempty"`
	// This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.
	//
	// Note: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.
	ArtifactPlan *ArtifactPlan `json:"artifactPlan,omitempty" url:"artifactPlan,omitempty"`
	// This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.
	//
	// Note: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.
	MessagePlan *MessagePlan `json:"messagePlan,omitempty" url:"messagePlan,omitempty"`
	// This is the plan for when the assistant should start talking.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to start talking after the customer is done speaking.
	// - The assistant is too fast to start talking after the customer is done speaking.
	// - The assistant is so fast that it's actually interrupting the customer.
	StartSpeakingPlan *StartSpeakingPlan `json:"startSpeakingPlan,omitempty" url:"startSpeakingPlan,omitempty"`
	// This is the plan for when assistant should stop talking on customer interruption.
	//
	// You should configure this if you're running into these issues:
	// - The assistant is too slow to recognize customer's interruption.
	// - The assistant is too fast to recognize customer's interruption.
	// - The assistant is getting interrupted by phrases that are just acknowledgments.
	// - The assistant is getting interrupted by background noises.
	// - The assistant is not properly stopping -- it starts talking right after getting interrupted.
	StopSpeakingPlan *StopSpeakingPlan `json:"stopSpeakingPlan,omitempty" url:"stopSpeakingPlan,omitempty"`
	// This is the plan for real-time monitoring of the assistant's calls.
	//
	// Usage:
	// - To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.
	// - To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.
	//
	// Note, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible
	MonitorPlan *MonitorPlan `json:"monitorPlan,omitempty" url:"monitorPlan,omitempty"`
	// These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.
	CredentialIds []string `json:"credentialIds,omitempty" url:"credentialIds,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server.url
	// 2. phoneNumber.serverUrl
	// 3. org.serverUrl
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAssistantDto) GetTranscriber() *CreateAssistantDtoTranscriber {
	if c == nil {
		return nil
	}
	return c.Transcriber
}

func (c *CreateAssistantDto) GetModel() *CreateAssistantDtoModel {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *CreateAssistantDto) GetVoice() *CreateAssistantDtoVoice {
	if c == nil {
		return nil
	}
	return c.Voice
}

func (c *CreateAssistantDto) GetFirstMessage() *string {
	if c == nil {
		return nil
	}
	return c.FirstMessage
}

func (c *CreateAssistantDto) GetFirstMessageMode() *CreateAssistantDtoFirstMessageMode {
	if c == nil {
		return nil
	}
	return c.FirstMessageMode
}

func (c *CreateAssistantDto) GetHipaaEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.HipaaEnabled
}

func (c *CreateAssistantDto) GetClientMessages() []CreateAssistantDtoClientMessagesItem {
	if c == nil {
		return nil
	}
	return c.ClientMessages
}

func (c *CreateAssistantDto) GetServerMessages() []CreateAssistantDtoServerMessagesItem {
	if c == nil {
		return nil
	}
	return c.ServerMessages
}

func (c *CreateAssistantDto) GetSilenceTimeoutSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.SilenceTimeoutSeconds
}

func (c *CreateAssistantDto) GetMaxDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxDurationSeconds
}

func (c *CreateAssistantDto) GetBackgroundSound() *CreateAssistantDtoBackgroundSound {
	if c == nil {
		return nil
	}
	return c.BackgroundSound
}

func (c *CreateAssistantDto) GetBackgroundDenoisingEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.BackgroundDenoisingEnabled
}

func (c *CreateAssistantDto) GetModelOutputInMessagesEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.ModelOutputInMessagesEnabled
}

func (c *CreateAssistantDto) GetTransportConfigurations() []*TransportConfigurationTwilio {
	if c == nil {
		return nil
	}
	return c.TransportConfigurations
}

func (c *CreateAssistantDto) GetCredentials() []*CreateAssistantDtoCredentialsItem {
	if c == nil {
		return nil
	}
	return c.Credentials
}

func (c *CreateAssistantDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAssistantDto) GetVoicemailDetection() *TwilioVoicemailDetection {
	if c == nil {
		return nil
	}
	return c.VoicemailDetection
}

func (c *CreateAssistantDto) GetVoicemailMessage() *string {
	if c == nil {
		return nil
	}
	return c.VoicemailMessage
}

func (c *CreateAssistantDto) GetEndCallMessage() *string {
	if c == nil {
		return nil
	}
	return c.EndCallMessage
}

func (c *CreateAssistantDto) GetEndCallPhrases() []string {
	if c == nil {
		return nil
	}
	return c.EndCallPhrases
}

func (c *CreateAssistantDto) GetMetadata() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateAssistantDto) GetAnalysisPlan() *AnalysisPlan {
	if c == nil {
		return nil
	}
	return c.AnalysisPlan
}

func (c *CreateAssistantDto) GetArtifactPlan() *ArtifactPlan {
	if c == nil {
		return nil
	}
	return c.ArtifactPlan
}

func (c *CreateAssistantDto) GetMessagePlan() *MessagePlan {
	if c == nil {
		return nil
	}
	return c.MessagePlan
}

func (c *CreateAssistantDto) GetStartSpeakingPlan() *StartSpeakingPlan {
	if c == nil {
		return nil
	}
	return c.StartSpeakingPlan
}

func (c *CreateAssistantDto) GetStopSpeakingPlan() *StopSpeakingPlan {
	if c == nil {
		return nil
	}
	return c.StopSpeakingPlan
}

func (c *CreateAssistantDto) GetMonitorPlan() *MonitorPlan {
	if c == nil {
		return nil
	}
	return c.MonitorPlan
}

func (c *CreateAssistantDto) GetCredentialIds() []string {
	if c == nil {
		return nil
	}
	return c.CredentialIds
}

func (c *CreateAssistantDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateAssistantDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAssistantDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAssistantDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAssistantDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAssistantDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.
type CreateAssistantDtoBackgroundSound string

const (
	CreateAssistantDtoBackgroundSoundOff    CreateAssistantDtoBackgroundSound = "off"
	CreateAssistantDtoBackgroundSoundOffice CreateAssistantDtoBackgroundSound = "office"
)

func NewCreateAssistantDtoBackgroundSoundFromString(s string) (CreateAssistantDtoBackgroundSound, error) {
	switch s {
	case "off":
		return CreateAssistantDtoBackgroundSoundOff, nil
	case "office":
		return CreateAssistantDtoBackgroundSoundOffice, nil
	}
	var t CreateAssistantDtoBackgroundSound
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoBackgroundSound) Ptr() *CreateAssistantDtoBackgroundSound {
	return &c
}

type CreateAssistantDtoClientMessagesItem string

const (
	CreateAssistantDtoClientMessagesItemConversationUpdate CreateAssistantDtoClientMessagesItem = "conversation-update"
	CreateAssistantDtoClientMessagesItemFunctionCall       CreateAssistantDtoClientMessagesItem = "function-call"
	CreateAssistantDtoClientMessagesItemFunctionCallResult CreateAssistantDtoClientMessagesItem = "function-call-result"
	CreateAssistantDtoClientMessagesItemHang               CreateAssistantDtoClientMessagesItem = "hang"
	CreateAssistantDtoClientMessagesItemLanguageChanged    CreateAssistantDtoClientMessagesItem = "language-changed"
	CreateAssistantDtoClientMessagesItemMetadata           CreateAssistantDtoClientMessagesItem = "metadata"
	CreateAssistantDtoClientMessagesItemModelOutput        CreateAssistantDtoClientMessagesItem = "model-output"
	CreateAssistantDtoClientMessagesItemSpeechUpdate       CreateAssistantDtoClientMessagesItem = "speech-update"
	CreateAssistantDtoClientMessagesItemStatusUpdate       CreateAssistantDtoClientMessagesItem = "status-update"
	CreateAssistantDtoClientMessagesItemTranscript         CreateAssistantDtoClientMessagesItem = "transcript"
	CreateAssistantDtoClientMessagesItemToolCalls          CreateAssistantDtoClientMessagesItem = "tool-calls"
	CreateAssistantDtoClientMessagesItemToolCallsResult    CreateAssistantDtoClientMessagesItem = "tool-calls-result"
	CreateAssistantDtoClientMessagesItemTransferUpdate     CreateAssistantDtoClientMessagesItem = "transfer-update"
	CreateAssistantDtoClientMessagesItemUserInterrupted    CreateAssistantDtoClientMessagesItem = "user-interrupted"
	CreateAssistantDtoClientMessagesItemVoiceInput         CreateAssistantDtoClientMessagesItem = "voice-input"
)

func NewCreateAssistantDtoClientMessagesItemFromString(s string) (CreateAssistantDtoClientMessagesItem, error) {
	switch s {
	case "conversation-update":
		return CreateAssistantDtoClientMessagesItemConversationUpdate, nil
	case "function-call":
		return CreateAssistantDtoClientMessagesItemFunctionCall, nil
	case "function-call-result":
		return CreateAssistantDtoClientMessagesItemFunctionCallResult, nil
	case "hang":
		return CreateAssistantDtoClientMessagesItemHang, nil
	case "language-changed":
		return CreateAssistantDtoClientMessagesItemLanguageChanged, nil
	case "metadata":
		return CreateAssistantDtoClientMessagesItemMetadata, nil
	case "model-output":
		return CreateAssistantDtoClientMessagesItemModelOutput, nil
	case "speech-update":
		return CreateAssistantDtoClientMessagesItemSpeechUpdate, nil
	case "status-update":
		return CreateAssistantDtoClientMessagesItemStatusUpdate, nil
	case "transcript":
		return CreateAssistantDtoClientMessagesItemTranscript, nil
	case "tool-calls":
		return CreateAssistantDtoClientMessagesItemToolCalls, nil
	case "tool-calls-result":
		return CreateAssistantDtoClientMessagesItemToolCallsResult, nil
	case "transfer-update":
		return CreateAssistantDtoClientMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return CreateAssistantDtoClientMessagesItemUserInterrupted, nil
	case "voice-input":
		return CreateAssistantDtoClientMessagesItemVoiceInput, nil
	}
	var t CreateAssistantDtoClientMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoClientMessagesItem) Ptr() *CreateAssistantDtoClientMessagesItem {
	return &c
}

type CreateAssistantDtoCredentialsItem struct {
	CreateAnthropicCredentialDto    *CreateAnthropicCredentialDto
	CreateAnyscaleCredentialDto     *CreateAnyscaleCredentialDto
	CreateAssemblyAiCredentialDto   *CreateAssemblyAiCredentialDto
	CreateAzureOpenAiCredentialDto  *CreateAzureOpenAiCredentialDto
	CreateAzureCredentialDto        *CreateAzureCredentialDto
	CreateByoSipTrunkCredentialDto  *CreateByoSipTrunkCredentialDto
	CreateCartesiaCredentialDto     *CreateCartesiaCredentialDto
	CreateCloudflareCredentialDto   *CreateCloudflareCredentialDto
	CreateCustomLlmCredentialDto    *CreateCustomLlmCredentialDto
	CreateDeepgramCredentialDto     *CreateDeepgramCredentialDto
	CreateDeepInfraCredentialDto    *CreateDeepInfraCredentialDto
	CreateDeepSeekCredentialDto     *CreateDeepSeekCredentialDto
	CreateElevenLabsCredentialDto   *CreateElevenLabsCredentialDto
	CreateGcpCredentialDto          *CreateGcpCredentialDto
	CreateGladiaCredentialDto       *CreateGladiaCredentialDto
	CreateGoHighLevelCredentialDto  *CreateGoHighLevelCredentialDto
	CreateGroqCredentialDto         *CreateGroqCredentialDto
	CreateLangfuseCredentialDto     *CreateLangfuseCredentialDto
	CreateLmntCredentialDto         *CreateLmntCredentialDto
	CreateMakeCredentialDto         *CreateMakeCredentialDto
	CreateOpenAiCredentialDto       *CreateOpenAiCredentialDto
	CreateOpenRouterCredentialDto   *CreateOpenRouterCredentialDto
	CreatePerplexityAiCredentialDto *CreatePerplexityAiCredentialDto
	CreatePlayHtCredentialDto       *CreatePlayHtCredentialDto
	CreateRimeAiCredentialDto       *CreateRimeAiCredentialDto
	CreateRunpodCredentialDto       *CreateRunpodCredentialDto
	CreateS3CredentialDto           *CreateS3CredentialDto
	CreateSmallestAiCredentialDto   *CreateSmallestAiCredentialDto
	CreateTavusCredentialDto        *CreateTavusCredentialDto
	CreateTogetherAiCredentialDto   *CreateTogetherAiCredentialDto
	CreateTwilioCredentialDto       *CreateTwilioCredentialDto
	CreateVonageCredentialDto       *CreateVonageCredentialDto
	CreateWebhookCredentialDto      *CreateWebhookCredentialDto
	CreateXAiCredentialDto          *CreateXAiCredentialDto

	typ string
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAnthropicCredentialDto() *CreateAnthropicCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAnthropicCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAnyscaleCredentialDto() *CreateAnyscaleCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAnyscaleCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAssemblyAiCredentialDto() *CreateAssemblyAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAssemblyAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAzureOpenAiCredentialDto() *CreateAzureOpenAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAzureOpenAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateAzureCredentialDto() *CreateAzureCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateAzureCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateByoSipTrunkCredentialDto() *CreateByoSipTrunkCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateByoSipTrunkCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateCartesiaCredentialDto() *CreateCartesiaCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateCartesiaCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateCloudflareCredentialDto() *CreateCloudflareCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateCloudflareCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateCustomLlmCredentialDto() *CreateCustomLlmCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateCustomLlmCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateDeepgramCredentialDto() *CreateDeepgramCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateDeepgramCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateDeepInfraCredentialDto() *CreateDeepInfraCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateDeepInfraCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateDeepSeekCredentialDto() *CreateDeepSeekCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateDeepSeekCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateElevenLabsCredentialDto() *CreateElevenLabsCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateElevenLabsCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGcpCredentialDto() *CreateGcpCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGcpCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGladiaCredentialDto() *CreateGladiaCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGladiaCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGoHighLevelCredentialDto() *CreateGoHighLevelCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGoHighLevelCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateGroqCredentialDto() *CreateGroqCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateGroqCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateLangfuseCredentialDto() *CreateLangfuseCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateLangfuseCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateLmntCredentialDto() *CreateLmntCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateLmntCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateMakeCredentialDto() *CreateMakeCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateMakeCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateOpenAiCredentialDto() *CreateOpenAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateOpenAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateOpenRouterCredentialDto() *CreateOpenRouterCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateOpenRouterCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreatePerplexityAiCredentialDto() *CreatePerplexityAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreatePerplexityAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreatePlayHtCredentialDto() *CreatePlayHtCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreatePlayHtCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateRimeAiCredentialDto() *CreateRimeAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateRimeAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateRunpodCredentialDto() *CreateRunpodCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateRunpodCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateS3CredentialDto() *CreateS3CredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateS3CredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateSmallestAiCredentialDto() *CreateSmallestAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateSmallestAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateTavusCredentialDto() *CreateTavusCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateTavusCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateTogetherAiCredentialDto() *CreateTogetherAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateTogetherAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateTwilioCredentialDto() *CreateTwilioCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateTwilioCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateVonageCredentialDto() *CreateVonageCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateVonageCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateWebhookCredentialDto() *CreateWebhookCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateWebhookCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) GetCreateXAiCredentialDto() *CreateXAiCredentialDto {
	if c == nil {
		return nil
	}
	return c.CreateXAiCredentialDto
}

func (c *CreateAssistantDtoCredentialsItem) UnmarshalJSON(data []byte) error {
	valueCreateAnthropicCredentialDto := new(CreateAnthropicCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAnthropicCredentialDto); err == nil {
		c.typ = "CreateAnthropicCredentialDto"
		c.CreateAnthropicCredentialDto = valueCreateAnthropicCredentialDto
		return nil
	}
	valueCreateAnyscaleCredentialDto := new(CreateAnyscaleCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAnyscaleCredentialDto); err == nil {
		c.typ = "CreateAnyscaleCredentialDto"
		c.CreateAnyscaleCredentialDto = valueCreateAnyscaleCredentialDto
		return nil
	}
	valueCreateAssemblyAiCredentialDto := new(CreateAssemblyAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAssemblyAiCredentialDto); err == nil {
		c.typ = "CreateAssemblyAiCredentialDto"
		c.CreateAssemblyAiCredentialDto = valueCreateAssemblyAiCredentialDto
		return nil
	}
	valueCreateAzureOpenAiCredentialDto := new(CreateAzureOpenAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAzureOpenAiCredentialDto); err == nil {
		c.typ = "CreateAzureOpenAiCredentialDto"
		c.CreateAzureOpenAiCredentialDto = valueCreateAzureOpenAiCredentialDto
		return nil
	}
	valueCreateAzureCredentialDto := new(CreateAzureCredentialDto)
	if err := json.Unmarshal(data, &valueCreateAzureCredentialDto); err == nil {
		c.typ = "CreateAzureCredentialDto"
		c.CreateAzureCredentialDto = valueCreateAzureCredentialDto
		return nil
	}
	valueCreateByoSipTrunkCredentialDto := new(CreateByoSipTrunkCredentialDto)
	if err := json.Unmarshal(data, &valueCreateByoSipTrunkCredentialDto); err == nil {
		c.typ = "CreateByoSipTrunkCredentialDto"
		c.CreateByoSipTrunkCredentialDto = valueCreateByoSipTrunkCredentialDto
		return nil
	}
	valueCreateCartesiaCredentialDto := new(CreateCartesiaCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCartesiaCredentialDto); err == nil {
		c.typ = "CreateCartesiaCredentialDto"
		c.CreateCartesiaCredentialDto = valueCreateCartesiaCredentialDto
		return nil
	}
	valueCreateCloudflareCredentialDto := new(CreateCloudflareCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCloudflareCredentialDto); err == nil {
		c.typ = "CreateCloudflareCredentialDto"
		c.CreateCloudflareCredentialDto = valueCreateCloudflareCredentialDto
		return nil
	}
	valueCreateCustomLlmCredentialDto := new(CreateCustomLlmCredentialDto)
	if err := json.Unmarshal(data, &valueCreateCustomLlmCredentialDto); err == nil {
		c.typ = "CreateCustomLlmCredentialDto"
		c.CreateCustomLlmCredentialDto = valueCreateCustomLlmCredentialDto
		return nil
	}
	valueCreateDeepgramCredentialDto := new(CreateDeepgramCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepgramCredentialDto); err == nil {
		c.typ = "CreateDeepgramCredentialDto"
		c.CreateDeepgramCredentialDto = valueCreateDeepgramCredentialDto
		return nil
	}
	valueCreateDeepInfraCredentialDto := new(CreateDeepInfraCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepInfraCredentialDto); err == nil {
		c.typ = "CreateDeepInfraCredentialDto"
		c.CreateDeepInfraCredentialDto = valueCreateDeepInfraCredentialDto
		return nil
	}
	valueCreateDeepSeekCredentialDto := new(CreateDeepSeekCredentialDto)
	if err := json.Unmarshal(data, &valueCreateDeepSeekCredentialDto); err == nil {
		c.typ = "CreateDeepSeekCredentialDto"
		c.CreateDeepSeekCredentialDto = valueCreateDeepSeekCredentialDto
		return nil
	}
	valueCreateElevenLabsCredentialDto := new(CreateElevenLabsCredentialDto)
	if err := json.Unmarshal(data, &valueCreateElevenLabsCredentialDto); err == nil {
		c.typ = "CreateElevenLabsCredentialDto"
		c.CreateElevenLabsCredentialDto = valueCreateElevenLabsCredentialDto
		return nil
	}
	valueCreateGcpCredentialDto := new(CreateGcpCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGcpCredentialDto); err == nil {
		c.typ = "CreateGcpCredentialDto"
		c.CreateGcpCredentialDto = valueCreateGcpCredentialDto
		return nil
	}
	valueCreateGladiaCredentialDto := new(CreateGladiaCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGladiaCredentialDto); err == nil {
		c.typ = "CreateGladiaCredentialDto"
		c.CreateGladiaCredentialDto = valueCreateGladiaCredentialDto
		return nil
	}
	valueCreateGoHighLevelCredentialDto := new(CreateGoHighLevelCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGoHighLevelCredentialDto); err == nil {
		c.typ = "CreateGoHighLevelCredentialDto"
		c.CreateGoHighLevelCredentialDto = valueCreateGoHighLevelCredentialDto
		return nil
	}
	valueCreateGroqCredentialDto := new(CreateGroqCredentialDto)
	if err := json.Unmarshal(data, &valueCreateGroqCredentialDto); err == nil {
		c.typ = "CreateGroqCredentialDto"
		c.CreateGroqCredentialDto = valueCreateGroqCredentialDto
		return nil
	}
	valueCreateLangfuseCredentialDto := new(CreateLangfuseCredentialDto)
	if err := json.Unmarshal(data, &valueCreateLangfuseCredentialDto); err == nil {
		c.typ = "CreateLangfuseCredentialDto"
		c.CreateLangfuseCredentialDto = valueCreateLangfuseCredentialDto
		return nil
	}
	valueCreateLmntCredentialDto := new(CreateLmntCredentialDto)
	if err := json.Unmarshal(data, &valueCreateLmntCredentialDto); err == nil {
		c.typ = "CreateLmntCredentialDto"
		c.CreateLmntCredentialDto = valueCreateLmntCredentialDto
		return nil
	}
	valueCreateMakeCredentialDto := new(CreateMakeCredentialDto)
	if err := json.Unmarshal(data, &valueCreateMakeCredentialDto); err == nil {
		c.typ = "CreateMakeCredentialDto"
		c.CreateMakeCredentialDto = valueCreateMakeCredentialDto
		return nil
	}
	valueCreateOpenAiCredentialDto := new(CreateOpenAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateOpenAiCredentialDto); err == nil {
		c.typ = "CreateOpenAiCredentialDto"
		c.CreateOpenAiCredentialDto = valueCreateOpenAiCredentialDto
		return nil
	}
	valueCreateOpenRouterCredentialDto := new(CreateOpenRouterCredentialDto)
	if err := json.Unmarshal(data, &valueCreateOpenRouterCredentialDto); err == nil {
		c.typ = "CreateOpenRouterCredentialDto"
		c.CreateOpenRouterCredentialDto = valueCreateOpenRouterCredentialDto
		return nil
	}
	valueCreatePerplexityAiCredentialDto := new(CreatePerplexityAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreatePerplexityAiCredentialDto); err == nil {
		c.typ = "CreatePerplexityAiCredentialDto"
		c.CreatePerplexityAiCredentialDto = valueCreatePerplexityAiCredentialDto
		return nil
	}
	valueCreatePlayHtCredentialDto := new(CreatePlayHtCredentialDto)
	if err := json.Unmarshal(data, &valueCreatePlayHtCredentialDto); err == nil {
		c.typ = "CreatePlayHtCredentialDto"
		c.CreatePlayHtCredentialDto = valueCreatePlayHtCredentialDto
		return nil
	}
	valueCreateRimeAiCredentialDto := new(CreateRimeAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateRimeAiCredentialDto); err == nil {
		c.typ = "CreateRimeAiCredentialDto"
		c.CreateRimeAiCredentialDto = valueCreateRimeAiCredentialDto
		return nil
	}
	valueCreateRunpodCredentialDto := new(CreateRunpodCredentialDto)
	if err := json.Unmarshal(data, &valueCreateRunpodCredentialDto); err == nil {
		c.typ = "CreateRunpodCredentialDto"
		c.CreateRunpodCredentialDto = valueCreateRunpodCredentialDto
		return nil
	}
	valueCreateS3CredentialDto := new(CreateS3CredentialDto)
	if err := json.Unmarshal(data, &valueCreateS3CredentialDto); err == nil {
		c.typ = "CreateS3CredentialDto"
		c.CreateS3CredentialDto = valueCreateS3CredentialDto
		return nil
	}
	valueCreateSmallestAiCredentialDto := new(CreateSmallestAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateSmallestAiCredentialDto); err == nil {
		c.typ = "CreateSmallestAiCredentialDto"
		c.CreateSmallestAiCredentialDto = valueCreateSmallestAiCredentialDto
		return nil
	}
	valueCreateTavusCredentialDto := new(CreateTavusCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTavusCredentialDto); err == nil {
		c.typ = "CreateTavusCredentialDto"
		c.CreateTavusCredentialDto = valueCreateTavusCredentialDto
		return nil
	}
	valueCreateTogetherAiCredentialDto := new(CreateTogetherAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTogetherAiCredentialDto); err == nil {
		c.typ = "CreateTogetherAiCredentialDto"
		c.CreateTogetherAiCredentialDto = valueCreateTogetherAiCredentialDto
		return nil
	}
	valueCreateTwilioCredentialDto := new(CreateTwilioCredentialDto)
	if err := json.Unmarshal(data, &valueCreateTwilioCredentialDto); err == nil {
		c.typ = "CreateTwilioCredentialDto"
		c.CreateTwilioCredentialDto = valueCreateTwilioCredentialDto
		return nil
	}
	valueCreateVonageCredentialDto := new(CreateVonageCredentialDto)
	if err := json.Unmarshal(data, &valueCreateVonageCredentialDto); err == nil {
		c.typ = "CreateVonageCredentialDto"
		c.CreateVonageCredentialDto = valueCreateVonageCredentialDto
		return nil
	}
	valueCreateWebhookCredentialDto := new(CreateWebhookCredentialDto)
	if err := json.Unmarshal(data, &valueCreateWebhookCredentialDto); err == nil {
		c.typ = "CreateWebhookCredentialDto"
		c.CreateWebhookCredentialDto = valueCreateWebhookCredentialDto
		return nil
	}
	valueCreateXAiCredentialDto := new(CreateXAiCredentialDto)
	if err := json.Unmarshal(data, &valueCreateXAiCredentialDto); err == nil {
		c.typ = "CreateXAiCredentialDto"
		c.CreateXAiCredentialDto = valueCreateXAiCredentialDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoCredentialsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateAnthropicCredentialDto" || c.CreateAnthropicCredentialDto != nil {
		return json.Marshal(c.CreateAnthropicCredentialDto)
	}
	if c.typ == "CreateAnyscaleCredentialDto" || c.CreateAnyscaleCredentialDto != nil {
		return json.Marshal(c.CreateAnyscaleCredentialDto)
	}
	if c.typ == "CreateAssemblyAiCredentialDto" || c.CreateAssemblyAiCredentialDto != nil {
		return json.Marshal(c.CreateAssemblyAiCredentialDto)
	}
	if c.typ == "CreateAzureOpenAiCredentialDto" || c.CreateAzureOpenAiCredentialDto != nil {
		return json.Marshal(c.CreateAzureOpenAiCredentialDto)
	}
	if c.typ == "CreateAzureCredentialDto" || c.CreateAzureCredentialDto != nil {
		return json.Marshal(c.CreateAzureCredentialDto)
	}
	if c.typ == "CreateByoSipTrunkCredentialDto" || c.CreateByoSipTrunkCredentialDto != nil {
		return json.Marshal(c.CreateByoSipTrunkCredentialDto)
	}
	if c.typ == "CreateCartesiaCredentialDto" || c.CreateCartesiaCredentialDto != nil {
		return json.Marshal(c.CreateCartesiaCredentialDto)
	}
	if c.typ == "CreateCloudflareCredentialDto" || c.CreateCloudflareCredentialDto != nil {
		return json.Marshal(c.CreateCloudflareCredentialDto)
	}
	if c.typ == "CreateCustomLlmCredentialDto" || c.CreateCustomLlmCredentialDto != nil {
		return json.Marshal(c.CreateCustomLlmCredentialDto)
	}
	if c.typ == "CreateDeepgramCredentialDto" || c.CreateDeepgramCredentialDto != nil {
		return json.Marshal(c.CreateDeepgramCredentialDto)
	}
	if c.typ == "CreateDeepInfraCredentialDto" || c.CreateDeepInfraCredentialDto != nil {
		return json.Marshal(c.CreateDeepInfraCredentialDto)
	}
	if c.typ == "CreateDeepSeekCredentialDto" || c.CreateDeepSeekCredentialDto != nil {
		return json.Marshal(c.CreateDeepSeekCredentialDto)
	}
	if c.typ == "CreateElevenLabsCredentialDto" || c.CreateElevenLabsCredentialDto != nil {
		return json.Marshal(c.CreateElevenLabsCredentialDto)
	}
	if c.typ == "CreateGcpCredentialDto" || c.CreateGcpCredentialDto != nil {
		return json.Marshal(c.CreateGcpCredentialDto)
	}
	if c.typ == "CreateGladiaCredentialDto" || c.CreateGladiaCredentialDto != nil {
		return json.Marshal(c.CreateGladiaCredentialDto)
	}
	if c.typ == "CreateGoHighLevelCredentialDto" || c.CreateGoHighLevelCredentialDto != nil {
		return json.Marshal(c.CreateGoHighLevelCredentialDto)
	}
	if c.typ == "CreateGroqCredentialDto" || c.CreateGroqCredentialDto != nil {
		return json.Marshal(c.CreateGroqCredentialDto)
	}
	if c.typ == "CreateLangfuseCredentialDto" || c.CreateLangfuseCredentialDto != nil {
		return json.Marshal(c.CreateLangfuseCredentialDto)
	}
	if c.typ == "CreateLmntCredentialDto" || c.CreateLmntCredentialDto != nil {
		return json.Marshal(c.CreateLmntCredentialDto)
	}
	if c.typ == "CreateMakeCredentialDto" || c.CreateMakeCredentialDto != nil {
		return json.Marshal(c.CreateMakeCredentialDto)
	}
	if c.typ == "CreateOpenAiCredentialDto" || c.CreateOpenAiCredentialDto != nil {
		return json.Marshal(c.CreateOpenAiCredentialDto)
	}
	if c.typ == "CreateOpenRouterCredentialDto" || c.CreateOpenRouterCredentialDto != nil {
		return json.Marshal(c.CreateOpenRouterCredentialDto)
	}
	if c.typ == "CreatePerplexityAiCredentialDto" || c.CreatePerplexityAiCredentialDto != nil {
		return json.Marshal(c.CreatePerplexityAiCredentialDto)
	}
	if c.typ == "CreatePlayHtCredentialDto" || c.CreatePlayHtCredentialDto != nil {
		return json.Marshal(c.CreatePlayHtCredentialDto)
	}
	if c.typ == "CreateRimeAiCredentialDto" || c.CreateRimeAiCredentialDto != nil {
		return json.Marshal(c.CreateRimeAiCredentialDto)
	}
	if c.typ == "CreateRunpodCredentialDto" || c.CreateRunpodCredentialDto != nil {
		return json.Marshal(c.CreateRunpodCredentialDto)
	}
	if c.typ == "CreateS3CredentialDto" || c.CreateS3CredentialDto != nil {
		return json.Marshal(c.CreateS3CredentialDto)
	}
	if c.typ == "CreateSmallestAiCredentialDto" || c.CreateSmallestAiCredentialDto != nil {
		return json.Marshal(c.CreateSmallestAiCredentialDto)
	}
	if c.typ == "CreateTavusCredentialDto" || c.CreateTavusCredentialDto != nil {
		return json.Marshal(c.CreateTavusCredentialDto)
	}
	if c.typ == "CreateTogetherAiCredentialDto" || c.CreateTogetherAiCredentialDto != nil {
		return json.Marshal(c.CreateTogetherAiCredentialDto)
	}
	if c.typ == "CreateTwilioCredentialDto" || c.CreateTwilioCredentialDto != nil {
		return json.Marshal(c.CreateTwilioCredentialDto)
	}
	if c.typ == "CreateVonageCredentialDto" || c.CreateVonageCredentialDto != nil {
		return json.Marshal(c.CreateVonageCredentialDto)
	}
	if c.typ == "CreateWebhookCredentialDto" || c.CreateWebhookCredentialDto != nil {
		return json.Marshal(c.CreateWebhookCredentialDto)
	}
	if c.typ == "CreateXAiCredentialDto" || c.CreateXAiCredentialDto != nil {
		return json.Marshal(c.CreateXAiCredentialDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoCredentialsItemVisitor interface {
	VisitCreateAnthropicCredentialDto(*CreateAnthropicCredentialDto) error
	VisitCreateAnyscaleCredentialDto(*CreateAnyscaleCredentialDto) error
	VisitCreateAssemblyAiCredentialDto(*CreateAssemblyAiCredentialDto) error
	VisitCreateAzureOpenAiCredentialDto(*CreateAzureOpenAiCredentialDto) error
	VisitCreateAzureCredentialDto(*CreateAzureCredentialDto) error
	VisitCreateByoSipTrunkCredentialDto(*CreateByoSipTrunkCredentialDto) error
	VisitCreateCartesiaCredentialDto(*CreateCartesiaCredentialDto) error
	VisitCreateCloudflareCredentialDto(*CreateCloudflareCredentialDto) error
	VisitCreateCustomLlmCredentialDto(*CreateCustomLlmCredentialDto) error
	VisitCreateDeepgramCredentialDto(*CreateDeepgramCredentialDto) error
	VisitCreateDeepInfraCredentialDto(*CreateDeepInfraCredentialDto) error
	VisitCreateDeepSeekCredentialDto(*CreateDeepSeekCredentialDto) error
	VisitCreateElevenLabsCredentialDto(*CreateElevenLabsCredentialDto) error
	VisitCreateGcpCredentialDto(*CreateGcpCredentialDto) error
	VisitCreateGladiaCredentialDto(*CreateGladiaCredentialDto) error
	VisitCreateGoHighLevelCredentialDto(*CreateGoHighLevelCredentialDto) error
	VisitCreateGroqCredentialDto(*CreateGroqCredentialDto) error
	VisitCreateLangfuseCredentialDto(*CreateLangfuseCredentialDto) error
	VisitCreateLmntCredentialDto(*CreateLmntCredentialDto) error
	VisitCreateMakeCredentialDto(*CreateMakeCredentialDto) error
	VisitCreateOpenAiCredentialDto(*CreateOpenAiCredentialDto) error
	VisitCreateOpenRouterCredentialDto(*CreateOpenRouterCredentialDto) error
	VisitCreatePerplexityAiCredentialDto(*CreatePerplexityAiCredentialDto) error
	VisitCreatePlayHtCredentialDto(*CreatePlayHtCredentialDto) error
	VisitCreateRimeAiCredentialDto(*CreateRimeAiCredentialDto) error
	VisitCreateRunpodCredentialDto(*CreateRunpodCredentialDto) error
	VisitCreateS3CredentialDto(*CreateS3CredentialDto) error
	VisitCreateSmallestAiCredentialDto(*CreateSmallestAiCredentialDto) error
	VisitCreateTavusCredentialDto(*CreateTavusCredentialDto) error
	VisitCreateTogetherAiCredentialDto(*CreateTogetherAiCredentialDto) error
	VisitCreateTwilioCredentialDto(*CreateTwilioCredentialDto) error
	VisitCreateVonageCredentialDto(*CreateVonageCredentialDto) error
	VisitCreateWebhookCredentialDto(*CreateWebhookCredentialDto) error
	VisitCreateXAiCredentialDto(*CreateXAiCredentialDto) error
}

func (c *CreateAssistantDtoCredentialsItem) Accept(visitor CreateAssistantDtoCredentialsItemVisitor) error {
	if c.typ == "CreateAnthropicCredentialDto" || c.CreateAnthropicCredentialDto != nil {
		return visitor.VisitCreateAnthropicCredentialDto(c.CreateAnthropicCredentialDto)
	}
	if c.typ == "CreateAnyscaleCredentialDto" || c.CreateAnyscaleCredentialDto != nil {
		return visitor.VisitCreateAnyscaleCredentialDto(c.CreateAnyscaleCredentialDto)
	}
	if c.typ == "CreateAssemblyAiCredentialDto" || c.CreateAssemblyAiCredentialDto != nil {
		return visitor.VisitCreateAssemblyAiCredentialDto(c.CreateAssemblyAiCredentialDto)
	}
	if c.typ == "CreateAzureOpenAiCredentialDto" || c.CreateAzureOpenAiCredentialDto != nil {
		return visitor.VisitCreateAzureOpenAiCredentialDto(c.CreateAzureOpenAiCredentialDto)
	}
	if c.typ == "CreateAzureCredentialDto" || c.CreateAzureCredentialDto != nil {
		return visitor.VisitCreateAzureCredentialDto(c.CreateAzureCredentialDto)
	}
	if c.typ == "CreateByoSipTrunkCredentialDto" || c.CreateByoSipTrunkCredentialDto != nil {
		return visitor.VisitCreateByoSipTrunkCredentialDto(c.CreateByoSipTrunkCredentialDto)
	}
	if c.typ == "CreateCartesiaCredentialDto" || c.CreateCartesiaCredentialDto != nil {
		return visitor.VisitCreateCartesiaCredentialDto(c.CreateCartesiaCredentialDto)
	}
	if c.typ == "CreateCloudflareCredentialDto" || c.CreateCloudflareCredentialDto != nil {
		return visitor.VisitCreateCloudflareCredentialDto(c.CreateCloudflareCredentialDto)
	}
	if c.typ == "CreateCustomLlmCredentialDto" || c.CreateCustomLlmCredentialDto != nil {
		return visitor.VisitCreateCustomLlmCredentialDto(c.CreateCustomLlmCredentialDto)
	}
	if c.typ == "CreateDeepgramCredentialDto" || c.CreateDeepgramCredentialDto != nil {
		return visitor.VisitCreateDeepgramCredentialDto(c.CreateDeepgramCredentialDto)
	}
	if c.typ == "CreateDeepInfraCredentialDto" || c.CreateDeepInfraCredentialDto != nil {
		return visitor.VisitCreateDeepInfraCredentialDto(c.CreateDeepInfraCredentialDto)
	}
	if c.typ == "CreateDeepSeekCredentialDto" || c.CreateDeepSeekCredentialDto != nil {
		return visitor.VisitCreateDeepSeekCredentialDto(c.CreateDeepSeekCredentialDto)
	}
	if c.typ == "CreateElevenLabsCredentialDto" || c.CreateElevenLabsCredentialDto != nil {
		return visitor.VisitCreateElevenLabsCredentialDto(c.CreateElevenLabsCredentialDto)
	}
	if c.typ == "CreateGcpCredentialDto" || c.CreateGcpCredentialDto != nil {
		return visitor.VisitCreateGcpCredentialDto(c.CreateGcpCredentialDto)
	}
	if c.typ == "CreateGladiaCredentialDto" || c.CreateGladiaCredentialDto != nil {
		return visitor.VisitCreateGladiaCredentialDto(c.CreateGladiaCredentialDto)
	}
	if c.typ == "CreateGoHighLevelCredentialDto" || c.CreateGoHighLevelCredentialDto != nil {
		return visitor.VisitCreateGoHighLevelCredentialDto(c.CreateGoHighLevelCredentialDto)
	}
	if c.typ == "CreateGroqCredentialDto" || c.CreateGroqCredentialDto != nil {
		return visitor.VisitCreateGroqCredentialDto(c.CreateGroqCredentialDto)
	}
	if c.typ == "CreateLangfuseCredentialDto" || c.CreateLangfuseCredentialDto != nil {
		return visitor.VisitCreateLangfuseCredentialDto(c.CreateLangfuseCredentialDto)
	}
	if c.typ == "CreateLmntCredentialDto" || c.CreateLmntCredentialDto != nil {
		return visitor.VisitCreateLmntCredentialDto(c.CreateLmntCredentialDto)
	}
	if c.typ == "CreateMakeCredentialDto" || c.CreateMakeCredentialDto != nil {
		return visitor.VisitCreateMakeCredentialDto(c.CreateMakeCredentialDto)
	}
	if c.typ == "CreateOpenAiCredentialDto" || c.CreateOpenAiCredentialDto != nil {
		return visitor.VisitCreateOpenAiCredentialDto(c.CreateOpenAiCredentialDto)
	}
	if c.typ == "CreateOpenRouterCredentialDto" || c.CreateOpenRouterCredentialDto != nil {
		return visitor.VisitCreateOpenRouterCredentialDto(c.CreateOpenRouterCredentialDto)
	}
	if c.typ == "CreatePerplexityAiCredentialDto" || c.CreatePerplexityAiCredentialDto != nil {
		return visitor.VisitCreatePerplexityAiCredentialDto(c.CreatePerplexityAiCredentialDto)
	}
	if c.typ == "CreatePlayHtCredentialDto" || c.CreatePlayHtCredentialDto != nil {
		return visitor.VisitCreatePlayHtCredentialDto(c.CreatePlayHtCredentialDto)
	}
	if c.typ == "CreateRimeAiCredentialDto" || c.CreateRimeAiCredentialDto != nil {
		return visitor.VisitCreateRimeAiCredentialDto(c.CreateRimeAiCredentialDto)
	}
	if c.typ == "CreateRunpodCredentialDto" || c.CreateRunpodCredentialDto != nil {
		return visitor.VisitCreateRunpodCredentialDto(c.CreateRunpodCredentialDto)
	}
	if c.typ == "CreateS3CredentialDto" || c.CreateS3CredentialDto != nil {
		return visitor.VisitCreateS3CredentialDto(c.CreateS3CredentialDto)
	}
	if c.typ == "CreateSmallestAiCredentialDto" || c.CreateSmallestAiCredentialDto != nil {
		return visitor.VisitCreateSmallestAiCredentialDto(c.CreateSmallestAiCredentialDto)
	}
	if c.typ == "CreateTavusCredentialDto" || c.CreateTavusCredentialDto != nil {
		return visitor.VisitCreateTavusCredentialDto(c.CreateTavusCredentialDto)
	}
	if c.typ == "CreateTogetherAiCredentialDto" || c.CreateTogetherAiCredentialDto != nil {
		return visitor.VisitCreateTogetherAiCredentialDto(c.CreateTogetherAiCredentialDto)
	}
	if c.typ == "CreateTwilioCredentialDto" || c.CreateTwilioCredentialDto != nil {
		return visitor.VisitCreateTwilioCredentialDto(c.CreateTwilioCredentialDto)
	}
	if c.typ == "CreateVonageCredentialDto" || c.CreateVonageCredentialDto != nil {
		return visitor.VisitCreateVonageCredentialDto(c.CreateVonageCredentialDto)
	}
	if c.typ == "CreateWebhookCredentialDto" || c.CreateWebhookCredentialDto != nil {
		return visitor.VisitCreateWebhookCredentialDto(c.CreateWebhookCredentialDto)
	}
	if c.typ == "CreateXAiCredentialDto" || c.CreateXAiCredentialDto != nil {
		return visitor.VisitCreateXAiCredentialDto(c.CreateXAiCredentialDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the mode for the first message. Default is 'assistant-speaks-first'.
//
// Use:
// - 'assistant-speaks-first' to have the assistant speak first.
// - 'assistant-waits-for-user' to have the assistant wait for the user to speak first.
// - 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).
//
// @default 'assistant-speaks-first'
type CreateAssistantDtoFirstMessageMode string

const (
	CreateAssistantDtoFirstMessageModeAssistantSpeaksFirst                          CreateAssistantDtoFirstMessageMode = "assistant-speaks-first"
	CreateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage CreateAssistantDtoFirstMessageMode = "assistant-speaks-first-with-model-generated-message"
	CreateAssistantDtoFirstMessageModeAssistantWaitsForUser                         CreateAssistantDtoFirstMessageMode = "assistant-waits-for-user"
)

func NewCreateAssistantDtoFirstMessageModeFromString(s string) (CreateAssistantDtoFirstMessageMode, error) {
	switch s {
	case "assistant-speaks-first":
		return CreateAssistantDtoFirstMessageModeAssistantSpeaksFirst, nil
	case "assistant-speaks-first-with-model-generated-message":
		return CreateAssistantDtoFirstMessageModeAssistantSpeaksFirstWithModelGeneratedMessage, nil
	case "assistant-waits-for-user":
		return CreateAssistantDtoFirstMessageModeAssistantWaitsForUser, nil
	}
	var t CreateAssistantDtoFirstMessageMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoFirstMessageMode) Ptr() *CreateAssistantDtoFirstMessageMode {
	return &c
}

// These are the options for the assistant's LLM.
type CreateAssistantDtoModel struct {
	AnyscaleModel     *AnyscaleModel
	AnthropicModel    *AnthropicModel
	CustomLlmModel    *CustomLlmModel
	DeepInfraModel    *DeepInfraModel
	GoogleModel       *GoogleModel
	GroqModel         *GroqModel
	InflectionAiModel *InflectionAiModel
	DeepSeekModel     *DeepSeekModel
	OpenAiModel       *OpenAiModel
	OpenRouterModel   *OpenRouterModel
	PerplexityAiModel *PerplexityAiModel
	TogetherAiModel   *TogetherAiModel
	VapiModel         *VapiModel
	XaiModel          *XaiModel

	typ string
}

func (c *CreateAssistantDtoModel) GetAnyscaleModel() *AnyscaleModel {
	if c == nil {
		return nil
	}
	return c.AnyscaleModel
}

func (c *CreateAssistantDtoModel) GetAnthropicModel() *AnthropicModel {
	if c == nil {
		return nil
	}
	return c.AnthropicModel
}

func (c *CreateAssistantDtoModel) GetCustomLlmModel() *CustomLlmModel {
	if c == nil {
		return nil
	}
	return c.CustomLlmModel
}

func (c *CreateAssistantDtoModel) GetDeepInfraModel() *DeepInfraModel {
	if c == nil {
		return nil
	}
	return c.DeepInfraModel
}

func (c *CreateAssistantDtoModel) GetGoogleModel() *GoogleModel {
	if c == nil {
		return nil
	}
	return c.GoogleModel
}

func (c *CreateAssistantDtoModel) GetGroqModel() *GroqModel {
	if c == nil {
		return nil
	}
	return c.GroqModel
}

func (c *CreateAssistantDtoModel) GetInflectionAiModel() *InflectionAiModel {
	if c == nil {
		return nil
	}
	return c.InflectionAiModel
}

func (c *CreateAssistantDtoModel) GetDeepSeekModel() *DeepSeekModel {
	if c == nil {
		return nil
	}
	return c.DeepSeekModel
}

func (c *CreateAssistantDtoModel) GetOpenAiModel() *OpenAiModel {
	if c == nil {
		return nil
	}
	return c.OpenAiModel
}

func (c *CreateAssistantDtoModel) GetOpenRouterModel() *OpenRouterModel {
	if c == nil {
		return nil
	}
	return c.OpenRouterModel
}

func (c *CreateAssistantDtoModel) GetPerplexityAiModel() *PerplexityAiModel {
	if c == nil {
		return nil
	}
	return c.PerplexityAiModel
}

func (c *CreateAssistantDtoModel) GetTogetherAiModel() *TogetherAiModel {
	if c == nil {
		return nil
	}
	return c.TogetherAiModel
}

func (c *CreateAssistantDtoModel) GetVapiModel() *VapiModel {
	if c == nil {
		return nil
	}
	return c.VapiModel
}

func (c *CreateAssistantDtoModel) GetXaiModel() *XaiModel {
	if c == nil {
		return nil
	}
	return c.XaiModel
}

func (c *CreateAssistantDtoModel) UnmarshalJSON(data []byte) error {
	valueAnyscaleModel := new(AnyscaleModel)
	if err := json.Unmarshal(data, &valueAnyscaleModel); err == nil {
		c.typ = "AnyscaleModel"
		c.AnyscaleModel = valueAnyscaleModel
		return nil
	}
	valueAnthropicModel := new(AnthropicModel)
	if err := json.Unmarshal(data, &valueAnthropicModel); err == nil {
		c.typ = "AnthropicModel"
		c.AnthropicModel = valueAnthropicModel
		return nil
	}
	valueCustomLlmModel := new(CustomLlmModel)
	if err := json.Unmarshal(data, &valueCustomLlmModel); err == nil {
		c.typ = "CustomLlmModel"
		c.CustomLlmModel = valueCustomLlmModel
		return nil
	}
	valueDeepInfraModel := new(DeepInfraModel)
	if err := json.Unmarshal(data, &valueDeepInfraModel); err == nil {
		c.typ = "DeepInfraModel"
		c.DeepInfraModel = valueDeepInfraModel
		return nil
	}
	valueGoogleModel := new(GoogleModel)
	if err := json.Unmarshal(data, &valueGoogleModel); err == nil {
		c.typ = "GoogleModel"
		c.GoogleModel = valueGoogleModel
		return nil
	}
	valueGroqModel := new(GroqModel)
	if err := json.Unmarshal(data, &valueGroqModel); err == nil {
		c.typ = "GroqModel"
		c.GroqModel = valueGroqModel
		return nil
	}
	valueInflectionAiModel := new(InflectionAiModel)
	if err := json.Unmarshal(data, &valueInflectionAiModel); err == nil {
		c.typ = "InflectionAiModel"
		c.InflectionAiModel = valueInflectionAiModel
		return nil
	}
	valueDeepSeekModel := new(DeepSeekModel)
	if err := json.Unmarshal(data, &valueDeepSeekModel); err == nil {
		c.typ = "DeepSeekModel"
		c.DeepSeekModel = valueDeepSeekModel
		return nil
	}
	valueOpenAiModel := new(OpenAiModel)
	if err := json.Unmarshal(data, &valueOpenAiModel); err == nil {
		c.typ = "OpenAiModel"
		c.OpenAiModel = valueOpenAiModel
		return nil
	}
	valueOpenRouterModel := new(OpenRouterModel)
	if err := json.Unmarshal(data, &valueOpenRouterModel); err == nil {
		c.typ = "OpenRouterModel"
		c.OpenRouterModel = valueOpenRouterModel
		return nil
	}
	valuePerplexityAiModel := new(PerplexityAiModel)
	if err := json.Unmarshal(data, &valuePerplexityAiModel); err == nil {
		c.typ = "PerplexityAiModel"
		c.PerplexityAiModel = valuePerplexityAiModel
		return nil
	}
	valueTogetherAiModel := new(TogetherAiModel)
	if err := json.Unmarshal(data, &valueTogetherAiModel); err == nil {
		c.typ = "TogetherAiModel"
		c.TogetherAiModel = valueTogetherAiModel
		return nil
	}
	valueVapiModel := new(VapiModel)
	if err := json.Unmarshal(data, &valueVapiModel); err == nil {
		c.typ = "VapiModel"
		c.VapiModel = valueVapiModel
		return nil
	}
	valueXaiModel := new(XaiModel)
	if err := json.Unmarshal(data, &valueXaiModel); err == nil {
		c.typ = "XaiModel"
		c.XaiModel = valueXaiModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoModel) MarshalJSON() ([]byte, error) {
	if c.typ == "AnyscaleModel" || c.AnyscaleModel != nil {
		return json.Marshal(c.AnyscaleModel)
	}
	if c.typ == "AnthropicModel" || c.AnthropicModel != nil {
		return json.Marshal(c.AnthropicModel)
	}
	if c.typ == "CustomLlmModel" || c.CustomLlmModel != nil {
		return json.Marshal(c.CustomLlmModel)
	}
	if c.typ == "DeepInfraModel" || c.DeepInfraModel != nil {
		return json.Marshal(c.DeepInfraModel)
	}
	if c.typ == "GoogleModel" || c.GoogleModel != nil {
		return json.Marshal(c.GoogleModel)
	}
	if c.typ == "GroqModel" || c.GroqModel != nil {
		return json.Marshal(c.GroqModel)
	}
	if c.typ == "InflectionAiModel" || c.InflectionAiModel != nil {
		return json.Marshal(c.InflectionAiModel)
	}
	if c.typ == "DeepSeekModel" || c.DeepSeekModel != nil {
		return json.Marshal(c.DeepSeekModel)
	}
	if c.typ == "OpenAiModel" || c.OpenAiModel != nil {
		return json.Marshal(c.OpenAiModel)
	}
	if c.typ == "OpenRouterModel" || c.OpenRouterModel != nil {
		return json.Marshal(c.OpenRouterModel)
	}
	if c.typ == "PerplexityAiModel" || c.PerplexityAiModel != nil {
		return json.Marshal(c.PerplexityAiModel)
	}
	if c.typ == "TogetherAiModel" || c.TogetherAiModel != nil {
		return json.Marshal(c.TogetherAiModel)
	}
	if c.typ == "VapiModel" || c.VapiModel != nil {
		return json.Marshal(c.VapiModel)
	}
	if c.typ == "XaiModel" || c.XaiModel != nil {
		return json.Marshal(c.XaiModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoModelVisitor interface {
	VisitAnyscaleModel(*AnyscaleModel) error
	VisitAnthropicModel(*AnthropicModel) error
	VisitCustomLlmModel(*CustomLlmModel) error
	VisitDeepInfraModel(*DeepInfraModel) error
	VisitGoogleModel(*GoogleModel) error
	VisitGroqModel(*GroqModel) error
	VisitInflectionAiModel(*InflectionAiModel) error
	VisitDeepSeekModel(*DeepSeekModel) error
	VisitOpenAiModel(*OpenAiModel) error
	VisitOpenRouterModel(*OpenRouterModel) error
	VisitPerplexityAiModel(*PerplexityAiModel) error
	VisitTogetherAiModel(*TogetherAiModel) error
	VisitVapiModel(*VapiModel) error
	VisitXaiModel(*XaiModel) error
}

func (c *CreateAssistantDtoModel) Accept(visitor CreateAssistantDtoModelVisitor) error {
	if c.typ == "AnyscaleModel" || c.AnyscaleModel != nil {
		return visitor.VisitAnyscaleModel(c.AnyscaleModel)
	}
	if c.typ == "AnthropicModel" || c.AnthropicModel != nil {
		return visitor.VisitAnthropicModel(c.AnthropicModel)
	}
	if c.typ == "CustomLlmModel" || c.CustomLlmModel != nil {
		return visitor.VisitCustomLlmModel(c.CustomLlmModel)
	}
	if c.typ == "DeepInfraModel" || c.DeepInfraModel != nil {
		return visitor.VisitDeepInfraModel(c.DeepInfraModel)
	}
	if c.typ == "GoogleModel" || c.GoogleModel != nil {
		return visitor.VisitGoogleModel(c.GoogleModel)
	}
	if c.typ == "GroqModel" || c.GroqModel != nil {
		return visitor.VisitGroqModel(c.GroqModel)
	}
	if c.typ == "InflectionAiModel" || c.InflectionAiModel != nil {
		return visitor.VisitInflectionAiModel(c.InflectionAiModel)
	}
	if c.typ == "DeepSeekModel" || c.DeepSeekModel != nil {
		return visitor.VisitDeepSeekModel(c.DeepSeekModel)
	}
	if c.typ == "OpenAiModel" || c.OpenAiModel != nil {
		return visitor.VisitOpenAiModel(c.OpenAiModel)
	}
	if c.typ == "OpenRouterModel" || c.OpenRouterModel != nil {
		return visitor.VisitOpenRouterModel(c.OpenRouterModel)
	}
	if c.typ == "PerplexityAiModel" || c.PerplexityAiModel != nil {
		return visitor.VisitPerplexityAiModel(c.PerplexityAiModel)
	}
	if c.typ == "TogetherAiModel" || c.TogetherAiModel != nil {
		return visitor.VisitTogetherAiModel(c.TogetherAiModel)
	}
	if c.typ == "VapiModel" || c.VapiModel != nil {
		return visitor.VisitVapiModel(c.VapiModel)
	}
	if c.typ == "XaiModel" || c.XaiModel != nil {
		return visitor.VisitXaiModel(c.XaiModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoServerMessagesItem string

const (
	CreateAssistantDtoServerMessagesItemConversationUpdate         CreateAssistantDtoServerMessagesItem = "conversation-update"
	CreateAssistantDtoServerMessagesItemEndOfCallReport            CreateAssistantDtoServerMessagesItem = "end-of-call-report"
	CreateAssistantDtoServerMessagesItemFunctionCall               CreateAssistantDtoServerMessagesItem = "function-call"
	CreateAssistantDtoServerMessagesItemHang                       CreateAssistantDtoServerMessagesItem = "hang"
	CreateAssistantDtoServerMessagesItemLanguageChanged            CreateAssistantDtoServerMessagesItem = "language-changed"
	CreateAssistantDtoServerMessagesItemLanguageChangeDetected     CreateAssistantDtoServerMessagesItem = "language-change-detected"
	CreateAssistantDtoServerMessagesItemModelOutput                CreateAssistantDtoServerMessagesItem = "model-output"
	CreateAssistantDtoServerMessagesItemPhoneCallControl           CreateAssistantDtoServerMessagesItem = "phone-call-control"
	CreateAssistantDtoServerMessagesItemSpeechUpdate               CreateAssistantDtoServerMessagesItem = "speech-update"
	CreateAssistantDtoServerMessagesItemStatusUpdate               CreateAssistantDtoServerMessagesItem = "status-update"
	CreateAssistantDtoServerMessagesItemTranscript                 CreateAssistantDtoServerMessagesItem = "transcript"
	CreateAssistantDtoServerMessagesItemToolCalls                  CreateAssistantDtoServerMessagesItem = "tool-calls"
	CreateAssistantDtoServerMessagesItemTransferDestinationRequest CreateAssistantDtoServerMessagesItem = "transfer-destination-request"
	CreateAssistantDtoServerMessagesItemTransferUpdate             CreateAssistantDtoServerMessagesItem = "transfer-update"
	CreateAssistantDtoServerMessagesItemUserInterrupted            CreateAssistantDtoServerMessagesItem = "user-interrupted"
	CreateAssistantDtoServerMessagesItemVoiceInput                 CreateAssistantDtoServerMessagesItem = "voice-input"
)

func NewCreateAssistantDtoServerMessagesItemFromString(s string) (CreateAssistantDtoServerMessagesItem, error) {
	switch s {
	case "conversation-update":
		return CreateAssistantDtoServerMessagesItemConversationUpdate, nil
	case "end-of-call-report":
		return CreateAssistantDtoServerMessagesItemEndOfCallReport, nil
	case "function-call":
		return CreateAssistantDtoServerMessagesItemFunctionCall, nil
	case "hang":
		return CreateAssistantDtoServerMessagesItemHang, nil
	case "language-changed":
		return CreateAssistantDtoServerMessagesItemLanguageChanged, nil
	case "language-change-detected":
		return CreateAssistantDtoServerMessagesItemLanguageChangeDetected, nil
	case "model-output":
		return CreateAssistantDtoServerMessagesItemModelOutput, nil
	case "phone-call-control":
		return CreateAssistantDtoServerMessagesItemPhoneCallControl, nil
	case "speech-update":
		return CreateAssistantDtoServerMessagesItemSpeechUpdate, nil
	case "status-update":
		return CreateAssistantDtoServerMessagesItemStatusUpdate, nil
	case "transcript":
		return CreateAssistantDtoServerMessagesItemTranscript, nil
	case "tool-calls":
		return CreateAssistantDtoServerMessagesItemToolCalls, nil
	case "transfer-destination-request":
		return CreateAssistantDtoServerMessagesItemTransferDestinationRequest, nil
	case "transfer-update":
		return CreateAssistantDtoServerMessagesItemTransferUpdate, nil
	case "user-interrupted":
		return CreateAssistantDtoServerMessagesItemUserInterrupted, nil
	case "voice-input":
		return CreateAssistantDtoServerMessagesItemVoiceInput, nil
	}
	var t CreateAssistantDtoServerMessagesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssistantDtoServerMessagesItem) Ptr() *CreateAssistantDtoServerMessagesItem {
	return &c
}

// These are the options for the assistant's transcriber.
type CreateAssistantDtoTranscriber struct {
	AssemblyAiTranscriber  *AssemblyAiTranscriber
	AzureSpeechTranscriber *AzureSpeechTranscriber
	CustomTranscriber      *CustomTranscriber
	DeepgramTranscriber    *DeepgramTranscriber
	GladiaTranscriber      *GladiaTranscriber
	TalkscriberTranscriber *TalkscriberTranscriber

	typ string
}

func (c *CreateAssistantDtoTranscriber) GetAssemblyAiTranscriber() *AssemblyAiTranscriber {
	if c == nil {
		return nil
	}
	return c.AssemblyAiTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetAzureSpeechTranscriber() *AzureSpeechTranscriber {
	if c == nil {
		return nil
	}
	return c.AzureSpeechTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetCustomTranscriber() *CustomTranscriber {
	if c == nil {
		return nil
	}
	return c.CustomTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetDeepgramTranscriber() *DeepgramTranscriber {
	if c == nil {
		return nil
	}
	return c.DeepgramTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetGladiaTranscriber() *GladiaTranscriber {
	if c == nil {
		return nil
	}
	return c.GladiaTranscriber
}

func (c *CreateAssistantDtoTranscriber) GetTalkscriberTranscriber() *TalkscriberTranscriber {
	if c == nil {
		return nil
	}
	return c.TalkscriberTranscriber
}

func (c *CreateAssistantDtoTranscriber) UnmarshalJSON(data []byte) error {
	valueAssemblyAiTranscriber := new(AssemblyAiTranscriber)
	if err := json.Unmarshal(data, &valueAssemblyAiTranscriber); err == nil {
		c.typ = "AssemblyAiTranscriber"
		c.AssemblyAiTranscriber = valueAssemblyAiTranscriber
		return nil
	}
	valueAzureSpeechTranscriber := new(AzureSpeechTranscriber)
	if err := json.Unmarshal(data, &valueAzureSpeechTranscriber); err == nil {
		c.typ = "AzureSpeechTranscriber"
		c.AzureSpeechTranscriber = valueAzureSpeechTranscriber
		return nil
	}
	valueCustomTranscriber := new(CustomTranscriber)
	if err := json.Unmarshal(data, &valueCustomTranscriber); err == nil {
		c.typ = "CustomTranscriber"
		c.CustomTranscriber = valueCustomTranscriber
		return nil
	}
	valueDeepgramTranscriber := new(DeepgramTranscriber)
	if err := json.Unmarshal(data, &valueDeepgramTranscriber); err == nil {
		c.typ = "DeepgramTranscriber"
		c.DeepgramTranscriber = valueDeepgramTranscriber
		return nil
	}
	valueGladiaTranscriber := new(GladiaTranscriber)
	if err := json.Unmarshal(data, &valueGladiaTranscriber); err == nil {
		c.typ = "GladiaTranscriber"
		c.GladiaTranscriber = valueGladiaTranscriber
		return nil
	}
	valueTalkscriberTranscriber := new(TalkscriberTranscriber)
	if err := json.Unmarshal(data, &valueTalkscriberTranscriber); err == nil {
		c.typ = "TalkscriberTranscriber"
		c.TalkscriberTranscriber = valueTalkscriberTranscriber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoTranscriber) MarshalJSON() ([]byte, error) {
	if c.typ == "AssemblyAiTranscriber" || c.AssemblyAiTranscriber != nil {
		return json.Marshal(c.AssemblyAiTranscriber)
	}
	if c.typ == "AzureSpeechTranscriber" || c.AzureSpeechTranscriber != nil {
		return json.Marshal(c.AzureSpeechTranscriber)
	}
	if c.typ == "CustomTranscriber" || c.CustomTranscriber != nil {
		return json.Marshal(c.CustomTranscriber)
	}
	if c.typ == "DeepgramTranscriber" || c.DeepgramTranscriber != nil {
		return json.Marshal(c.DeepgramTranscriber)
	}
	if c.typ == "GladiaTranscriber" || c.GladiaTranscriber != nil {
		return json.Marshal(c.GladiaTranscriber)
	}
	if c.typ == "TalkscriberTranscriber" || c.TalkscriberTranscriber != nil {
		return json.Marshal(c.TalkscriberTranscriber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoTranscriberVisitor interface {
	VisitAssemblyAiTranscriber(*AssemblyAiTranscriber) error
	VisitAzureSpeechTranscriber(*AzureSpeechTranscriber) error
	VisitCustomTranscriber(*CustomTranscriber) error
	VisitDeepgramTranscriber(*DeepgramTranscriber) error
	VisitGladiaTranscriber(*GladiaTranscriber) error
	VisitTalkscriberTranscriber(*TalkscriberTranscriber) error
}

func (c *CreateAssistantDtoTranscriber) Accept(visitor CreateAssistantDtoTranscriberVisitor) error {
	if c.typ == "AssemblyAiTranscriber" || c.AssemblyAiTranscriber != nil {
		return visitor.VisitAssemblyAiTranscriber(c.AssemblyAiTranscriber)
	}
	if c.typ == "AzureSpeechTranscriber" || c.AzureSpeechTranscriber != nil {
		return visitor.VisitAzureSpeechTranscriber(c.AzureSpeechTranscriber)
	}
	if c.typ == "CustomTranscriber" || c.CustomTranscriber != nil {
		return visitor.VisitCustomTranscriber(c.CustomTranscriber)
	}
	if c.typ == "DeepgramTranscriber" || c.DeepgramTranscriber != nil {
		return visitor.VisitDeepgramTranscriber(c.DeepgramTranscriber)
	}
	if c.typ == "GladiaTranscriber" || c.GladiaTranscriber != nil {
		return visitor.VisitGladiaTranscriber(c.GladiaTranscriber)
	}
	if c.typ == "TalkscriberTranscriber" || c.TalkscriberTranscriber != nil {
		return visitor.VisitTalkscriberTranscriber(c.TalkscriberTranscriber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// These are the options for the assistant's voice.
type CreateAssistantDtoVoice struct {
	AzureVoice      *AzureVoice
	CartesiaVoice   *CartesiaVoice
	CustomVoice     *CustomVoice
	DeepgramVoice   *DeepgramVoice
	ElevenLabsVoice *ElevenLabsVoice
	LmntVoice       *LmntVoice
	NeetsVoice      *NeetsVoice
	OpenAiVoice     *OpenAiVoice
	PlayHtVoice     *PlayHtVoice
	RimeAiVoice     *RimeAiVoice
	SmallestAiVoice *SmallestAiVoice
	TavusVoice      *TavusVoice

	typ string
}

func (c *CreateAssistantDtoVoice) GetAzureVoice() *AzureVoice {
	if c == nil {
		return nil
	}
	return c.AzureVoice
}

func (c *CreateAssistantDtoVoice) GetCartesiaVoice() *CartesiaVoice {
	if c == nil {
		return nil
	}
	return c.CartesiaVoice
}

func (c *CreateAssistantDtoVoice) GetCustomVoice() *CustomVoice {
	if c == nil {
		return nil
	}
	return c.CustomVoice
}

func (c *CreateAssistantDtoVoice) GetDeepgramVoice() *DeepgramVoice {
	if c == nil {
		return nil
	}
	return c.DeepgramVoice
}

func (c *CreateAssistantDtoVoice) GetElevenLabsVoice() *ElevenLabsVoice {
	if c == nil {
		return nil
	}
	return c.ElevenLabsVoice
}

func (c *CreateAssistantDtoVoice) GetLmntVoice() *LmntVoice {
	if c == nil {
		return nil
	}
	return c.LmntVoice
}

func (c *CreateAssistantDtoVoice) GetNeetsVoice() *NeetsVoice {
	if c == nil {
		return nil
	}
	return c.NeetsVoice
}

func (c *CreateAssistantDtoVoice) GetOpenAiVoice() *OpenAiVoice {
	if c == nil {
		return nil
	}
	return c.OpenAiVoice
}

func (c *CreateAssistantDtoVoice) GetPlayHtVoice() *PlayHtVoice {
	if c == nil {
		return nil
	}
	return c.PlayHtVoice
}

func (c *CreateAssistantDtoVoice) GetRimeAiVoice() *RimeAiVoice {
	if c == nil {
		return nil
	}
	return c.RimeAiVoice
}

func (c *CreateAssistantDtoVoice) GetSmallestAiVoice() *SmallestAiVoice {
	if c == nil {
		return nil
	}
	return c.SmallestAiVoice
}

func (c *CreateAssistantDtoVoice) GetTavusVoice() *TavusVoice {
	if c == nil {
		return nil
	}
	return c.TavusVoice
}

func (c *CreateAssistantDtoVoice) UnmarshalJSON(data []byte) error {
	valueAzureVoice := new(AzureVoice)
	if err := json.Unmarshal(data, &valueAzureVoice); err == nil {
		c.typ = "AzureVoice"
		c.AzureVoice = valueAzureVoice
		return nil
	}
	valueCartesiaVoice := new(CartesiaVoice)
	if err := json.Unmarshal(data, &valueCartesiaVoice); err == nil {
		c.typ = "CartesiaVoice"
		c.CartesiaVoice = valueCartesiaVoice
		return nil
	}
	valueCustomVoice := new(CustomVoice)
	if err := json.Unmarshal(data, &valueCustomVoice); err == nil {
		c.typ = "CustomVoice"
		c.CustomVoice = valueCustomVoice
		return nil
	}
	valueDeepgramVoice := new(DeepgramVoice)
	if err := json.Unmarshal(data, &valueDeepgramVoice); err == nil {
		c.typ = "DeepgramVoice"
		c.DeepgramVoice = valueDeepgramVoice
		return nil
	}
	valueElevenLabsVoice := new(ElevenLabsVoice)
	if err := json.Unmarshal(data, &valueElevenLabsVoice); err == nil {
		c.typ = "ElevenLabsVoice"
		c.ElevenLabsVoice = valueElevenLabsVoice
		return nil
	}
	valueLmntVoice := new(LmntVoice)
	if err := json.Unmarshal(data, &valueLmntVoice); err == nil {
		c.typ = "LmntVoice"
		c.LmntVoice = valueLmntVoice
		return nil
	}
	valueNeetsVoice := new(NeetsVoice)
	if err := json.Unmarshal(data, &valueNeetsVoice); err == nil {
		c.typ = "NeetsVoice"
		c.NeetsVoice = valueNeetsVoice
		return nil
	}
	valueOpenAiVoice := new(OpenAiVoice)
	if err := json.Unmarshal(data, &valueOpenAiVoice); err == nil {
		c.typ = "OpenAiVoice"
		c.OpenAiVoice = valueOpenAiVoice
		return nil
	}
	valuePlayHtVoice := new(PlayHtVoice)
	if err := json.Unmarshal(data, &valuePlayHtVoice); err == nil {
		c.typ = "PlayHtVoice"
		c.PlayHtVoice = valuePlayHtVoice
		return nil
	}
	valueRimeAiVoice := new(RimeAiVoice)
	if err := json.Unmarshal(data, &valueRimeAiVoice); err == nil {
		c.typ = "RimeAiVoice"
		c.RimeAiVoice = valueRimeAiVoice
		return nil
	}
	valueSmallestAiVoice := new(SmallestAiVoice)
	if err := json.Unmarshal(data, &valueSmallestAiVoice); err == nil {
		c.typ = "SmallestAiVoice"
		c.SmallestAiVoice = valueSmallestAiVoice
		return nil
	}
	valueTavusVoice := new(TavusVoice)
	if err := json.Unmarshal(data, &valueTavusVoice); err == nil {
		c.typ = "TavusVoice"
		c.TavusVoice = valueTavusVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateAssistantDtoVoice) MarshalJSON() ([]byte, error) {
	if c.typ == "AzureVoice" || c.AzureVoice != nil {
		return json.Marshal(c.AzureVoice)
	}
	if c.typ == "CartesiaVoice" || c.CartesiaVoice != nil {
		return json.Marshal(c.CartesiaVoice)
	}
	if c.typ == "CustomVoice" || c.CustomVoice != nil {
		return json.Marshal(c.CustomVoice)
	}
	if c.typ == "DeepgramVoice" || c.DeepgramVoice != nil {
		return json.Marshal(c.DeepgramVoice)
	}
	if c.typ == "ElevenLabsVoice" || c.ElevenLabsVoice != nil {
		return json.Marshal(c.ElevenLabsVoice)
	}
	if c.typ == "LmntVoice" || c.LmntVoice != nil {
		return json.Marshal(c.LmntVoice)
	}
	if c.typ == "NeetsVoice" || c.NeetsVoice != nil {
		return json.Marshal(c.NeetsVoice)
	}
	if c.typ == "OpenAiVoice" || c.OpenAiVoice != nil {
		return json.Marshal(c.OpenAiVoice)
	}
	if c.typ == "PlayHtVoice" || c.PlayHtVoice != nil {
		return json.Marshal(c.PlayHtVoice)
	}
	if c.typ == "RimeAiVoice" || c.RimeAiVoice != nil {
		return json.Marshal(c.RimeAiVoice)
	}
	if c.typ == "SmallestAiVoice" || c.SmallestAiVoice != nil {
		return json.Marshal(c.SmallestAiVoice)
	}
	if c.typ == "TavusVoice" || c.TavusVoice != nil {
		return json.Marshal(c.TavusVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAssistantDtoVoiceVisitor interface {
	VisitAzureVoice(*AzureVoice) error
	VisitCartesiaVoice(*CartesiaVoice) error
	VisitCustomVoice(*CustomVoice) error
	VisitDeepgramVoice(*DeepgramVoice) error
	VisitElevenLabsVoice(*ElevenLabsVoice) error
	VisitLmntVoice(*LmntVoice) error
	VisitNeetsVoice(*NeetsVoice) error
	VisitOpenAiVoice(*OpenAiVoice) error
	VisitPlayHtVoice(*PlayHtVoice) error
	VisitRimeAiVoice(*RimeAiVoice) error
	VisitSmallestAiVoice(*SmallestAiVoice) error
	VisitTavusVoice(*TavusVoice) error
}

func (c *CreateAssistantDtoVoice) Accept(visitor CreateAssistantDtoVoiceVisitor) error {
	if c.typ == "AzureVoice" || c.AzureVoice != nil {
		return visitor.VisitAzureVoice(c.AzureVoice)
	}
	if c.typ == "CartesiaVoice" || c.CartesiaVoice != nil {
		return visitor.VisitCartesiaVoice(c.CartesiaVoice)
	}
	if c.typ == "CustomVoice" || c.CustomVoice != nil {
		return visitor.VisitCustomVoice(c.CustomVoice)
	}
	if c.typ == "DeepgramVoice" || c.DeepgramVoice != nil {
		return visitor.VisitDeepgramVoice(c.DeepgramVoice)
	}
	if c.typ == "ElevenLabsVoice" || c.ElevenLabsVoice != nil {
		return visitor.VisitElevenLabsVoice(c.ElevenLabsVoice)
	}
	if c.typ == "LmntVoice" || c.LmntVoice != nil {
		return visitor.VisitLmntVoice(c.LmntVoice)
	}
	if c.typ == "NeetsVoice" || c.NeetsVoice != nil {
		return visitor.VisitNeetsVoice(c.NeetsVoice)
	}
	if c.typ == "OpenAiVoice" || c.OpenAiVoice != nil {
		return visitor.VisitOpenAiVoice(c.OpenAiVoice)
	}
	if c.typ == "PlayHtVoice" || c.PlayHtVoice != nil {
		return visitor.VisitPlayHtVoice(c.PlayHtVoice)
	}
	if c.typ == "RimeAiVoice" || c.RimeAiVoice != nil {
		return visitor.VisitRimeAiVoice(c.RimeAiVoice)
	}
	if c.typ == "SmallestAiVoice" || c.SmallestAiVoice != nil {
		return visitor.VisitSmallestAiVoice(c.SmallestAiVoice)
	}
	if c.typ == "TavusVoice" || c.TavusVoice != nil {
		return visitor.VisitTavusVoice(c.TavusVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateAzureCredentialDto struct {
	// This is the service being used in Azure.
	Service CreateAzureCredentialDtoService `json:"service" url:"service"`
	// This is the region of the Azure resource.
	Region *CreateAzureCredentialDtoRegion `json:"region,omitempty" url:"region,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.
	BucketPlan *AzureBlobStorageBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAzureCredentialDto) GetService() CreateAzureCredentialDtoService {
	if c == nil {
		return ""
	}
	return c.Service
}

func (c *CreateAzureCredentialDto) GetRegion() *CreateAzureCredentialDtoRegion {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateAzureCredentialDto) GetApiKey() *string {
	if c == nil {
		return nil
	}
	return c.ApiKey
}

func (c *CreateAzureCredentialDto) GetBucketPlan() *AzureBlobStorageBucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CreateAzureCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAzureCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAzureCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAzureCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAzureCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAzureCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "azure", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAzureCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAzureCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAzureCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the region of the Azure resource.
type CreateAzureCredentialDtoRegion string

const (
	CreateAzureCredentialDtoRegionAustralia      CreateAzureCredentialDtoRegion = "australia"
	CreateAzureCredentialDtoRegionCanada         CreateAzureCredentialDtoRegion = "canada"
	CreateAzureCredentialDtoRegionEastus2        CreateAzureCredentialDtoRegion = "eastus2"
	CreateAzureCredentialDtoRegionEastus         CreateAzureCredentialDtoRegion = "eastus"
	CreateAzureCredentialDtoRegionFrance         CreateAzureCredentialDtoRegion = "france"
	CreateAzureCredentialDtoRegionIndia          CreateAzureCredentialDtoRegion = "india"
	CreateAzureCredentialDtoRegionJapan          CreateAzureCredentialDtoRegion = "japan"
	CreateAzureCredentialDtoRegionUaenorth       CreateAzureCredentialDtoRegion = "uaenorth"
	CreateAzureCredentialDtoRegionNorthcentralus CreateAzureCredentialDtoRegion = "northcentralus"
	CreateAzureCredentialDtoRegionNorway         CreateAzureCredentialDtoRegion = "norway"
	CreateAzureCredentialDtoRegionSouthcentralus CreateAzureCredentialDtoRegion = "southcentralus"
	CreateAzureCredentialDtoRegionSwedencentral  CreateAzureCredentialDtoRegion = "swedencentral"
	CreateAzureCredentialDtoRegionSwitzerland    CreateAzureCredentialDtoRegion = "switzerland"
	CreateAzureCredentialDtoRegionUk             CreateAzureCredentialDtoRegion = "uk"
	CreateAzureCredentialDtoRegionWestus         CreateAzureCredentialDtoRegion = "westus"
	CreateAzureCredentialDtoRegionWestus3        CreateAzureCredentialDtoRegion = "westus3"
)

func NewCreateAzureCredentialDtoRegionFromString(s string) (CreateAzureCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return CreateAzureCredentialDtoRegionAustralia, nil
	case "canada":
		return CreateAzureCredentialDtoRegionCanada, nil
	case "eastus2":
		return CreateAzureCredentialDtoRegionEastus2, nil
	case "eastus":
		return CreateAzureCredentialDtoRegionEastus, nil
	case "france":
		return CreateAzureCredentialDtoRegionFrance, nil
	case "india":
		return CreateAzureCredentialDtoRegionIndia, nil
	case "japan":
		return CreateAzureCredentialDtoRegionJapan, nil
	case "uaenorth":
		return CreateAzureCredentialDtoRegionUaenorth, nil
	case "northcentralus":
		return CreateAzureCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return CreateAzureCredentialDtoRegionNorway, nil
	case "southcentralus":
		return CreateAzureCredentialDtoRegionSouthcentralus, nil
	case "swedencentral":
		return CreateAzureCredentialDtoRegionSwedencentral, nil
	case "switzerland":
		return CreateAzureCredentialDtoRegionSwitzerland, nil
	case "uk":
		return CreateAzureCredentialDtoRegionUk, nil
	case "westus":
		return CreateAzureCredentialDtoRegionWestus, nil
	case "westus3":
		return CreateAzureCredentialDtoRegionWestus3, nil
	}
	var t CreateAzureCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureCredentialDtoRegion) Ptr() *CreateAzureCredentialDtoRegion {
	return &c
}

// This is the service being used in Azure.
type CreateAzureCredentialDtoService string

const (
	CreateAzureCredentialDtoServiceSpeech      CreateAzureCredentialDtoService = "speech"
	CreateAzureCredentialDtoServiceBlobStorage CreateAzureCredentialDtoService = "blob_storage"
)

func NewCreateAzureCredentialDtoServiceFromString(s string) (CreateAzureCredentialDtoService, error) {
	switch s {
	case "speech":
		return CreateAzureCredentialDtoServiceSpeech, nil
	case "blob_storage":
		return CreateAzureCredentialDtoServiceBlobStorage, nil
	}
	var t CreateAzureCredentialDtoService
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureCredentialDtoService) Ptr() *CreateAzureCredentialDtoService {
	return &c
}

type CreateAzureOpenAiCredentialDto struct {
	Region CreateAzureOpenAiCredentialDtoRegion       `json:"region" url:"region"`
	Models []CreateAzureOpenAiCredentialDtoModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey string `json:"openAIKey" url:"openAIKey"`
	// This is not returned in the API.
	OcpApimSubscriptionKey *string `json:"ocpApimSubscriptionKey,omitempty" url:"ocpApimSubscriptionKey,omitempty"`
	OpenAiEndpoint         string  `json:"openAIEndpoint" url:"openAIEndpoint"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateAzureOpenAiCredentialDto) GetRegion() CreateAzureOpenAiCredentialDtoRegion {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateAzureOpenAiCredentialDto) GetModels() []CreateAzureOpenAiCredentialDtoModelsItem {
	if c == nil {
		return nil
	}
	return c.Models
}

func (c *CreateAzureOpenAiCredentialDto) GetOpenAiKey() string {
	if c == nil {
		return ""
	}
	return c.OpenAiKey
}

func (c *CreateAzureOpenAiCredentialDto) GetOcpApimSubscriptionKey() *string {
	if c == nil {
		return nil
	}
	return c.OcpApimSubscriptionKey
}

func (c *CreateAzureOpenAiCredentialDto) GetOpenAiEndpoint() string {
	if c == nil {
		return ""
	}
	return c.OpenAiEndpoint
}

func (c *CreateAzureOpenAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateAzureOpenAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateAzureOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAzureOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateAzureOpenAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateAzureOpenAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "azure-openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "azure-openai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAzureOpenAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateAzureOpenAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "azure-openai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateAzureOpenAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAzureOpenAiCredentialDtoModelsItem string

const (
	CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240806     CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-08-06"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718 CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-mini-2024-07-18"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240513     CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-05-13"
	CreateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409 CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-turbo-2024-04-09"
	CreateAzureOpenAiCredentialDtoModelsItemGpt40125Preview   CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0125-preview"
	CreateAzureOpenAiCredentialDtoModelsItemGpt41106Preview   CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-1106-preview"
	CreateAzureOpenAiCredentialDtoModelsItemGpt40613          CreateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0613"
	CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125    CreateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-0125"
	CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106    CreateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-1106"
)

func NewCreateAzureOpenAiCredentialDtoModelsItemFromString(s string) (CreateAzureOpenAiCredentialDtoModelsItem, error) {
	switch s {
	case "gpt-4o-2024-08-06":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240806, nil
	case "gpt-4o-mini-2024-07-18":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718, nil
	case "gpt-4o-2024-05-13":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4O20240513, nil
	case "gpt-4-turbo-2024-04-09":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return CreateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106, nil
	}
	var t CreateAzureOpenAiCredentialDtoModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureOpenAiCredentialDtoModelsItem) Ptr() *CreateAzureOpenAiCredentialDtoModelsItem {
	return &c
}

type CreateAzureOpenAiCredentialDtoRegion string

const (
	CreateAzureOpenAiCredentialDtoRegionAustralia      CreateAzureOpenAiCredentialDtoRegion = "australia"
	CreateAzureOpenAiCredentialDtoRegionCanada         CreateAzureOpenAiCredentialDtoRegion = "canada"
	CreateAzureOpenAiCredentialDtoRegionEastus2        CreateAzureOpenAiCredentialDtoRegion = "eastus2"
	CreateAzureOpenAiCredentialDtoRegionEastus         CreateAzureOpenAiCredentialDtoRegion = "eastus"
	CreateAzureOpenAiCredentialDtoRegionFrance         CreateAzureOpenAiCredentialDtoRegion = "france"
	CreateAzureOpenAiCredentialDtoRegionIndia          CreateAzureOpenAiCredentialDtoRegion = "india"
	CreateAzureOpenAiCredentialDtoRegionJapan          CreateAzureOpenAiCredentialDtoRegion = "japan"
	CreateAzureOpenAiCredentialDtoRegionUaenorth       CreateAzureOpenAiCredentialDtoRegion = "uaenorth"
	CreateAzureOpenAiCredentialDtoRegionNorthcentralus CreateAzureOpenAiCredentialDtoRegion = "northcentralus"
	CreateAzureOpenAiCredentialDtoRegionNorway         CreateAzureOpenAiCredentialDtoRegion = "norway"
	CreateAzureOpenAiCredentialDtoRegionSouthcentralus CreateAzureOpenAiCredentialDtoRegion = "southcentralus"
	CreateAzureOpenAiCredentialDtoRegionSwedencentral  CreateAzureOpenAiCredentialDtoRegion = "swedencentral"
	CreateAzureOpenAiCredentialDtoRegionSwitzerland    CreateAzureOpenAiCredentialDtoRegion = "switzerland"
	CreateAzureOpenAiCredentialDtoRegionUk             CreateAzureOpenAiCredentialDtoRegion = "uk"
	CreateAzureOpenAiCredentialDtoRegionWestus         CreateAzureOpenAiCredentialDtoRegion = "westus"
	CreateAzureOpenAiCredentialDtoRegionWestus3        CreateAzureOpenAiCredentialDtoRegion = "westus3"
)

func NewCreateAzureOpenAiCredentialDtoRegionFromString(s string) (CreateAzureOpenAiCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return CreateAzureOpenAiCredentialDtoRegionAustralia, nil
	case "canada":
		return CreateAzureOpenAiCredentialDtoRegionCanada, nil
	case "eastus2":
		return CreateAzureOpenAiCredentialDtoRegionEastus2, nil
	case "eastus":
		return CreateAzureOpenAiCredentialDtoRegionEastus, nil
	case "france":
		return CreateAzureOpenAiCredentialDtoRegionFrance, nil
	case "india":
		return CreateAzureOpenAiCredentialDtoRegionIndia, nil
	case "japan":
		return CreateAzureOpenAiCredentialDtoRegionJapan, nil
	case "uaenorth":
		return CreateAzureOpenAiCredentialDtoRegionUaenorth, nil
	case "northcentralus":
		return CreateAzureOpenAiCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return CreateAzureOpenAiCredentialDtoRegionNorway, nil
	case "southcentralus":
		return CreateAzureOpenAiCredentialDtoRegionSouthcentralus, nil
	case "swedencentral":
		return CreateAzureOpenAiCredentialDtoRegionSwedencentral, nil
	case "switzerland":
		return CreateAzureOpenAiCredentialDtoRegionSwitzerland, nil
	case "uk":
		return CreateAzureOpenAiCredentialDtoRegionUk, nil
	case "westus":
		return CreateAzureOpenAiCredentialDtoRegionWestus, nil
	case "westus3":
		return CreateAzureOpenAiCredentialDtoRegionWestus3, nil
	}
	var t CreateAzureOpenAiCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAzureOpenAiCredentialDtoRegion) Ptr() *CreateAzureOpenAiCredentialDtoRegion {
	return &c
}

type CreateByoSipTrunkCredentialDto struct {
	// This can be used to bring your own SIP trunks or to connect to a Carrier.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This can be used to configure the tech prefix on outbound calls. This is an advanced property.
	TechPrefix *string `json:"techPrefix,omitempty" url:"techPrefix,omitempty"`
	// This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.
	SipDiversionHeader *string `json:"sipDiversionHeader,omitempty" url:"sipDiversionHeader,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateByoSipTrunkCredentialDto) GetGateways() []*SipTrunkGateway {
	if c == nil {
		return nil
	}
	return c.Gateways
}

func (c *CreateByoSipTrunkCredentialDto) GetOutboundAuthenticationPlan() *SipTrunkOutboundAuthenticationPlan {
	if c == nil {
		return nil
	}
	return c.OutboundAuthenticationPlan
}

func (c *CreateByoSipTrunkCredentialDto) GetOutboundLeadingPlusEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.OutboundLeadingPlusEnabled
}

func (c *CreateByoSipTrunkCredentialDto) GetTechPrefix() *string {
	if c == nil {
		return nil
	}
	return c.TechPrefix
}

func (c *CreateByoSipTrunkCredentialDto) GetSipDiversionHeader() *string {
	if c == nil {
		return nil
	}
	return c.SipDiversionHeader
}

func (c *CreateByoSipTrunkCredentialDto) GetSbcConfiguration() *SbcConfiguration {
	if c == nil {
		return nil
	}
	return c.SbcConfiguration
}

func (c *CreateByoSipTrunkCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateByoSipTrunkCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateByoSipTrunkCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateByoSipTrunkCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateByoSipTrunkCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateByoSipTrunkCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCartesiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCartesiaCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateCartesiaCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateCartesiaCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCartesiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCartesiaCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCartesiaCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCartesiaCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cartesia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCartesiaCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCartesiaCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCartesiaCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCerebrasCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCerebrasCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateCerebrasCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateCerebrasCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCerebrasCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCerebrasCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCerebrasCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCerebrasCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "cerebras" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cerebras", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCerebrasCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCerebrasCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cerebras",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCerebrasCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCloudflareCredentialDto struct {
	// Credential provider. Only allowed value is cloudflare
	// Cloudflare Account Id.
	AccountId *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Cloudflare API Key / Token.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// Cloudflare Account Email.
	AccountEmail *string `json:"accountEmail,omitempty" url:"accountEmail,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in R2
	BucketPlan *CloudflareR2BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCloudflareCredentialDto) GetAccountId() *string {
	if c == nil {
		return nil
	}
	return c.AccountId
}

func (c *CreateCloudflareCredentialDto) GetApiKey() *string {
	if c == nil {
		return nil
	}
	return c.ApiKey
}

func (c *CreateCloudflareCredentialDto) GetAccountEmail() *string {
	if c == nil {
		return nil
	}
	return c.AccountEmail
}

func (c *CreateCloudflareCredentialDto) GetBucketPlan() *CloudflareR2BucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CreateCloudflareCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateCloudflareCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCloudflareCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCloudflareCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCloudflareCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCloudflareCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "cloudflare" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cloudflare", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCloudflareCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCloudflareCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "cloudflare",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCloudflareCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConversationBlockDto struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*CreateConversationBlockDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// This is the instruction to the model.
	//
	// You can reference any variable in the context of the current block execution (step):
	// - "{{input.your-property-name}}" for the current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// This can be as simple or as complex as you want it to be.
	// - "say hello and ask the user about their day!"
	// - "collect the user's first and last name"
	// - "user is {{input.firstName}} {{input.lastName}}. their age is {{input.age}}. ask them about their salary and if they might be interested in buying a house. we offer {{input.offer}}"
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output/input.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output/input.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	Instruction string `json:"instruction" url:"instruction"`
	// This is the name of the block. This is just for your reference.
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateConversationBlockDto) GetMessages() []*CreateConversationBlockDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateConversationBlockDto) GetInputSchema() *JsonSchema {
	if c == nil {
		return nil
	}
	return c.InputSchema
}

func (c *CreateConversationBlockDto) GetOutputSchema() *JsonSchema {
	if c == nil {
		return nil
	}
	return c.OutputSchema
}

func (c *CreateConversationBlockDto) GetInstruction() string {
	if c == nil {
		return ""
	}
	return c.Instruction
}

func (c *CreateConversationBlockDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateConversationBlockDto) Type() string {
	return c.type_
}

func (c *CreateConversationBlockDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateConversationBlockDto) UnmarshalJSON(data []byte) error {
	type embed CreateConversationBlockDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateConversationBlockDto(unmarshaler.embed)
	if unmarshaler.Type != "conversation" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConversationBlockDto) MarshalJSON() ([]byte, error) {
	type embed CreateConversationBlockDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "conversation",
	}
	return json.Marshal(marshaler)
}

func (c *CreateConversationBlockDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConversationBlockDtoMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage

	typ string
}

func (c *CreateConversationBlockDtoMessagesItem) GetBlockStartMessage() *BlockStartMessage {
	if c == nil {
		return nil
	}
	return c.BlockStartMessage
}

func (c *CreateConversationBlockDtoMessagesItem) GetBlockCompleteMessage() *BlockCompleteMessage {
	if c == nil {
		return nil
	}
	return c.BlockCompleteMessage
}

func (c *CreateConversationBlockDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		c.typ = "BlockStartMessage"
		c.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		c.typ = "BlockCompleteMessage"
		c.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateConversationBlockDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "BlockStartMessage" || c.BlockStartMessage != nil {
		return json.Marshal(c.BlockStartMessage)
	}
	if c.typ == "BlockCompleteMessage" || c.BlockCompleteMessage != nil {
		return json.Marshal(c.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateConversationBlockDtoMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (c *CreateConversationBlockDtoMessagesItem) Accept(visitor CreateConversationBlockDtoMessagesItemVisitor) error {
	if c.typ == "BlockStartMessage" || c.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(c.BlockStartMessage)
	}
	if c.typ == "BlockCompleteMessage" || c.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(c.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateCustomKnowledgeBaseDto struct {
	// /**
	// This is where the knowledge base request will be sent.
	//
	// Request Example:
	//
	// POST https://{server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "messsage": {
	//	    "type": "knowledge-base-request",
	//	    "messages": [
	//	      {
	//	        "role": "user",
	//	        "content": "Why is ocean blue?"
	//	      }
	//	    ],
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// Response Expected:
	// ```
	//
	//	{
	//	  "message": {
	//	     "role": "assistant",
	//	     "content": "The ocean is blue because water absorbs everything but blue.",
	//	  }, // YOU CAN RETURN THE EXACT RESPONSE TO SPEAK
	//	  "documents": [
	//	    {
	//	      "content": "The ocean is blue primarily because water absorbs colors in the red part of the light spectrum and scatters the blue light, making it more visible to our eyes.",
	//	      "similarity": 1
	//	    },
	//	    {
	//	      "content": "Blue light is scattered more by the water molecules than other colors, enhancing the blue appearance of the ocean.",
	//	      "similarity": .5
	//	    }
	//	  ] // OR, YOU CAN RETURN AN ARRAY OF DOCUMENTS THAT WILL BE SENT TO THE MODEL
	//	}
	//
	// ```
	Server   *Server `json:"server,omitempty" url:"server,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCustomKnowledgeBaseDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateCustomKnowledgeBaseDto) Provider() string {
	return c.provider
}

func (c *CreateCustomKnowledgeBaseDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomKnowledgeBaseDto) UnmarshalJSON(data []byte) error {
	type embed CreateCustomKnowledgeBaseDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCustomKnowledgeBaseDto(unmarshaler.embed)
	if unmarshaler.Provider != "custom-knowledge-base" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-knowledge-base", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomKnowledgeBaseDto) MarshalJSON() ([]byte, error) {
	type embed CreateCustomKnowledgeBaseDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-knowledge-base",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCustomKnowledgeBaseDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCustomLlmCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCustomLlmCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateCustomLlmCredentialDto) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if c == nil {
		return nil
	}
	return c.AuthenticationPlan
}

func (c *CreateCustomLlmCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateCustomLlmCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateCustomLlmCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomLlmCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateCustomLlmCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateCustomLlmCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomLlmCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateCustomLlmCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CreateCustomLlmCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeepInfraCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDeepInfraCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateDeepInfraCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateDeepInfraCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateDeepInfraCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeepInfraCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateDeepInfraCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDeepInfraCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "deepinfra", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeepInfraCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateDeepInfraCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDeepInfraCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeepSeekCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDeepSeekCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateDeepSeekCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateDeepSeekCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateDeepSeekCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeepSeekCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateDeepSeekCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDeepSeekCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deep-seek" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "deep-seek", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeepSeekCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateDeepSeekCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "deep-seek",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDeepSeekCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeepgramCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDeepgramCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateDeepgramCredentialDto) GetApiUrl() *string {
	if c == nil {
		return nil
	}
	return c.ApiUrl
}

func (c *CreateDeepgramCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateDeepgramCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateDeepgramCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeepgramCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateDeepgramCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDeepgramCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "deepgram", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeepgramCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateDeepgramCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDeepgramCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDtmfToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateDtmfToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDtmfToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateDtmfToolDto) GetMessages() []*CreateDtmfToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateDtmfToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateDtmfToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateDtmfToolDto) Type() string {
	return c.type_
}

func (c *CreateDtmfToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDtmfToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateDtmfToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateDtmfToolDto(unmarshaler.embed)
	if unmarshaler.Type != "dtmf" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "dtmf", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDtmfToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateDtmfToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "dtmf",
	}
	return json.Marshal(marshaler)
}

func (c *CreateDtmfToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDtmfToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateDtmfToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateDtmfToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateDtmfToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateDtmfToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateDtmfToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateDtmfToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateDtmfToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateDtmfToolDtoMessagesItem) Accept(visitor CreateDtmfToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateElevenLabsCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateElevenLabsCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateElevenLabsCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateElevenLabsCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateElevenLabsCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateElevenLabsCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateElevenLabsCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateElevenLabsCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "11labs", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateElevenLabsCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateElevenLabsCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (c *CreateElevenLabsCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEndCallToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateEndCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateEndCallToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateEndCallToolDto) GetMessages() []*CreateEndCallToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateEndCallToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateEndCallToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateEndCallToolDto) Type() string {
	return c.type_
}

func (c *CreateEndCallToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEndCallToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateEndCallToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateEndCallToolDto(unmarshaler.embed)
	if unmarshaler.Type != "endCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "endCall", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEndCallToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateEndCallToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "endCall",
	}
	return json.Marshal(marshaler)
}

func (c *CreateEndCallToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateEndCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateEndCallToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateEndCallToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateEndCallToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateEndCallToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateEndCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEndCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateEndCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateEndCallToolDtoMessagesItem) Accept(visitor CreateEndCallToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateFunctionToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateFunctionToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateFunctionToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateFunctionToolDto) GetMessages() []*CreateFunctionToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateFunctionToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateFunctionToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateFunctionToolDto) Type() string {
	return c.type_
}

func (c *CreateFunctionToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFunctionToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateFunctionToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateFunctionToolDto(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "function", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateFunctionToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateFunctionToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (c *CreateFunctionToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateFunctionToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateFunctionToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateFunctionToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateFunctionToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateFunctionToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateFunctionToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateFunctionToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateFunctionToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateFunctionToolDtoMessagesItem) Accept(visitor CreateFunctionToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGcpCredentialDto struct {
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGcpCredentialDto) GetGcpKey() *GcpKey {
	if c == nil {
		return nil
	}
	return c.GcpKey
}

func (c *CreateGcpCredentialDto) GetBucketPlan() *BucketPlan {
	if c == nil {
		return nil
	}
	return c.BucketPlan
}

func (c *CreateGcpCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGcpCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGcpCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGcpCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGcpCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGcpCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gcp", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGcpCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGcpCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gcp",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGcpCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGhlToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateGhlToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata *GhlToolMetadata                `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGhlToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateGhlToolDto) GetMessages() []*CreateGhlToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateGhlToolDto) GetMetadata() *GhlToolMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateGhlToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateGhlToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateGhlToolDto) Type() string {
	return c.type_
}

func (c *CreateGhlToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGhlToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateGhlToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGhlToolDto(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "ghl", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGhlToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateGhlToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGhlToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGhlToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateGhlToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateGhlToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateGhlToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateGhlToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateGhlToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateGhlToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGhlToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateGhlToolDtoMessagesItem) Accept(visitor CreateGhlToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateGladiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGladiaCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateGladiaCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGladiaCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGladiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGladiaCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGladiaCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGladiaCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gladia", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGladiaCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGladiaCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gladia",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGladiaCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoHighLevelCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoHighLevelCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateGoHighLevelCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGoHighLevelCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoHighLevelCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoHighLevelCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoHighLevelCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoHighLevelCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "gohighlevel" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "gohighlevel", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoHighLevelCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoHighLevelCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "gohighlevel",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoHighLevelCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGoogleCredentialDto struct {
	// This is the key for Gemini in Google AI Studio. Get it from here: https://aistudio.google.com/app/apikey
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGoogleCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateGoogleCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGoogleCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGoogleCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGoogleCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGoogleCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGoogleCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "google", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGoogleCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGoogleCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "google",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGoogleCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateGroqCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGroqCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateGroqCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateGroqCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateGroqCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGroqCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateGroqCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateGroqCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "groq", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGroqCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateGroqCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "groq",
	}
	return json.Marshal(marshaler)
}

func (c *CreateGroqCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateInflectionAiCredentialDto struct {
	// This is the api key for Pi in InflectionAI's console. Get it from here: https://developers.inflection.ai/keys, billing will need to be setup
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateInflectionAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateInflectionAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateInflectionAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateInflectionAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateInflectionAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateInflectionAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateInflectionAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "inflection-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "inflection-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateInflectionAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateInflectionAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "inflection-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateInflectionAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLangfuseCredentialDto struct {
	// The public key for Langfuse project. Eg: pk-lf-...
	PublicKey string `json:"publicKey" url:"publicKey"`
	// The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// The host URL for Langfuse project. Eg: https://cloud.langfuse.com
	ApiUrl string `json:"apiUrl" url:"apiUrl"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLangfuseCredentialDto) GetPublicKey() string {
	if c == nil {
		return ""
	}
	return c.PublicKey
}

func (c *CreateLangfuseCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateLangfuseCredentialDto) GetApiUrl() string {
	if c == nil {
		return ""
	}
	return c.ApiUrl
}

func (c *CreateLangfuseCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLangfuseCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateLangfuseCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLangfuseCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateLangfuseCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateLangfuseCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "langfuse" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "langfuse", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLangfuseCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateLangfuseCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "langfuse",
	}
	return json.Marshal(marshaler)
}

func (c *CreateLangfuseCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateLmntCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLmntCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateLmntCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateLmntCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateLmntCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLmntCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateLmntCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateLmntCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "lmnt", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLmntCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateLmntCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (c *CreateLmntCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMakeCredentialDto struct {
	// Team ID
	TeamId string `json:"teamId" url:"teamId"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region string `json:"region" url:"region"`
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateMakeCredentialDto) GetTeamId() string {
	if c == nil {
		return ""
	}
	return c.TeamId
}

func (c *CreateMakeCredentialDto) GetRegion() string {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateMakeCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateMakeCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateMakeCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateMakeCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMakeCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateMakeCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateMakeCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "make", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMakeCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateMakeCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "make",
	}
	return json.Marshal(marshaler)
}

func (c *CreateMakeCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMakeToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateMakeToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	Metadata *MakeToolMetadata                `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateMakeToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateMakeToolDto) GetMessages() []*CreateMakeToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateMakeToolDto) GetMetadata() *MakeToolMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateMakeToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateMakeToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateMakeToolDto) Type() string {
	return c.type_
}

func (c *CreateMakeToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMakeToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateMakeToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateMakeToolDto(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "make", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMakeToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateMakeToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (c *CreateMakeToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateMakeToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateMakeToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateMakeToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateMakeToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateMakeToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateMakeToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateMakeToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateMakeToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateMakeToolDtoMessagesItem) Accept(visitor CreateMakeToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateOpenAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOpenAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateOpenAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateOpenAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateOpenAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateOpenAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "openai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOpenAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateOpenAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateOpenAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOpenRouterCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOpenRouterCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateOpenRouterCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateOpenRouterCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateOpenRouterCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOpenRouterCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateOpenRouterCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateOpenRouterCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "openrouter", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOpenRouterCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateOpenRouterCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "openrouter",
	}
	return json.Marshal(marshaler)
}

func (c *CreateOpenRouterCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOrgDto struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the ID of the subscription the org belongs to.
	SubscriptionId *string `json:"subscriptionId,omitempty" url:"subscriptionId,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
	Channel *CreateOrgDtoChannel `json:"channel,omitempty" url:"channel,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOrgDto) GetHipaaEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.HipaaEnabled
}

func (c *CreateOrgDto) GetSubscriptionId() *string {
	if c == nil {
		return nil
	}
	return c.SubscriptionId
}

func (c *CreateOrgDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateOrgDto) GetChannel() *CreateOrgDtoChannel {
	if c == nil {
		return nil
	}
	return c.Channel
}

func (c *CreateOrgDto) GetBillingLimit() *float64 {
	if c == nil {
		return nil
	}
	return c.BillingLimit
}

func (c *CreateOrgDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateOrgDto) GetConcurrencyLimit() *float64 {
	if c == nil {
		return nil
	}
	return c.ConcurrencyLimit
}

func (c *CreateOrgDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrgDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrgDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrgDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrgDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
type CreateOrgDtoChannel string

const (
	CreateOrgDtoChannelDefault CreateOrgDtoChannel = "default"
	CreateOrgDtoChannelWeekly  CreateOrgDtoChannel = "weekly"
)

func NewCreateOrgDtoChannelFromString(s string) (CreateOrgDtoChannel, error) {
	switch s {
	case "default":
		return CreateOrgDtoChannelDefault, nil
	case "weekly":
		return CreateOrgDtoChannelWeekly, nil
	}
	var t CreateOrgDtoChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateOrgDtoChannel) Ptr() *CreateOrgDtoChannel {
	return &c
}

type CreateOutboundCallDto struct {
	// This is the name of the call. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// This is the phone number that will be used for the call. To use a transient number, use `phoneNumber` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneNumberId *string `json:"phoneNumberId,omitempty" url:"phoneNumberId,omitempty"`
	// This is the phone number that will be used for the call. To use an existing number, use `phoneNumberId` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	PhoneNumber *ImportTwilioPhoneNumberDto `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the customer that will be called. To call a transient customer , use `customer` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	CustomerId *string `json:"customerId,omitempty" url:"customerId,omitempty"`
	// This is the customer that will be called. To call an existing customer, use `customerId` instead.
	//
	// Only relevant for `outboundPhoneCall` and `inboundPhoneCall` type.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOutboundCallDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateOutboundCallDto) GetAssistantId() *string {
	if c == nil {
		return nil
	}
	return c.AssistantId
}

func (c *CreateOutboundCallDto) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *CreateOutboundCallDto) GetAssistantOverrides() *AssistantOverrides {
	if c == nil {
		return nil
	}
	return c.AssistantOverrides
}

func (c *CreateOutboundCallDto) GetSquadId() *string {
	if c == nil {
		return nil
	}
	return c.SquadId
}

func (c *CreateOutboundCallDto) GetSquad() *CreateSquadDto {
	if c == nil {
		return nil
	}
	return c.Squad
}

func (c *CreateOutboundCallDto) GetPhoneNumberId() *string {
	if c == nil {
		return nil
	}
	return c.PhoneNumberId
}

func (c *CreateOutboundCallDto) GetPhoneNumber() *ImportTwilioPhoneNumberDto {
	if c == nil {
		return nil
	}
	return c.PhoneNumber
}

func (c *CreateOutboundCallDto) GetCustomerId() *string {
	if c == nil {
		return nil
	}
	return c.CustomerId
}

func (c *CreateOutboundCallDto) GetCustomer() *CreateCustomerDto {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *CreateOutboundCallDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOutboundCallDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOutboundCallDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOutboundCallDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOutboundCallDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreatePerplexityAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreatePerplexityAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreatePerplexityAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreatePerplexityAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreatePerplexityAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePerplexityAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreatePerplexityAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreatePerplexityAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "perplexity-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePerplexityAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreatePerplexityAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreatePerplexityAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreatePlayHtCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	UserId string `json:"userId" url:"userId"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreatePlayHtCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreatePlayHtCredentialDto) GetUserId() string {
	if c == nil {
		return ""
	}
	return c.UserId
}

func (c *CreatePlayHtCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreatePlayHtCredentialDto) Provider() string {
	return c.provider
}

func (c *CreatePlayHtCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePlayHtCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreatePlayHtCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreatePlayHtCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "playht", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePlayHtCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreatePlayHtCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (c *CreatePlayHtCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateRimeAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateRimeAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateRimeAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateRimeAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateRimeAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRimeAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateRimeAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateRimeAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "rime-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRimeAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateRimeAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateRimeAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateRunpodCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateRunpodCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateRunpodCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateRunpodCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateRunpodCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRunpodCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateRunpodCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateRunpodCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "runpod" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "runpod", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRunpodCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateRunpodCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "runpod",
	}
	return json.Marshal(marshaler)
}

func (c *CreateRunpodCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateS3CredentialDto struct {
	// Credential provider. Only allowed value is s3
	// AWS access key ID.
	AwsAccessKeyId string `json:"awsAccessKeyId" url:"awsAccessKeyId"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey string `json:"awsSecretAccessKey" url:"awsSecretAccessKey"`
	// AWS region in which the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// AWS S3 bucket name.
	S3BucketName string `json:"s3BucketName" url:"s3BucketName"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix string `json:"s3PathPrefix" url:"s3PathPrefix"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateS3CredentialDto) GetAwsAccessKeyId() string {
	if c == nil {
		return ""
	}
	return c.AwsAccessKeyId
}

func (c *CreateS3CredentialDto) GetAwsSecretAccessKey() string {
	if c == nil {
		return ""
	}
	return c.AwsSecretAccessKey
}

func (c *CreateS3CredentialDto) GetRegion() string {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateS3CredentialDto) GetS3BucketName() string {
	if c == nil {
		return ""
	}
	return c.S3BucketName
}

func (c *CreateS3CredentialDto) GetS3PathPrefix() string {
	if c == nil {
		return ""
	}
	return c.S3PathPrefix
}

func (c *CreateS3CredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateS3CredentialDto) Provider() string {
	return c.provider
}

func (c *CreateS3CredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateS3CredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateS3CredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateS3CredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "s3" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "s3", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateS3CredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateS3CredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "s3",
	}
	return json.Marshal(marshaler)
}

func (c *CreateS3CredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSmallestAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSmallestAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateSmallestAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateSmallestAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateSmallestAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSmallestAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateSmallestAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateSmallestAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "smallest-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "smallest-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSmallestAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateSmallestAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "smallest-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateSmallestAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateSquadDto struct {
	// This is the name of the squad.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the list of assistants that make up the squad.
	//
	// The call will start with the first assistant in the list.
	Members []*SquadMemberDto `json:"members,omitempty" url:"members,omitempty"`
	// This can be used to override all the assistants' settings and provide values for their template variables.
	//
	// Both `membersOverrides` and `members[n].assistantOverrides` can be used together. First, `members[n].assistantOverrides` is applied. Then, `membersOverrides` is applied as a global override.
	MembersOverrides *AssistantOverrides `json:"membersOverrides,omitempty" url:"membersOverrides,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSquadDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateSquadDto) GetMembers() []*SquadMemberDto {
	if c == nil {
		return nil
	}
	return c.Members
}

func (c *CreateSquadDto) GetMembersOverrides() *AssistantOverrides {
	if c == nil {
		return nil
	}
	return c.MembersOverrides
}

func (c *CreateSquadDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSquadDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateSquadDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateSquadDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSquadDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTavusCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTavusCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateTavusCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTavusCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTavusCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTavusCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTavusCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTavusCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "tavus" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tavus", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTavusCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTavusCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "tavus",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTavusCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTogetherAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTogetherAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateTogetherAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTogetherAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTogetherAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTogetherAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTogetherAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTogetherAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "together-ai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTogetherAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTogetherAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "together-ai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTogetherAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTokenDto struct {
	// This is the tag for the token. It represents its scope.
	Tag *CreateTokenDtoTag `json:"tag,omitempty" url:"tag,omitempty"`
	// This is the name of the token. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This are the restrictions for the token.
	Restrictions *TokenRestrictions `json:"restrictions,omitempty" url:"restrictions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTokenDto) GetTag() *CreateTokenDtoTag {
	if c == nil {
		return nil
	}
	return c.Tag
}

func (c *CreateTokenDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTokenDto) GetRestrictions() *TokenRestrictions {
	if c == nil {
		return nil
	}
	return c.Restrictions
}

func (c *CreateTokenDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTokenDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTokenDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTokenDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTokenDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This is the tag for the token. It represents its scope.
type CreateTokenDtoTag string

const (
	CreateTokenDtoTagPrivate CreateTokenDtoTag = "private"
	CreateTokenDtoTagPublic  CreateTokenDtoTag = "public"
)

func NewCreateTokenDtoTagFromString(s string) (CreateTokenDtoTag, error) {
	switch s {
	case "private":
		return CreateTokenDtoTagPrivate, nil
	case "public":
		return CreateTokenDtoTagPublic, nil
	}
	var t CreateTokenDtoTag
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateTokenDtoTag) Ptr() *CreateTokenDtoTag {
	return &c
}

type CreateToolCallBlockDto struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*CreateToolCallBlockDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// This is the tool that the block will call. To use an existing tool, use `toolId`.
	Tool *CreateToolCallBlockDtoTool `json:"tool,omitempty" url:"tool,omitempty"`
	// This is the id of the tool that the block will call. To use a transient tool, use `tool`.
	ToolId *string `json:"toolId,omitempty" url:"toolId,omitempty"`
	// This is the name of the block. This is just for your reference.
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateToolCallBlockDto) GetMessages() []*CreateToolCallBlockDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateToolCallBlockDto) GetInputSchema() *JsonSchema {
	if c == nil {
		return nil
	}
	return c.InputSchema
}

func (c *CreateToolCallBlockDto) GetOutputSchema() *JsonSchema {
	if c == nil {
		return nil
	}
	return c.OutputSchema
}

func (c *CreateToolCallBlockDto) GetTool() *CreateToolCallBlockDtoTool {
	if c == nil {
		return nil
	}
	return c.Tool
}

func (c *CreateToolCallBlockDto) GetToolId() *string {
	if c == nil {
		return nil
	}
	return c.ToolId
}

func (c *CreateToolCallBlockDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateToolCallBlockDto) Type() string {
	return c.type_
}

func (c *CreateToolCallBlockDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateToolCallBlockDto) UnmarshalJSON(data []byte) error {
	type embed CreateToolCallBlockDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateToolCallBlockDto(unmarshaler.embed)
	if unmarshaler.Type != "tool-call" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool-call", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateToolCallBlockDto) MarshalJSON() ([]byte, error) {
	type embed CreateToolCallBlockDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "tool-call",
	}
	return json.Marshal(marshaler)
}

func (c *CreateToolCallBlockDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateToolCallBlockDtoMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage

	typ string
}

func (c *CreateToolCallBlockDtoMessagesItem) GetBlockStartMessage() *BlockStartMessage {
	if c == nil {
		return nil
	}
	return c.BlockStartMessage
}

func (c *CreateToolCallBlockDtoMessagesItem) GetBlockCompleteMessage() *BlockCompleteMessage {
	if c == nil {
		return nil
	}
	return c.BlockCompleteMessage
}

func (c *CreateToolCallBlockDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		c.typ = "BlockStartMessage"
		c.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		c.typ = "BlockCompleteMessage"
		c.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolCallBlockDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "BlockStartMessage" || c.BlockStartMessage != nil {
		return json.Marshal(c.BlockStartMessage)
	}
	if c.typ == "BlockCompleteMessage" || c.BlockCompleteMessage != nil {
		return json.Marshal(c.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolCallBlockDtoMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (c *CreateToolCallBlockDtoMessagesItem) Accept(visitor CreateToolCallBlockDtoMessagesItemVisitor) error {
	if c.typ == "BlockStartMessage" || c.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(c.BlockStartMessage)
	}
	if c.typ == "BlockCompleteMessage" || c.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(c.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// This is the tool that the block will call. To use an existing tool, use `toolId`.
type CreateToolCallBlockDtoTool struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (c *CreateToolCallBlockDtoTool) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if c == nil {
		return nil
	}
	return c.CreateDtmfToolDto
}

func (c *CreateToolCallBlockDtoTool) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateEndCallToolDto
}

func (c *CreateToolCallBlockDtoTool) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if c == nil {
		return nil
	}
	return c.CreateVoicemailToolDto
}

func (c *CreateToolCallBlockDtoTool) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if c == nil {
		return nil
	}
	return c.CreateFunctionToolDto
}

func (c *CreateToolCallBlockDtoTool) GetCreateGhlToolDto() *CreateGhlToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGhlToolDto
}

func (c *CreateToolCallBlockDtoTool) GetCreateMakeToolDto() *CreateMakeToolDto {
	if c == nil {
		return nil
	}
	return c.CreateMakeToolDto
}

func (c *CreateToolCallBlockDtoTool) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTransferCallToolDto
}

func (c *CreateToolCallBlockDtoTool) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.typ = "CreateDtmfToolDto"
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.typ = "CreateEndCallToolDto"
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		c.typ = "CreateVoicemailToolDto"
		c.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.typ = "CreateFunctionToolDto"
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		c.typ = "CreateGhlToolDto"
		c.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		c.typ = "CreateMakeToolDto"
		c.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.typ = "CreateTransferCallToolDto"
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolCallBlockDtoTool) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateVoicemailToolDto" || c.CreateVoicemailToolDto != nil {
		return json.Marshal(c.CreateVoicemailToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGhlToolDto" || c.CreateGhlToolDto != nil {
		return json.Marshal(c.CreateGhlToolDto)
	}
	if c.typ == "CreateMakeToolDto" || c.CreateMakeToolDto != nil {
		return json.Marshal(c.CreateMakeToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolCallBlockDtoToolVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CreateToolCallBlockDtoTool) Accept(visitor CreateToolCallBlockDtoToolVisitor) error {
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateVoicemailToolDto" || c.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(c.CreateVoicemailToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGhlToolDto" || c.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(c.CreateGhlToolDto)
	}
	if c.typ == "CreateMakeToolDto" || c.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(c.CreateMakeToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDto struct {
	Details         *CreateToolTemplateDtoDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *CreateToolTemplateDtoProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata                 `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *CreateToolTemplateDtoVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string                        `json:"name,omitempty" url:"name,omitempty"`
	Provider *CreateToolTemplateDtoProvider `json:"provider,omitempty" url:"provider,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateToolTemplateDto) GetDetails() *CreateToolTemplateDtoDetails {
	if c == nil {
		return nil
	}
	return c.Details
}

func (c *CreateToolTemplateDto) GetProviderDetails() *CreateToolTemplateDtoProviderDetails {
	if c == nil {
		return nil
	}
	return c.ProviderDetails
}

func (c *CreateToolTemplateDto) GetMetadata() *ToolTemplateMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateToolTemplateDto) GetVisibility() *CreateToolTemplateDtoVisibility {
	if c == nil {
		return nil
	}
	return c.Visibility
}

func (c *CreateToolTemplateDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateToolTemplateDto) GetProvider() *CreateToolTemplateDtoProvider {
	if c == nil {
		return nil
	}
	return c.Provider
}

func (c *CreateToolTemplateDto) Type() string {
	return c.type_
}

func (c *CreateToolTemplateDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateToolTemplateDto) UnmarshalJSON(data []byte) error {
	type embed CreateToolTemplateDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateToolTemplateDto(unmarshaler.embed)
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "tool", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateToolTemplateDto) MarshalJSON() ([]byte, error) {
	type embed CreateToolTemplateDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "tool",
	}
	return json.Marshal(marshaler)
}

func (c *CreateToolTemplateDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateToolTemplateDtoDetails struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (c *CreateToolTemplateDtoDetails) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if c == nil {
		return nil
	}
	return c.CreateDtmfToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateEndCallToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if c == nil {
		return nil
	}
	return c.CreateVoicemailToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if c == nil {
		return nil
	}
	return c.CreateFunctionToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateGhlToolDto() *CreateGhlToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGhlToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateMakeToolDto() *CreateMakeToolDto {
	if c == nil {
		return nil
	}
	return c.CreateMakeToolDto
}

func (c *CreateToolTemplateDtoDetails) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTransferCallToolDto
}

func (c *CreateToolTemplateDtoDetails) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.typ = "CreateDtmfToolDto"
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.typ = "CreateEndCallToolDto"
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		c.typ = "CreateVoicemailToolDto"
		c.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.typ = "CreateFunctionToolDto"
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		c.typ = "CreateGhlToolDto"
		c.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		c.typ = "CreateMakeToolDto"
		c.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.typ = "CreateTransferCallToolDto"
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolTemplateDtoDetails) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateVoicemailToolDto" || c.CreateVoicemailToolDto != nil {
		return json.Marshal(c.CreateVoicemailToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGhlToolDto" || c.CreateGhlToolDto != nil {
		return json.Marshal(c.CreateGhlToolDto)
	}
	if c.typ == "CreateMakeToolDto" || c.CreateMakeToolDto != nil {
		return json.Marshal(c.CreateMakeToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoDetailsVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CreateToolTemplateDtoDetails) Accept(visitor CreateToolTemplateDtoDetailsVisitor) error {
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateVoicemailToolDto" || c.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(c.CreateVoicemailToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGhlToolDto" || c.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(c.CreateGhlToolDto)
	}
	if c.typ == "CreateMakeToolDto" || c.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(c.CreateMakeToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoProvider string

const (
	CreateToolTemplateDtoProviderMake        CreateToolTemplateDtoProvider = "make"
	CreateToolTemplateDtoProviderGohighlevel CreateToolTemplateDtoProvider = "gohighlevel"
	CreateToolTemplateDtoProviderFunction    CreateToolTemplateDtoProvider = "function"
)

func NewCreateToolTemplateDtoProviderFromString(s string) (CreateToolTemplateDtoProvider, error) {
	switch s {
	case "make":
		return CreateToolTemplateDtoProviderMake, nil
	case "gohighlevel":
		return CreateToolTemplateDtoProviderGohighlevel, nil
	case "function":
		return CreateToolTemplateDtoProviderFunction, nil
	}
	var t CreateToolTemplateDtoProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateToolTemplateDtoProvider) Ptr() *CreateToolTemplateDtoProvider {
	return &c
}

type CreateToolTemplateDtoProviderDetails struct {
	MakeToolProviderDetails     *MakeToolProviderDetails
	GhlToolProviderDetails      *GhlToolProviderDetails
	FunctionToolProviderDetails *FunctionToolProviderDetails

	typ string
}

func (c *CreateToolTemplateDtoProviderDetails) GetMakeToolProviderDetails() *MakeToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.MakeToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetGhlToolProviderDetails() *GhlToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.GhlToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) GetFunctionToolProviderDetails() *FunctionToolProviderDetails {
	if c == nil {
		return nil
	}
	return c.FunctionToolProviderDetails
}

func (c *CreateToolTemplateDtoProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		c.typ = "MakeToolProviderDetails"
		c.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		c.typ = "GhlToolProviderDetails"
		c.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		c.typ = "FunctionToolProviderDetails"
		c.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateToolTemplateDtoProviderDetails) MarshalJSON() ([]byte, error) {
	if c.typ == "MakeToolProviderDetails" || c.MakeToolProviderDetails != nil {
		return json.Marshal(c.MakeToolProviderDetails)
	}
	if c.typ == "GhlToolProviderDetails" || c.GhlToolProviderDetails != nil {
		return json.Marshal(c.GhlToolProviderDetails)
	}
	if c.typ == "FunctionToolProviderDetails" || c.FunctionToolProviderDetails != nil {
		return json.Marshal(c.FunctionToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
}

func (c *CreateToolTemplateDtoProviderDetails) Accept(visitor CreateToolTemplateDtoProviderDetailsVisitor) error {
	if c.typ == "MakeToolProviderDetails" || c.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(c.MakeToolProviderDetails)
	}
	if c.typ == "GhlToolProviderDetails" || c.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(c.GhlToolProviderDetails)
	}
	if c.typ == "FunctionToolProviderDetails" || c.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(c.FunctionToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateToolTemplateDtoVisibility string

const (
	CreateToolTemplateDtoVisibilityPublic  CreateToolTemplateDtoVisibility = "public"
	CreateToolTemplateDtoVisibilityPrivate CreateToolTemplateDtoVisibility = "private"
)

func NewCreateToolTemplateDtoVisibilityFromString(s string) (CreateToolTemplateDtoVisibility, error) {
	switch s {
	case "public":
		return CreateToolTemplateDtoVisibilityPublic, nil
	case "private":
		return CreateToolTemplateDtoVisibilityPrivate, nil
	}
	var t CreateToolTemplateDtoVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateToolTemplateDtoVisibility) Ptr() *CreateToolTemplateDtoVisibility {
	return &c
}

type CreateTransferCallToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateTransferCallToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
	Destinations []*CreateTransferCallToolDtoDestinationsItem `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTransferCallToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateTransferCallToolDto) GetMessages() []*CreateTransferCallToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateTransferCallToolDto) GetDestinations() []*CreateTransferCallToolDtoDestinationsItem {
	if c == nil {
		return nil
	}
	return c.Destinations
}

func (c *CreateTransferCallToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateTransferCallToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateTransferCallToolDto) Type() string {
	return c.type_
}

func (c *CreateTransferCallToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTransferCallToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateTransferCallToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTransferCallToolDto(unmarshaler.embed)
	if unmarshaler.Type != "transferCall" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "transferCall", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTransferCallToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateTransferCallToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "transferCall",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTransferCallToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTransferCallToolDtoDestinationsItem struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationStep      *TransferDestinationStep
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (c *CreateTransferCallToolDtoDestinationsItem) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if c == nil {
		return nil
	}
	return c.TransferDestinationAssistant
}

func (c *CreateTransferCallToolDtoDestinationsItem) GetTransferDestinationStep() *TransferDestinationStep {
	if c == nil {
		return nil
	}
	return c.TransferDestinationStep
}

func (c *CreateTransferCallToolDtoDestinationsItem) GetTransferDestinationNumber() *TransferDestinationNumber {
	if c == nil {
		return nil
	}
	return c.TransferDestinationNumber
}

func (c *CreateTransferCallToolDtoDestinationsItem) GetTransferDestinationSip() *TransferDestinationSip {
	if c == nil {
		return nil
	}
	return c.TransferDestinationSip
}

func (c *CreateTransferCallToolDtoDestinationsItem) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		c.typ = "TransferDestinationAssistant"
		c.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationStep := new(TransferDestinationStep)
	if err := json.Unmarshal(data, &valueTransferDestinationStep); err == nil {
		c.typ = "TransferDestinationStep"
		c.TransferDestinationStep = valueTransferDestinationStep
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		c.typ = "TransferDestinationNumber"
		c.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		c.typ = "TransferDestinationSip"
		c.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTransferCallToolDtoDestinationsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "TransferDestinationAssistant" || c.TransferDestinationAssistant != nil {
		return json.Marshal(c.TransferDestinationAssistant)
	}
	if c.typ == "TransferDestinationStep" || c.TransferDestinationStep != nil {
		return json.Marshal(c.TransferDestinationStep)
	}
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return json.Marshal(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return json.Marshal(c.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoDestinationsItemVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationStep(*TransferDestinationStep) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (c *CreateTransferCallToolDtoDestinationsItem) Accept(visitor CreateTransferCallToolDtoDestinationsItemVisitor) error {
	if c.typ == "TransferDestinationAssistant" || c.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(c.TransferDestinationAssistant)
	}
	if c.typ == "TransferDestinationStep" || c.TransferDestinationStep != nil {
		return visitor.VisitTransferDestinationStep(c.TransferDestinationStep)
	}
	if c.typ == "TransferDestinationNumber" || c.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(c.TransferDestinationNumber)
	}
	if c.typ == "TransferDestinationSip" || c.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(c.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateTransferCallToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateTransferCallToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateTransferCallToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateTransferCallToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateTransferCallToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTransferCallToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTransferCallToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateTransferCallToolDtoMessagesItem) Accept(visitor CreateTransferCallToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateTwilioCredentialDto struct {
	// This is not returned in the API.
	AuthToken  string `json:"authToken" url:"authToken"`
	AccountSid string `json:"accountSid" url:"accountSid"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTwilioCredentialDto) GetAuthToken() string {
	if c == nil {
		return ""
	}
	return c.AuthToken
}

func (c *CreateTwilioCredentialDto) GetAccountSid() string {
	if c == nil {
		return ""
	}
	return c.AccountSid
}

func (c *CreateTwilioCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateTwilioCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateTwilioCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTwilioCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateTwilioCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateTwilioCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "twilio", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTwilioCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateTwilioCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (c *CreateTwilioCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateVoicemailToolDto struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*CreateVoicemailToolDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "voicemail". This uses the model itself to determine if a voicemil was reached. Can be used alternatively/alongside with TwilioVoicemailDetection
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateVoicemailToolDto) GetAsync() *bool {
	if c == nil {
		return nil
	}
	return c.Async
}

func (c *CreateVoicemailToolDto) GetMessages() []*CreateVoicemailToolDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateVoicemailToolDto) GetFunction() *OpenAiFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *CreateVoicemailToolDto) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CreateVoicemailToolDto) Type() string {
	return c.type_
}

func (c *CreateVoicemailToolDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVoicemailToolDto) UnmarshalJSON(data []byte) error {
	type embed CreateVoicemailToolDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateVoicemailToolDto(unmarshaler.embed)
	if unmarshaler.Type != "voicemail" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "voicemail", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVoicemailToolDto) MarshalJSON() ([]byte, error) {
	type embed CreateVoicemailToolDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "voicemail",
	}
	return json.Marshal(marshaler)
}

func (c *CreateVoicemailToolDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateVoicemailToolDtoMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (c *CreateVoicemailToolDtoMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if c == nil {
		return nil
	}
	return c.ToolMessageStart
}

func (c *CreateVoicemailToolDtoMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if c == nil {
		return nil
	}
	return c.ToolMessageComplete
}

func (c *CreateVoicemailToolDtoMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if c == nil {
		return nil
	}
	return c.ToolMessageFailed
}

func (c *CreateVoicemailToolDtoMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if c == nil {
		return nil
	}
	return c.ToolMessageDelayed
}

func (c *CreateVoicemailToolDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		c.typ = "ToolMessageStart"
		c.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		c.typ = "ToolMessageComplete"
		c.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		c.typ = "ToolMessageFailed"
		c.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		c.typ = "ToolMessageDelayed"
		c.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateVoicemailToolDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return json.Marshal(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return json.Marshal(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return json.Marshal(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return json.Marshal(c.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVoicemailToolDtoMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (c *CreateVoicemailToolDtoMessagesItem) Accept(visitor CreateVoicemailToolDtoMessagesItemVisitor) error {
	if c.typ == "ToolMessageStart" || c.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(c.ToolMessageStart)
	}
	if c.typ == "ToolMessageComplete" || c.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(c.ToolMessageComplete)
	}
	if c.typ == "ToolMessageFailed" || c.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(c.ToolMessageFailed)
	}
	if c.typ == "ToolMessageDelayed" || c.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(c.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateVonageCredentialDto struct {
	// This is not returned in the API.
	ApiSecret string `json:"apiSecret" url:"apiSecret"`
	ApiKey    string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateVonageCredentialDto) GetApiSecret() string {
	if c == nil {
		return ""
	}
	return c.ApiSecret
}

func (c *CreateVonageCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateVonageCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateVonageCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateVonageCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVonageCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateVonageCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateVonageCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "vonage", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVonageCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateVonageCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "vonage",
	}
	return json.Marshal(marshaler)
}

func (c *CreateVonageCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWebCallDto struct {
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateWebCallDto) GetAssistantId() *string {
	if c == nil {
		return nil
	}
	return c.AssistantId
}

func (c *CreateWebCallDto) GetAssistant() *CreateAssistantDto {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *CreateWebCallDto) GetAssistantOverrides() *AssistantOverrides {
	if c == nil {
		return nil
	}
	return c.AssistantOverrides
}

func (c *CreateWebCallDto) GetSquadId() *string {
	if c == nil {
		return nil
	}
	return c.SquadId
}

func (c *CreateWebCallDto) GetSquad() *CreateSquadDto {
	if c == nil {
		return nil
	}
	return c.Squad
}

func (c *CreateWebCallDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWebCallDto) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateWebCallDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateWebCallDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWebCallDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWebhookCredentialDto struct {
	// This is the authentication plan. Currently supports OAuth2 RFC 6749.
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateWebhookCredentialDto) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if c == nil {
		return nil
	}
	return c.AuthenticationPlan
}

func (c *CreateWebhookCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateWebhookCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateWebhookCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWebhookCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateWebhookCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateWebhookCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "webhook" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "webhook", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWebhookCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateWebhookCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "webhook",
	}
	return json.Marshal(marshaler)
}

func (c *CreateWebhookCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWorkflowBlockDto struct {
	// These are the pre-configured messages that will be spoken to the user while the block is running.
	Messages []*CreateWorkflowBlockDtoMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the input schema for the block. This is the input the block needs to run. It's given to the block as `steps[0].input`
	//
	// These are accessible as variables:
	// - ({{input.propertyName}}) in context of the block execution (step)
	// - ({{stepName.input.propertyName}}) in context of the workflow
	InputSchema *JsonSchema `json:"inputSchema,omitempty" url:"inputSchema,omitempty"`
	// This is the output schema for the block. This is the output the block will return to the workflow (`{{stepName.output}}`).
	//
	// These are accessible as variables:
	// - ({{output.propertyName}}) in context of the block execution (step)
	// - ({{stepName.output.propertyName}}) in context of the workflow (read caveat #1)
	// - ({{blockName.output.propertyName}}) in context of the workflow (read caveat #2)
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	OutputSchema *JsonSchema `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	// These are the steps in the workflow.
	Steps []*CreateWorkflowBlockDtoStepsItem `json:"steps,omitempty" url:"steps,omitempty"`
	// This is the name of the block. This is just for your reference.
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateWorkflowBlockDto) GetMessages() []*CreateWorkflowBlockDtoMessagesItem {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CreateWorkflowBlockDto) GetInputSchema() *JsonSchema {
	if c == nil {
		return nil
	}
	return c.InputSchema
}

func (c *CreateWorkflowBlockDto) GetOutputSchema() *JsonSchema {
	if c == nil {
		return nil
	}
	return c.OutputSchema
}

func (c *CreateWorkflowBlockDto) GetSteps() []*CreateWorkflowBlockDtoStepsItem {
	if c == nil {
		return nil
	}
	return c.Steps
}

func (c *CreateWorkflowBlockDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateWorkflowBlockDto) Type() string {
	return c.type_
}

func (c *CreateWorkflowBlockDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWorkflowBlockDto) UnmarshalJSON(data []byte) error {
	type embed CreateWorkflowBlockDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateWorkflowBlockDto(unmarshaler.embed)
	if unmarshaler.Type != "workflow" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "workflow", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWorkflowBlockDto) MarshalJSON() ([]byte, error) {
	type embed CreateWorkflowBlockDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "workflow",
	}
	return json.Marshal(marshaler)
}

func (c *CreateWorkflowBlockDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateWorkflowBlockDtoMessagesItem struct {
	BlockStartMessage    *BlockStartMessage
	BlockCompleteMessage *BlockCompleteMessage

	typ string
}

func (c *CreateWorkflowBlockDtoMessagesItem) GetBlockStartMessage() *BlockStartMessage {
	if c == nil {
		return nil
	}
	return c.BlockStartMessage
}

func (c *CreateWorkflowBlockDtoMessagesItem) GetBlockCompleteMessage() *BlockCompleteMessage {
	if c == nil {
		return nil
	}
	return c.BlockCompleteMessage
}

func (c *CreateWorkflowBlockDtoMessagesItem) UnmarshalJSON(data []byte) error {
	valueBlockStartMessage := new(BlockStartMessage)
	if err := json.Unmarshal(data, &valueBlockStartMessage); err == nil {
		c.typ = "BlockStartMessage"
		c.BlockStartMessage = valueBlockStartMessage
		return nil
	}
	valueBlockCompleteMessage := new(BlockCompleteMessage)
	if err := json.Unmarshal(data, &valueBlockCompleteMessage); err == nil {
		c.typ = "BlockCompleteMessage"
		c.BlockCompleteMessage = valueBlockCompleteMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateWorkflowBlockDtoMessagesItem) MarshalJSON() ([]byte, error) {
	if c.typ == "BlockStartMessage" || c.BlockStartMessage != nil {
		return json.Marshal(c.BlockStartMessage)
	}
	if c.typ == "BlockCompleteMessage" || c.BlockCompleteMessage != nil {
		return json.Marshal(c.BlockCompleteMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowBlockDtoMessagesItemVisitor interface {
	VisitBlockStartMessage(*BlockStartMessage) error
	VisitBlockCompleteMessage(*BlockCompleteMessage) error
}

func (c *CreateWorkflowBlockDtoMessagesItem) Accept(visitor CreateWorkflowBlockDtoMessagesItemVisitor) error {
	if c.typ == "BlockStartMessage" || c.BlockStartMessage != nil {
		return visitor.VisitBlockStartMessage(c.BlockStartMessage)
	}
	if c.typ == "BlockCompleteMessage" || c.BlockCompleteMessage != nil {
		return visitor.VisitBlockCompleteMessage(c.BlockCompleteMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowBlockDtoStepsItem struct {
	HandoffStep  *HandoffStep
	CallbackStep *CallbackStep

	typ string
}

func (c *CreateWorkflowBlockDtoStepsItem) GetHandoffStep() *HandoffStep {
	if c == nil {
		return nil
	}
	return c.HandoffStep
}

func (c *CreateWorkflowBlockDtoStepsItem) GetCallbackStep() *CallbackStep {
	if c == nil {
		return nil
	}
	return c.CallbackStep
}

func (c *CreateWorkflowBlockDtoStepsItem) UnmarshalJSON(data []byte) error {
	valueHandoffStep := new(HandoffStep)
	if err := json.Unmarshal(data, &valueHandoffStep); err == nil {
		c.typ = "HandoffStep"
		c.HandoffStep = valueHandoffStep
		return nil
	}
	valueCallbackStep := new(CallbackStep)
	if err := json.Unmarshal(data, &valueCallbackStep); err == nil {
		c.typ = "CallbackStep"
		c.CallbackStep = valueCallbackStep
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateWorkflowBlockDtoStepsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "HandoffStep" || c.HandoffStep != nil {
		return json.Marshal(c.HandoffStep)
	}
	if c.typ == "CallbackStep" || c.CallbackStep != nil {
		return json.Marshal(c.CallbackStep)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateWorkflowBlockDtoStepsItemVisitor interface {
	VisitHandoffStep(*HandoffStep) error
	VisitCallbackStep(*CallbackStep) error
}

func (c *CreateWorkflowBlockDtoStepsItem) Accept(visitor CreateWorkflowBlockDtoStepsItemVisitor) error {
	if c.typ == "HandoffStep" || c.HandoffStep != nil {
		return visitor.VisitHandoffStep(c.HandoffStep)
	}
	if c.typ == "CallbackStep" || c.CallbackStep != nil {
		return visitor.VisitCallbackStep(c.CallbackStep)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CreateXAiCredentialDto struct {
	// This is the api key for Grok in XAi's console. Get it from here: https://console.x.ai
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateXAiCredentialDto) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CreateXAiCredentialDto) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateXAiCredentialDto) Provider() string {
	return c.provider
}

func (c *CreateXAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateXAiCredentialDto) UnmarshalJSON(data []byte) error {
	type embed CreateXAiCredentialDto
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateXAiCredentialDto(unmarshaler.embed)
	if unmarshaler.Provider != "xai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "xai", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateXAiCredentialDto) MarshalJSON() ([]byte, error) {
	type embed CreateXAiCredentialDto
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "xai",
	}
	return json.Marshal(marshaler)
}

func (c *CreateXAiCredentialDto) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomLlmCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the authentication session for the credential. Available for credentials that have an authentication plan.
	AuthenticationSession *Oauth2AuthenticationSession `json:"authenticationSession,omitempty" url:"authenticationSession,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomLlmCredential) GetApiKey() string {
	if c == nil {
		return ""
	}
	return c.ApiKey
}

func (c *CustomLlmCredential) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if c == nil {
		return nil
	}
	return c.AuthenticationPlan
}

func (c *CustomLlmCredential) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *CustomLlmCredential) GetOrgId() string {
	if c == nil {
		return ""
	}
	return c.OrgId
}

func (c *CustomLlmCredential) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CustomLlmCredential) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CustomLlmCredential) GetAuthenticationSession() *Oauth2AuthenticationSession {
	if c == nil {
		return nil
	}
	return c.AuthenticationSession
}

func (c *CustomLlmCredential) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CustomLlmCredential) Provider() string {
	return c.provider
}

func (c *CustomLlmCredential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLlmCredential) UnmarshalJSON(data []byte) error {
	type embed CustomLlmCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomLlmCredential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomLlmCredential) MarshalJSON() ([]byte, error) {
	type embed CustomLlmCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
		Provider:  "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CustomLlmCredential) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomLlmModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*CustomLlmModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the provider that will be used for the model. Any service, including your own server, that is compatible with the OpenAI API can be used.
	// This determines whether metadata is sent in requests to the custom provider.
	//
	// - `off` will not send any metadata. payload will look like `{ messages }`
	// - `variable` will send `assistant.metadata` as a variable on the payload. payload will look like `{ messages, metadata }`
	// - `destructured` will send `assistant.metadata` fields directly on the payload. payload will look like `{ messages, ...metadata }`
	//
	// Further, `variable` and `destructured` will send `call`, `phoneNumber`, and `customer` objects in the payload.
	//
	// Default is `variable`.
	MetadataSendMode *CustomLlmModelMetadataSendMode `json:"metadataSendMode,omitempty" url:"metadataSendMode,omitempty"`
	// These is the URL we'll use for the OpenAI client's `baseURL`. Ex. https://openrouter.ai/api/v1
	Url string `json:"url" url:"url"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomLlmModel) GetMessages() []*OpenAiMessage {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *CustomLlmModel) GetTools() []*CustomLlmModelToolsItem {
	if c == nil {
		return nil
	}
	return c.Tools
}

func (c *CustomLlmModel) GetToolIds() []string {
	if c == nil {
		return nil
	}
	return c.ToolIds
}

func (c *CustomLlmModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if c == nil {
		return nil
	}
	return c.KnowledgeBase
}

func (c *CustomLlmModel) GetKnowledgeBaseId() *string {
	if c == nil {
		return nil
	}
	return c.KnowledgeBaseId
}

func (c *CustomLlmModel) GetMetadataSendMode() *CustomLlmModelMetadataSendMode {
	if c == nil {
		return nil
	}
	return c.MetadataSendMode
}

func (c *CustomLlmModel) GetUrl() string {
	if c == nil {
		return ""
	}
	return c.Url
}

func (c *CustomLlmModel) GetModel() string {
	if c == nil {
		return ""
	}
	return c.Model
}

func (c *CustomLlmModel) GetTemperature() *float64 {
	if c == nil {
		return nil
	}
	return c.Temperature
}

func (c *CustomLlmModel) GetMaxTokens() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxTokens
}

func (c *CustomLlmModel) GetEmotionRecognitionEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.EmotionRecognitionEnabled
}

func (c *CustomLlmModel) GetNumFastTurns() *float64 {
	if c == nil {
		return nil
	}
	return c.NumFastTurns
}

func (c *CustomLlmModel) Provider() string {
	return c.provider
}

func (c *CustomLlmModel) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLlmModel) UnmarshalJSON(data []byte) error {
	type embed CustomLlmModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomLlmModel(unmarshaler.embed)
	if unmarshaler.Provider != "custom-llm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-llm", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomLlmModel) MarshalJSON() ([]byte, error) {
	type embed CustomLlmModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-llm",
	}
	return json.Marshal(marshaler)
}

func (c *CustomLlmModel) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// This determines whether metadata is sent in requests to the custom provider.
//
// - `off` will not send any metadata. payload will look like `{ messages }`
// - `variable` will send `assistant.metadata` as a variable on the payload. payload will look like `{ messages, metadata }`
// - `destructured` will send `assistant.metadata` fields directly on the payload. payload will look like `{ messages, ...metadata }`
//
// Further, `variable` and `destructured` will send `call`, `phoneNumber`, and `customer` objects in the payload.
//
// Default is `variable`.
type CustomLlmModelMetadataSendMode string

const (
	CustomLlmModelMetadataSendModeOff          CustomLlmModelMetadataSendMode = "off"
	CustomLlmModelMetadataSendModeVariable     CustomLlmModelMetadataSendMode = "variable"
	CustomLlmModelMetadataSendModeDestructured CustomLlmModelMetadataSendMode = "destructured"
)

func NewCustomLlmModelMetadataSendModeFromString(s string) (CustomLlmModelMetadataSendMode, error) {
	switch s {
	case "off":
		return CustomLlmModelMetadataSendModeOff, nil
	case "variable":
		return CustomLlmModelMetadataSendModeVariable, nil
	case "destructured":
		return CustomLlmModelMetadataSendModeDestructured, nil
	}
	var t CustomLlmModelMetadataSendMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomLlmModelMetadataSendMode) Ptr() *CustomLlmModelMetadataSendMode {
	return &c
}

type CustomLlmModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (c *CustomLlmModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if c == nil {
		return nil
	}
	return c.CreateDtmfToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateEndCallToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if c == nil {
		return nil
	}
	return c.CreateVoicemailToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if c == nil {
		return nil
	}
	return c.CreateFunctionToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if c == nil {
		return nil
	}
	return c.CreateGhlToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if c == nil {
		return nil
	}
	return c.CreateMakeToolDto
}

func (c *CustomLlmModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if c == nil {
		return nil
	}
	return c.CreateTransferCallToolDto
}

func (c *CustomLlmModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		c.typ = "CreateDtmfToolDto"
		c.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		c.typ = "CreateEndCallToolDto"
		c.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		c.typ = "CreateVoicemailToolDto"
		c.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		c.typ = "CreateFunctionToolDto"
		c.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		c.typ = "CreateGhlToolDto"
		c.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		c.typ = "CreateMakeToolDto"
		c.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		c.typ = "CreateTransferCallToolDto"
		c.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CustomLlmModelToolsItem) MarshalJSON() ([]byte, error) {
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return json.Marshal(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return json.Marshal(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateVoicemailToolDto" || c.CreateVoicemailToolDto != nil {
		return json.Marshal(c.CreateVoicemailToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return json.Marshal(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGhlToolDto" || c.CreateGhlToolDto != nil {
		return json.Marshal(c.CreateGhlToolDto)
	}
	if c.typ == "CreateMakeToolDto" || c.CreateMakeToolDto != nil {
		return json.Marshal(c.CreateMakeToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return json.Marshal(c.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CustomLlmModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (c *CustomLlmModelToolsItem) Accept(visitor CustomLlmModelToolsItemVisitor) error {
	if c.typ == "CreateDtmfToolDto" || c.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(c.CreateDtmfToolDto)
	}
	if c.typ == "CreateEndCallToolDto" || c.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(c.CreateEndCallToolDto)
	}
	if c.typ == "CreateVoicemailToolDto" || c.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(c.CreateVoicemailToolDto)
	}
	if c.typ == "CreateFunctionToolDto" || c.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(c.CreateFunctionToolDto)
	}
	if c.typ == "CreateGhlToolDto" || c.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(c.CreateGhlToolDto)
	}
	if c.typ == "CreateMakeToolDto" || c.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(c.CreateMakeToolDto)
	}
	if c.typ == "CreateTransferCallToolDto" || c.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(c.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CustomMessage struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This is a custom message.
	// This is the content that the assistant will say when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomMessage) GetContents() []*TextContent {
	if c == nil {
		return nil
	}
	return c.Contents
}

func (c *CustomMessage) GetContent() *string {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *CustomMessage) Type() string {
	return c.type_
}

func (c *CustomMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomMessage) UnmarshalJSON(data []byte) error {
	type embed CustomMessage
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomMessage(unmarshaler.embed)
	if unmarshaler.Type != "custom-message" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-message", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomMessage) MarshalJSON() ([]byte, error) {
	type embed CustomMessage
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "custom-message",
	}
	return json.Marshal(marshaler)
}

func (c *CustomMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomTranscriber struct {
	// This is the transcription provider that will be used. Use `custom-transcriber` for providers that are not natively supported.
	// This is where the transcription request will be sent.
	//
	// Usage:
	// 1. Vapi will initiate a websocket connection with `server.url`.
	//
	// 2. Vapi will send an initial text frame with the sample rate. Format:
	// ```
	//
	//	{
	//	  "type": "start",
	//	  "encoding": "linear16", // 16-bit raw PCM format
	//	  "container": "raw",
	//	  "sampleRate": {{sampleRate}},
	//	  "channels": 2 // customer is channel 0, assistant is channel 1
	//	}
	//
	// ```
	//
	// 3. Vapi will send the audio data in 16-bit raw PCM format as binary frames.
	//
	// 4. You can read the messages something like this:
	// ```
	//
	//	ws.on('message', (data, isBinary) => {
	//	  if (isBinary) {
	//	    pcmBuffer = Buffer.concat([pcmBuffer, data]);
	//	    console.log(`Received PCM data, buffer size: ${pcmBuffer.length}`);
	//	  } else {
	//	    console.log('Received message:', JSON.parse(data.toString()));
	//	  }
	//	});
	//
	// ```
	//
	// 5. You will respond with transcriptions as you have them. Format:
	// ```
	//
	//	{
	//	   "type": "transcriber-response",
	//	   "transcription": "Hello, world!",
	//	   "channel": "customer" | "assistant"
	//	}
	//
	// ```
	Server   *Server `json:"server,omitempty" url:"server,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomTranscriber) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CustomTranscriber) Provider() string {
	return c.provider
}

func (c *CustomTranscriber) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomTranscriber) UnmarshalJSON(data []byte) error {
	type embed CustomTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "custom-transcriber" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-transcriber", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomTranscriber) MarshalJSON() ([]byte, error) {
	type embed CustomTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-transcriber",
	}
	return json.Marshal(marshaler)
}

func (c *CustomTranscriber) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomVoice struct {
	// This is the voice provider that will be used. Use `custom-voice` for providers that are not natively supported.
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is where the voice request will be sent.
	//
	// Request Example:
	//
	// POST https://{server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "message": {
	//	    "type": "voice-request",
	//	    "text": "Hello, world!",
	//	    "sampleRate": 24000,
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// Response Expected: 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomVoice) GetChunkPlan() *ChunkPlan {
	if c == nil {
		return nil
	}
	return c.ChunkPlan
}

func (c *CustomVoice) GetServer() *Server {
	if c == nil {
		return nil
	}
	return c.Server
}

func (c *CustomVoice) GetFallbackPlan() *FallbackPlan {
	if c == nil {
		return nil
	}
	return c.FallbackPlan
}

func (c *CustomVoice) Provider() string {
	return c.provider
}

func (c *CustomVoice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomVoice) UnmarshalJSON(data []byte) error {
	type embed CustomVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomVoice(unmarshaler.embed)
	if unmarshaler.Provider != "custom-voice" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "custom-voice", unmarshaler.Provider)
	}
	c.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "provider")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomVoice) MarshalJSON() ([]byte, error) {
	type embed CustomVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*c),
		Provider: "custom-voice",
	}
	return json.Marshal(marshaler)
}

func (c *CustomVoice) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomerCustomEndpointingRule struct {
	// This endpointing rule is based on current customer message as they are speaking.
	//
	// Flow:
	// - Assistant speaks
	// - Customer starts speaking
	// - Customer transcription comes in
	// - This rule is evaluated on the current customer transcription
	// - If a match is found based on `regex`, the endpointing timeout is set to `timeoutSeconds`
	//
	// Usage:
	// - If you want to wait longer while customer is speaking numbers, you can set a longer timeout.
	// This is the regex pattern to match.
	//
	// Note:
	// - This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test("hello there")` will return `true`.
	//
	// Hot tip:
	// - In JavaScript, escape `\` when sending the regex pattern. Eg. `"hello\sthere"` will be sent over the wire as `"hellosthere"`. Send `"hello\\sthere"` instead.
	// - `RegExp.test` does substring matching, so `/cat/.test("I love cats")` will return `true`. To do full string matching, send "^cat$".
	Regex string `json:"regex" url:"regex"`
	// These are the options for the regex match. Defaults to all disabled.
	//
	// @default []
	RegexOptions []*RegexOption `json:"regexOptions,omitempty" url:"regexOptions,omitempty"`
	// This is the endpointing timeout in seconds, if the rule is matched.
	TimeoutSeconds float64 `json:"timeoutSeconds" url:"timeoutSeconds"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomEndpointingRule) GetRegex() string {
	if c == nil {
		return ""
	}
	return c.Regex
}

func (c *CustomerCustomEndpointingRule) GetRegexOptions() []*RegexOption {
	if c == nil {
		return nil
	}
	return c.RegexOptions
}

func (c *CustomerCustomEndpointingRule) GetTimeoutSeconds() float64 {
	if c == nil {
		return 0
	}
	return c.TimeoutSeconds
}

func (c *CustomerCustomEndpointingRule) Type() string {
	return c.type_
}

func (c *CustomerCustomEndpointingRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomEndpointingRule) UnmarshalJSON(data []byte) error {
	type embed CustomerCustomEndpointingRule
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomerCustomEndpointingRule(unmarshaler.embed)
	if unmarshaler.Type != "customer" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "customer", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomEndpointingRule) MarshalJSON() ([]byte, error) {
	type embed CustomerCustomEndpointingRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "customer",
	}
	return json.Marshal(marshaler)
}

func (c *CustomerCustomEndpointingRule) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeepInfraCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepInfraCredential) GetApiKey() string {
	if d == nil {
		return ""
	}
	return d.ApiKey
}

func (d *DeepInfraCredential) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeepInfraCredential) GetOrgId() string {
	if d == nil {
		return ""
	}
	return d.OrgId
}

func (d *DeepInfraCredential) GetCreatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.CreatedAt
}

func (d *DeepInfraCredential) GetUpdatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.UpdatedAt
}

func (d *DeepInfraCredential) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeepInfraCredential) Provider() string {
	return d.provider
}

func (d *DeepInfraCredential) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepInfraCredential) UnmarshalJSON(data []byte) error {
	type embed DeepInfraCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepInfraCredential(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepinfra", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepInfraCredential) MarshalJSON() ([]byte, error) {
	type embed DeepInfraCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*d),
		CreatedAt: internal.NewDateTime(d.CreatedAt),
		UpdatedAt: internal.NewDateTime(d.UpdatedAt),
		Provider:  "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (d *DeepInfraCredential) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepInfraModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*DeepInfraModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepInfraModel) GetMessages() []*OpenAiMessage {
	if d == nil {
		return nil
	}
	return d.Messages
}

func (d *DeepInfraModel) GetTools() []*DeepInfraModelToolsItem {
	if d == nil {
		return nil
	}
	return d.Tools
}

func (d *DeepInfraModel) GetToolIds() []string {
	if d == nil {
		return nil
	}
	return d.ToolIds
}

func (d *DeepInfraModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if d == nil {
		return nil
	}
	return d.KnowledgeBase
}

func (d *DeepInfraModel) GetKnowledgeBaseId() *string {
	if d == nil {
		return nil
	}
	return d.KnowledgeBaseId
}

func (d *DeepInfraModel) GetModel() string {
	if d == nil {
		return ""
	}
	return d.Model
}

func (d *DeepInfraModel) GetTemperature() *float64 {
	if d == nil {
		return nil
	}
	return d.Temperature
}

func (d *DeepInfraModel) GetMaxTokens() *float64 {
	if d == nil {
		return nil
	}
	return d.MaxTokens
}

func (d *DeepInfraModel) GetEmotionRecognitionEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.EmotionRecognitionEnabled
}

func (d *DeepInfraModel) GetNumFastTurns() *float64 {
	if d == nil {
		return nil
	}
	return d.NumFastTurns
}

func (d *DeepInfraModel) Provider() string {
	return d.provider
}

func (d *DeepInfraModel) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepInfraModel) UnmarshalJSON(data []byte) error {
	type embed DeepInfraModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepInfraModel(unmarshaler.embed)
	if unmarshaler.Provider != "deepinfra" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepinfra", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepInfraModel) MarshalJSON() ([]byte, error) {
	type embed DeepInfraModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepinfra",
	}
	return json.Marshal(marshaler)
}

func (d *DeepInfraModel) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepInfraModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (d *DeepInfraModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if d == nil {
		return nil
	}
	return d.CreateDtmfToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if d == nil {
		return nil
	}
	return d.CreateEndCallToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if d == nil {
		return nil
	}
	return d.CreateVoicemailToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if d == nil {
		return nil
	}
	return d.CreateFunctionToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGhlToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if d == nil {
		return nil
	}
	return d.CreateMakeToolDto
}

func (d *DeepInfraModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if d == nil {
		return nil
	}
	return d.CreateTransferCallToolDto
}

func (d *DeepInfraModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		d.typ = "CreateDtmfToolDto"
		d.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		d.typ = "CreateEndCallToolDto"
		d.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		d.typ = "CreateVoicemailToolDto"
		d.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		d.typ = "CreateFunctionToolDto"
		d.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		d.typ = "CreateGhlToolDto"
		d.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		d.typ = "CreateMakeToolDto"
		d.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		d.typ = "CreateTransferCallToolDto"
		d.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeepInfraModelToolsItem) MarshalJSON() ([]byte, error) {
	if d.typ == "CreateDtmfToolDto" || d.CreateDtmfToolDto != nil {
		return json.Marshal(d.CreateDtmfToolDto)
	}
	if d.typ == "CreateEndCallToolDto" || d.CreateEndCallToolDto != nil {
		return json.Marshal(d.CreateEndCallToolDto)
	}
	if d.typ == "CreateVoicemailToolDto" || d.CreateVoicemailToolDto != nil {
		return json.Marshal(d.CreateVoicemailToolDto)
	}
	if d.typ == "CreateFunctionToolDto" || d.CreateFunctionToolDto != nil {
		return json.Marshal(d.CreateFunctionToolDto)
	}
	if d.typ == "CreateGhlToolDto" || d.CreateGhlToolDto != nil {
		return json.Marshal(d.CreateGhlToolDto)
	}
	if d.typ == "CreateMakeToolDto" || d.CreateMakeToolDto != nil {
		return json.Marshal(d.CreateMakeToolDto)
	}
	if d.typ == "CreateTransferCallToolDto" || d.CreateTransferCallToolDto != nil {
		return json.Marshal(d.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepInfraModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (d *DeepInfraModelToolsItem) Accept(visitor DeepInfraModelToolsItemVisitor) error {
	if d.typ == "CreateDtmfToolDto" || d.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(d.CreateDtmfToolDto)
	}
	if d.typ == "CreateEndCallToolDto" || d.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(d.CreateEndCallToolDto)
	}
	if d.typ == "CreateVoicemailToolDto" || d.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(d.CreateVoicemailToolDto)
	}
	if d.typ == "CreateFunctionToolDto" || d.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(d.CreateFunctionToolDto)
	}
	if d.typ == "CreateGhlToolDto" || d.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(d.CreateGhlToolDto)
	}
	if d.typ == "CreateMakeToolDto" || d.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(d.CreateMakeToolDto)
	}
	if d.typ == "CreateTransferCallToolDto" || d.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(d.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepSeekCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepSeekCredential) GetApiKey() string {
	if d == nil {
		return ""
	}
	return d.ApiKey
}

func (d *DeepSeekCredential) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeepSeekCredential) GetOrgId() string {
	if d == nil {
		return ""
	}
	return d.OrgId
}

func (d *DeepSeekCredential) GetCreatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.CreatedAt
}

func (d *DeepSeekCredential) GetUpdatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.UpdatedAt
}

func (d *DeepSeekCredential) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeepSeekCredential) Provider() string {
	return d.provider
}

func (d *DeepSeekCredential) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepSeekCredential) UnmarshalJSON(data []byte) error {
	type embed DeepSeekCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepSeekCredential(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "deep-seek" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deep-seek", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepSeekCredential) MarshalJSON() ([]byte, error) {
	type embed DeepSeekCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*d),
		CreatedAt: internal.NewDateTime(d.CreatedAt),
		UpdatedAt: internal.NewDateTime(d.UpdatedAt),
		Provider:  "deep-seek",
	}
	return json.Marshal(marshaler)
}

func (d *DeepSeekCredential) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepSeekModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*DeepSeekModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	model        string
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepSeekModel) GetMessages() []*OpenAiMessage {
	if d == nil {
		return nil
	}
	return d.Messages
}

func (d *DeepSeekModel) GetTools() []*DeepSeekModelToolsItem {
	if d == nil {
		return nil
	}
	return d.Tools
}

func (d *DeepSeekModel) GetToolIds() []string {
	if d == nil {
		return nil
	}
	return d.ToolIds
}

func (d *DeepSeekModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if d == nil {
		return nil
	}
	return d.KnowledgeBase
}

func (d *DeepSeekModel) GetKnowledgeBaseId() *string {
	if d == nil {
		return nil
	}
	return d.KnowledgeBaseId
}

func (d *DeepSeekModel) GetTemperature() *float64 {
	if d == nil {
		return nil
	}
	return d.Temperature
}

func (d *DeepSeekModel) GetMaxTokens() *float64 {
	if d == nil {
		return nil
	}
	return d.MaxTokens
}

func (d *DeepSeekModel) GetEmotionRecognitionEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.EmotionRecognitionEnabled
}

func (d *DeepSeekModel) GetNumFastTurns() *float64 {
	if d == nil {
		return nil
	}
	return d.NumFastTurns
}

func (d *DeepSeekModel) Model() string {
	return d.model
}

func (d *DeepSeekModel) Provider() string {
	return d.provider
}

func (d *DeepSeekModel) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepSeekModel) UnmarshalJSON(data []byte) error {
	type embed DeepSeekModel
	var unmarshaler = struct {
		embed
		Model    string `json:"model"`
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepSeekModel(unmarshaler.embed)
	if unmarshaler.Model != "deepseek-chat" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepseek-chat", unmarshaler.Model)
	}
	d.model = unmarshaler.Model
	if unmarshaler.Provider != "deep-seek" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deep-seek", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "model", "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepSeekModel) MarshalJSON() ([]byte, error) {
	type embed DeepSeekModel
	var marshaler = struct {
		embed
		Model    string `json:"model"`
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Model:    "deepseek-chat",
		Provider: "deep-seek",
	}
	return json.Marshal(marshaler)
}

func (d *DeepSeekModel) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepSeekModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (d *DeepSeekModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if d == nil {
		return nil
	}
	return d.CreateDtmfToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if d == nil {
		return nil
	}
	return d.CreateEndCallToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if d == nil {
		return nil
	}
	return d.CreateVoicemailToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if d == nil {
		return nil
	}
	return d.CreateFunctionToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if d == nil {
		return nil
	}
	return d.CreateGhlToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if d == nil {
		return nil
	}
	return d.CreateMakeToolDto
}

func (d *DeepSeekModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if d == nil {
		return nil
	}
	return d.CreateTransferCallToolDto
}

func (d *DeepSeekModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		d.typ = "CreateDtmfToolDto"
		d.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		d.typ = "CreateEndCallToolDto"
		d.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		d.typ = "CreateVoicemailToolDto"
		d.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		d.typ = "CreateFunctionToolDto"
		d.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		d.typ = "CreateGhlToolDto"
		d.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		d.typ = "CreateMakeToolDto"
		d.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		d.typ = "CreateTransferCallToolDto"
		d.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeepSeekModelToolsItem) MarshalJSON() ([]byte, error) {
	if d.typ == "CreateDtmfToolDto" || d.CreateDtmfToolDto != nil {
		return json.Marshal(d.CreateDtmfToolDto)
	}
	if d.typ == "CreateEndCallToolDto" || d.CreateEndCallToolDto != nil {
		return json.Marshal(d.CreateEndCallToolDto)
	}
	if d.typ == "CreateVoicemailToolDto" || d.CreateVoicemailToolDto != nil {
		return json.Marshal(d.CreateVoicemailToolDto)
	}
	if d.typ == "CreateFunctionToolDto" || d.CreateFunctionToolDto != nil {
		return json.Marshal(d.CreateFunctionToolDto)
	}
	if d.typ == "CreateGhlToolDto" || d.CreateGhlToolDto != nil {
		return json.Marshal(d.CreateGhlToolDto)
	}
	if d.typ == "CreateMakeToolDto" || d.CreateMakeToolDto != nil {
		return json.Marshal(d.CreateMakeToolDto)
	}
	if d.typ == "CreateTransferCallToolDto" || d.CreateTransferCallToolDto != nil {
		return json.Marshal(d.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepSeekModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (d *DeepSeekModelToolsItem) Accept(visitor DeepSeekModelToolsItemVisitor) error {
	if d.typ == "CreateDtmfToolDto" || d.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(d.CreateDtmfToolDto)
	}
	if d.typ == "CreateEndCallToolDto" || d.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(d.CreateEndCallToolDto)
	}
	if d.typ == "CreateVoicemailToolDto" || d.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(d.CreateVoicemailToolDto)
	}
	if d.typ == "CreateFunctionToolDto" || d.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(d.CreateFunctionToolDto)
	}
	if d.typ == "CreateGhlToolDto" || d.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(d.CreateGhlToolDto)
	}
	if d.typ == "CreateMakeToolDto" || d.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(d.CreateMakeToolDto)
	}
	if d.typ == "CreateTransferCallToolDto" || d.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(d.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepgramCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl   *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepgramCredential) GetApiKey() string {
	if d == nil {
		return ""
	}
	return d.ApiKey
}

func (d *DeepgramCredential) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DeepgramCredential) GetOrgId() string {
	if d == nil {
		return ""
	}
	return d.OrgId
}

func (d *DeepgramCredential) GetCreatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.CreatedAt
}

func (d *DeepgramCredential) GetUpdatedAt() time.Time {
	if d == nil {
		return time.Time{}
	}
	return d.UpdatedAt
}

func (d *DeepgramCredential) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeepgramCredential) GetApiUrl() *string {
	if d == nil {
		return nil
	}
	return d.ApiUrl
}

func (d *DeepgramCredential) Provider() string {
	return d.provider
}

func (d *DeepgramCredential) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramCredential) UnmarshalJSON(data []byte) error {
	type embed DeepgramCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramCredential(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramCredential) MarshalJSON() ([]byte, error) {
	type embed DeepgramCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*d),
		CreatedAt: internal.NewDateTime(d.CreatedAt),
		UpdatedAt: internal.NewDateTime(d.UpdatedAt),
		Provider:  "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramCredential) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepgramTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the Deepgram model that will be used. A list of models can be found here: https://developers.deepgram.com/docs/models-languages-overview
	Model *DeepgramTranscriberModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription. The list of languages Deepgram supports can be found here: https://developers.deepgram.com/docs/models-languages-overview
	Language *DeepgramTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This will be use smart format option provided by Deepgram. It's default disabled because it can sometimes format numbers as times but it's getting better.
	SmartFormat *bool `json:"smartFormat,omitempty" url:"smartFormat,omitempty"`
	// This automatically switches the transcriber's language when the customer's language changes. Defaults to false.
	//
	// Usage:
	// - If your customers switch languages mid-call, you can set this to true.
	//
	// Note:
	// - To detect language changes, Vapi uses a custom trained model. Languages supported (X = limited support):
	//  1. Arabic
	//  2. Bengali
	//  3. Cantonese
	//  4. Chinese
	//  5. Chinese Simplified (X)
	//  6. Chinese Traditional (X)
	//  7. English
	//  8. Farsi (X)
	//  9. French
	//  10. German
	//  11. Haitian Creole (X)
	//  12. Hindi
	//  13. Italian
	//  14. Japanese
	//  15. Korean
	//  16. Portuguese
	//  17. Russian
	//  18. Spanish
	//  19. Thai
	//  20. Urdu
	//  21. Vietnamese
	//
	// - To receive `language-change-detected` webhook events, add it to `assistant.serverMessages`.
	//
	// @default false
	CodeSwitchingEnabled *bool `json:"codeSwitchingEnabled,omitempty" url:"codeSwitchingEnabled,omitempty"`
	// These keywords are passed to the transcription model to help it pick up use-case specific words. Anything that may not be a common word, like your company name, should be added here.
	Keywords []string `json:"keywords,omitempty" url:"keywords,omitempty"`
	// This is the timeout after which Deepgram will send transcription on user silence. You can read in-depth documentation here: https://developers.deepgram.com/docs/endpointing.
	//
	// Here are the most important bits:
	// - Defaults to 10. This is recommended for most use cases to optimize for latency.
	// - 10 can cause some missing transcriptions since because of the shorter context. This mostly happens for one-word utterances. For those uses cases, it's recommended to try 300. It will add a bit of latency but the quality and reliability of the experience will be better.
	// - If neither 10 nor 300 work, contact support@vapi.ai and we'll find another solution.
	//
	// @default 10
	Endpointing *float64 `json:"endpointing,omitempty" url:"endpointing,omitempty"`
	provider    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepgramTranscriber) GetModel() *DeepgramTranscriberModel {
	if d == nil {
		return nil
	}
	return d.Model
}

func (d *DeepgramTranscriber) GetLanguage() *DeepgramTranscriberLanguage {
	if d == nil {
		return nil
	}
	return d.Language
}

func (d *DeepgramTranscriber) GetSmartFormat() *bool {
	if d == nil {
		return nil
	}
	return d.SmartFormat
}

func (d *DeepgramTranscriber) GetCodeSwitchingEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.CodeSwitchingEnabled
}

func (d *DeepgramTranscriber) GetKeywords() []string {
	if d == nil {
		return nil
	}
	return d.Keywords
}

func (d *DeepgramTranscriber) GetEndpointing() *float64 {
	if d == nil {
		return nil
	}
	return d.Endpointing
}

func (d *DeepgramTranscriber) Provider() string {
	return d.provider
}

func (d *DeepgramTranscriber) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramTranscriber) UnmarshalJSON(data []byte) error {
	type embed DeepgramTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramTranscriber) MarshalJSON() ([]byte, error) {
	type embed DeepgramTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramTranscriber) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeepgramTranscriberLanguage string

const (
	DeepgramTranscriberLanguageBg      DeepgramTranscriberLanguage = "bg"
	DeepgramTranscriberLanguageCa      DeepgramTranscriberLanguage = "ca"
	DeepgramTranscriberLanguageCs      DeepgramTranscriberLanguage = "cs"
	DeepgramTranscriberLanguageDa      DeepgramTranscriberLanguage = "da"
	DeepgramTranscriberLanguageDaDk    DeepgramTranscriberLanguage = "da-DK"
	DeepgramTranscriberLanguageDe      DeepgramTranscriberLanguage = "de"
	DeepgramTranscriberLanguageDeCh    DeepgramTranscriberLanguage = "de-CH"
	DeepgramTranscriberLanguageEl      DeepgramTranscriberLanguage = "el"
	DeepgramTranscriberLanguageEn      DeepgramTranscriberLanguage = "en"
	DeepgramTranscriberLanguageEnAu    DeepgramTranscriberLanguage = "en-AU"
	DeepgramTranscriberLanguageEnGb    DeepgramTranscriberLanguage = "en-GB"
	DeepgramTranscriberLanguageEnIn    DeepgramTranscriberLanguage = "en-IN"
	DeepgramTranscriberLanguageEnNz    DeepgramTranscriberLanguage = "en-NZ"
	DeepgramTranscriberLanguageEnUs    DeepgramTranscriberLanguage = "en-US"
	DeepgramTranscriberLanguageEs      DeepgramTranscriberLanguage = "es"
	DeepgramTranscriberLanguageEs419   DeepgramTranscriberLanguage = "es-419"
	DeepgramTranscriberLanguageEsLatam DeepgramTranscriberLanguage = "es-LATAM"
	DeepgramTranscriberLanguageEt      DeepgramTranscriberLanguage = "et"
	DeepgramTranscriberLanguageFi      DeepgramTranscriberLanguage = "fi"
	DeepgramTranscriberLanguageFr      DeepgramTranscriberLanguage = "fr"
	DeepgramTranscriberLanguageFrCa    DeepgramTranscriberLanguage = "fr-CA"
	DeepgramTranscriberLanguageHi      DeepgramTranscriberLanguage = "hi"
	DeepgramTranscriberLanguageHiLatn  DeepgramTranscriberLanguage = "hi-Latn"
	DeepgramTranscriberLanguageHu      DeepgramTranscriberLanguage = "hu"
	DeepgramTranscriberLanguageId      DeepgramTranscriberLanguage = "id"
	DeepgramTranscriberLanguageIt      DeepgramTranscriberLanguage = "it"
	DeepgramTranscriberLanguageJa      DeepgramTranscriberLanguage = "ja"
	DeepgramTranscriberLanguageKo      DeepgramTranscriberLanguage = "ko"
	DeepgramTranscriberLanguageKoKr    DeepgramTranscriberLanguage = "ko-KR"
	DeepgramTranscriberLanguageLt      DeepgramTranscriberLanguage = "lt"
	DeepgramTranscriberLanguageLv      DeepgramTranscriberLanguage = "lv"
	DeepgramTranscriberLanguageMs      DeepgramTranscriberLanguage = "ms"
	DeepgramTranscriberLanguageMulti   DeepgramTranscriberLanguage = "multi"
	DeepgramTranscriberLanguageNl      DeepgramTranscriberLanguage = "nl"
	DeepgramTranscriberLanguageNlBe    DeepgramTranscriberLanguage = "nl-BE"
	DeepgramTranscriberLanguageNo      DeepgramTranscriberLanguage = "no"
	DeepgramTranscriberLanguagePl      DeepgramTranscriberLanguage = "pl"
	DeepgramTranscriberLanguagePt      DeepgramTranscriberLanguage = "pt"
	DeepgramTranscriberLanguagePtBr    DeepgramTranscriberLanguage = "pt-BR"
	DeepgramTranscriberLanguageRo      DeepgramTranscriberLanguage = "ro"
	DeepgramTranscriberLanguageRu      DeepgramTranscriberLanguage = "ru"
	DeepgramTranscriberLanguageSk      DeepgramTranscriberLanguage = "sk"
	DeepgramTranscriberLanguageSv      DeepgramTranscriberLanguage = "sv"
	DeepgramTranscriberLanguageSvSe    DeepgramTranscriberLanguage = "sv-SE"
	DeepgramTranscriberLanguageTa      DeepgramTranscriberLanguage = "ta"
	DeepgramTranscriberLanguageTaq     DeepgramTranscriberLanguage = "taq"
	DeepgramTranscriberLanguageTh      DeepgramTranscriberLanguage = "th"
	DeepgramTranscriberLanguageThTh    DeepgramTranscriberLanguage = "th-TH"
	DeepgramTranscriberLanguageTr      DeepgramTranscriberLanguage = "tr"
	DeepgramTranscriberLanguageUk      DeepgramTranscriberLanguage = "uk"
	DeepgramTranscriberLanguageVi      DeepgramTranscriberLanguage = "vi"
	DeepgramTranscriberLanguageZh      DeepgramTranscriberLanguage = "zh"
	DeepgramTranscriberLanguageZhCn    DeepgramTranscriberLanguage = "zh-CN"
	DeepgramTranscriberLanguageZhHans  DeepgramTranscriberLanguage = "zh-Hans"
	DeepgramTranscriberLanguageZhHant  DeepgramTranscriberLanguage = "zh-Hant"
	DeepgramTranscriberLanguageZhTw    DeepgramTranscriberLanguage = "zh-TW"
)

func NewDeepgramTranscriberLanguageFromString(s string) (DeepgramTranscriberLanguage, error) {
	switch s {
	case "bg":
		return DeepgramTranscriberLanguageBg, nil
	case "ca":
		return DeepgramTranscriberLanguageCa, nil
	case "cs":
		return DeepgramTranscriberLanguageCs, nil
	case "da":
		return DeepgramTranscriberLanguageDa, nil
	case "da-DK":
		return DeepgramTranscriberLanguageDaDk, nil
	case "de":
		return DeepgramTranscriberLanguageDe, nil
	case "de-CH":
		return DeepgramTranscriberLanguageDeCh, nil
	case "el":
		return DeepgramTranscriberLanguageEl, nil
	case "en":
		return DeepgramTranscriberLanguageEn, nil
	case "en-AU":
		return DeepgramTranscriberLanguageEnAu, nil
	case "en-GB":
		return DeepgramTranscriberLanguageEnGb, nil
	case "en-IN":
		return DeepgramTranscriberLanguageEnIn, nil
	case "en-NZ":
		return DeepgramTranscriberLanguageEnNz, nil
	case "en-US":
		return DeepgramTranscriberLanguageEnUs, nil
	case "es":
		return DeepgramTranscriberLanguageEs, nil
	case "es-419":
		return DeepgramTranscriberLanguageEs419, nil
	case "es-LATAM":
		return DeepgramTranscriberLanguageEsLatam, nil
	case "et":
		return DeepgramTranscriberLanguageEt, nil
	case "fi":
		return DeepgramTranscriberLanguageFi, nil
	case "fr":
		return DeepgramTranscriberLanguageFr, nil
	case "fr-CA":
		return DeepgramTranscriberLanguageFrCa, nil
	case "hi":
		return DeepgramTranscriberLanguageHi, nil
	case "hi-Latn":
		return DeepgramTranscriberLanguageHiLatn, nil
	case "hu":
		return DeepgramTranscriberLanguageHu, nil
	case "id":
		return DeepgramTranscriberLanguageId, nil
	case "it":
		return DeepgramTranscriberLanguageIt, nil
	case "ja":
		return DeepgramTranscriberLanguageJa, nil
	case "ko":
		return DeepgramTranscriberLanguageKo, nil
	case "ko-KR":
		return DeepgramTranscriberLanguageKoKr, nil
	case "lt":
		return DeepgramTranscriberLanguageLt, nil
	case "lv":
		return DeepgramTranscriberLanguageLv, nil
	case "ms":
		return DeepgramTranscriberLanguageMs, nil
	case "multi":
		return DeepgramTranscriberLanguageMulti, nil
	case "nl":
		return DeepgramTranscriberLanguageNl, nil
	case "nl-BE":
		return DeepgramTranscriberLanguageNlBe, nil
	case "no":
		return DeepgramTranscriberLanguageNo, nil
	case "pl":
		return DeepgramTranscriberLanguagePl, nil
	case "pt":
		return DeepgramTranscriberLanguagePt, nil
	case "pt-BR":
		return DeepgramTranscriberLanguagePtBr, nil
	case "ro":
		return DeepgramTranscriberLanguageRo, nil
	case "ru":
		return DeepgramTranscriberLanguageRu, nil
	case "sk":
		return DeepgramTranscriberLanguageSk, nil
	case "sv":
		return DeepgramTranscriberLanguageSv, nil
	case "sv-SE":
		return DeepgramTranscriberLanguageSvSe, nil
	case "ta":
		return DeepgramTranscriberLanguageTa, nil
	case "taq":
		return DeepgramTranscriberLanguageTaq, nil
	case "th":
		return DeepgramTranscriberLanguageTh, nil
	case "th-TH":
		return DeepgramTranscriberLanguageThTh, nil
	case "tr":
		return DeepgramTranscriberLanguageTr, nil
	case "uk":
		return DeepgramTranscriberLanguageUk, nil
	case "vi":
		return DeepgramTranscriberLanguageVi, nil
	case "zh":
		return DeepgramTranscriberLanguageZh, nil
	case "zh-CN":
		return DeepgramTranscriberLanguageZhCn, nil
	case "zh-Hans":
		return DeepgramTranscriberLanguageZhHans, nil
	case "zh-Hant":
		return DeepgramTranscriberLanguageZhHant, nil
	case "zh-TW":
		return DeepgramTranscriberLanguageZhTw, nil
	}
	var t DeepgramTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramTranscriberLanguage) Ptr() *DeepgramTranscriberLanguage {
	return &d
}

type DeepgramTranscriberModel string

const (
	DeepgramTranscriberModelNova2                 DeepgramTranscriberModel = "nova-2"
	DeepgramTranscriberModelNova2General          DeepgramTranscriberModel = "nova-2-general"
	DeepgramTranscriberModelNova2Meeting          DeepgramTranscriberModel = "nova-2-meeting"
	DeepgramTranscriberModelNova2Phonecall        DeepgramTranscriberModel = "nova-2-phonecall"
	DeepgramTranscriberModelNova2Finance          DeepgramTranscriberModel = "nova-2-finance"
	DeepgramTranscriberModelNova2Conversationalai DeepgramTranscriberModel = "nova-2-conversationalai"
	DeepgramTranscriberModelNova2Voicemail        DeepgramTranscriberModel = "nova-2-voicemail"
	DeepgramTranscriberModelNova2Video            DeepgramTranscriberModel = "nova-2-video"
	DeepgramTranscriberModelNova2Medical          DeepgramTranscriberModel = "nova-2-medical"
	DeepgramTranscriberModelNova2Drivethru        DeepgramTranscriberModel = "nova-2-drivethru"
	DeepgramTranscriberModelNova2Automotive       DeepgramTranscriberModel = "nova-2-automotive"
	DeepgramTranscriberModelNova                  DeepgramTranscriberModel = "nova"
	DeepgramTranscriberModelNovaGeneral           DeepgramTranscriberModel = "nova-general"
	DeepgramTranscriberModelNovaPhonecall         DeepgramTranscriberModel = "nova-phonecall"
	DeepgramTranscriberModelNovaMedical           DeepgramTranscriberModel = "nova-medical"
	DeepgramTranscriberModelEnhanced              DeepgramTranscriberModel = "enhanced"
	DeepgramTranscriberModelEnhancedGeneral       DeepgramTranscriberModel = "enhanced-general"
	DeepgramTranscriberModelEnhancedMeeting       DeepgramTranscriberModel = "enhanced-meeting"
	DeepgramTranscriberModelEnhancedPhonecall     DeepgramTranscriberModel = "enhanced-phonecall"
	DeepgramTranscriberModelEnhancedFinance       DeepgramTranscriberModel = "enhanced-finance"
	DeepgramTranscriberModelBase                  DeepgramTranscriberModel = "base"
	DeepgramTranscriberModelBaseGeneral           DeepgramTranscriberModel = "base-general"
	DeepgramTranscriberModelBaseMeeting           DeepgramTranscriberModel = "base-meeting"
	DeepgramTranscriberModelBasePhonecall         DeepgramTranscriberModel = "base-phonecall"
	DeepgramTranscriberModelBaseFinance           DeepgramTranscriberModel = "base-finance"
	DeepgramTranscriberModelBaseConversationalai  DeepgramTranscriberModel = "base-conversationalai"
	DeepgramTranscriberModelBaseVoicemail         DeepgramTranscriberModel = "base-voicemail"
	DeepgramTranscriberModelBaseVideo             DeepgramTranscriberModel = "base-video"
)

func NewDeepgramTranscriberModelFromString(s string) (DeepgramTranscriberModel, error) {
	switch s {
	case "nova-2":
		return DeepgramTranscriberModelNova2, nil
	case "nova-2-general":
		return DeepgramTranscriberModelNova2General, nil
	case "nova-2-meeting":
		return DeepgramTranscriberModelNova2Meeting, nil
	case "nova-2-phonecall":
		return DeepgramTranscriberModelNova2Phonecall, nil
	case "nova-2-finance":
		return DeepgramTranscriberModelNova2Finance, nil
	case "nova-2-conversationalai":
		return DeepgramTranscriberModelNova2Conversationalai, nil
	case "nova-2-voicemail":
		return DeepgramTranscriberModelNova2Voicemail, nil
	case "nova-2-video":
		return DeepgramTranscriberModelNova2Video, nil
	case "nova-2-medical":
		return DeepgramTranscriberModelNova2Medical, nil
	case "nova-2-drivethru":
		return DeepgramTranscriberModelNova2Drivethru, nil
	case "nova-2-automotive":
		return DeepgramTranscriberModelNova2Automotive, nil
	case "nova":
		return DeepgramTranscriberModelNova, nil
	case "nova-general":
		return DeepgramTranscriberModelNovaGeneral, nil
	case "nova-phonecall":
		return DeepgramTranscriberModelNovaPhonecall, nil
	case "nova-medical":
		return DeepgramTranscriberModelNovaMedical, nil
	case "enhanced":
		return DeepgramTranscriberModelEnhanced, nil
	case "enhanced-general":
		return DeepgramTranscriberModelEnhancedGeneral, nil
	case "enhanced-meeting":
		return DeepgramTranscriberModelEnhancedMeeting, nil
	case "enhanced-phonecall":
		return DeepgramTranscriberModelEnhancedPhonecall, nil
	case "enhanced-finance":
		return DeepgramTranscriberModelEnhancedFinance, nil
	case "base":
		return DeepgramTranscriberModelBase, nil
	case "base-general":
		return DeepgramTranscriberModelBaseGeneral, nil
	case "base-meeting":
		return DeepgramTranscriberModelBaseMeeting, nil
	case "base-phonecall":
		return DeepgramTranscriberModelBasePhonecall, nil
	case "base-finance":
		return DeepgramTranscriberModelBaseFinance, nil
	case "base-conversationalai":
		return DeepgramTranscriberModelBaseConversationalai, nil
	case "base-voicemail":
		return DeepgramTranscriberModelBaseVoicemail, nil
	case "base-video":
		return DeepgramTranscriberModelBaseVideo, nil
	}
	var t DeepgramTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramTranscriberModel) Ptr() *DeepgramTranscriberModel {
	return &d
}

type DeepgramVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *DeepgramVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeepgramVoice) GetVoiceId() *DeepgramVoiceId {
	if d == nil {
		return nil
	}
	return d.VoiceId
}

func (d *DeepgramVoice) GetChunkPlan() *ChunkPlan {
	if d == nil {
		return nil
	}
	return d.ChunkPlan
}

func (d *DeepgramVoice) GetFallbackPlan() *FallbackPlan {
	if d == nil {
		return nil
	}
	return d.FallbackPlan
}

func (d *DeepgramVoice) Provider() string {
	return d.provider
}

func (d *DeepgramVoice) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeepgramVoice) UnmarshalJSON(data []byte) error {
	type embed DeepgramVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DeepgramVoice(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "deepgram", unmarshaler.Provider)
	}
	d.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *d, "provider")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeepgramVoice) MarshalJSON() ([]byte, error) {
	type embed DeepgramVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*d),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (d *DeepgramVoice) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// This is the provider-specific ID that will be used.
type DeepgramVoiceId struct {
	DeepgramVoiceIdEnum DeepgramVoiceIdEnum
	String              string

	typ string
}

func (d *DeepgramVoiceId) GetDeepgramVoiceIdEnum() DeepgramVoiceIdEnum {
	if d == nil {
		return ""
	}
	return d.DeepgramVoiceIdEnum
}

func (d *DeepgramVoiceId) GetString() string {
	if d == nil {
		return ""
	}
	return d.String
}

func (d *DeepgramVoiceId) UnmarshalJSON(data []byte) error {
	var valueDeepgramVoiceIdEnum DeepgramVoiceIdEnum
	if err := json.Unmarshal(data, &valueDeepgramVoiceIdEnum); err == nil {
		d.typ = "DeepgramVoiceIdEnum"
		d.DeepgramVoiceIdEnum = valueDeepgramVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typ = "String"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeepgramVoiceId) MarshalJSON() ([]byte, error) {
	if d.typ == "DeepgramVoiceIdEnum" || d.DeepgramVoiceIdEnum != "" {
		return json.Marshal(d.DeepgramVoiceIdEnum)
	}
	if d.typ == "String" || d.String != "" {
		return json.Marshal(d.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepgramVoiceIdVisitor interface {
	VisitDeepgramVoiceIdEnum(DeepgramVoiceIdEnum) error
	VisitString(string) error
}

func (d *DeepgramVoiceId) Accept(visitor DeepgramVoiceIdVisitor) error {
	if d.typ == "DeepgramVoiceIdEnum" || d.DeepgramVoiceIdEnum != "" {
		return visitor.VisitDeepgramVoiceIdEnum(d.DeepgramVoiceIdEnum)
	}
	if d.typ == "String" || d.String != "" {
		return visitor.VisitString(d.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DeepgramVoiceIdEnum string

const (
	DeepgramVoiceIdEnumAsteria DeepgramVoiceIdEnum = "asteria"
	DeepgramVoiceIdEnumLuna    DeepgramVoiceIdEnum = "luna"
	DeepgramVoiceIdEnumStella  DeepgramVoiceIdEnum = "stella"
	DeepgramVoiceIdEnumAthena  DeepgramVoiceIdEnum = "athena"
	DeepgramVoiceIdEnumHera    DeepgramVoiceIdEnum = "hera"
	DeepgramVoiceIdEnumOrion   DeepgramVoiceIdEnum = "orion"
	DeepgramVoiceIdEnumArcas   DeepgramVoiceIdEnum = "arcas"
	DeepgramVoiceIdEnumPerseus DeepgramVoiceIdEnum = "perseus"
	DeepgramVoiceIdEnumAngus   DeepgramVoiceIdEnum = "angus"
	DeepgramVoiceIdEnumOrpheus DeepgramVoiceIdEnum = "orpheus"
	DeepgramVoiceIdEnumHelios  DeepgramVoiceIdEnum = "helios"
	DeepgramVoiceIdEnumZeus    DeepgramVoiceIdEnum = "zeus"
)

func NewDeepgramVoiceIdEnumFromString(s string) (DeepgramVoiceIdEnum, error) {
	switch s {
	case "asteria":
		return DeepgramVoiceIdEnumAsteria, nil
	case "luna":
		return DeepgramVoiceIdEnumLuna, nil
	case "stella":
		return DeepgramVoiceIdEnumStella, nil
	case "athena":
		return DeepgramVoiceIdEnumAthena, nil
	case "hera":
		return DeepgramVoiceIdEnumHera, nil
	case "orion":
		return DeepgramVoiceIdEnumOrion, nil
	case "arcas":
		return DeepgramVoiceIdEnumArcas, nil
	case "perseus":
		return DeepgramVoiceIdEnumPerseus, nil
	case "angus":
		return DeepgramVoiceIdEnumAngus, nil
	case "orpheus":
		return DeepgramVoiceIdEnumOrpheus, nil
	case "helios":
		return DeepgramVoiceIdEnumHelios, nil
	case "zeus":
		return DeepgramVoiceIdEnumZeus, nil
	}
	var t DeepgramVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeepgramVoiceIdEnum) Ptr() *DeepgramVoiceIdEnum {
	return &d
}

type ElevenLabsCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ElevenLabsCredential) GetApiKey() string {
	if e == nil {
		return ""
	}
	return e.ApiKey
}

func (e *ElevenLabsCredential) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElevenLabsCredential) GetOrgId() string {
	if e == nil {
		return ""
	}
	return e.OrgId
}

func (e *ElevenLabsCredential) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *ElevenLabsCredential) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *ElevenLabsCredential) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *ElevenLabsCredential) Provider() string {
	return e.provider
}

func (e *ElevenLabsCredential) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElevenLabsCredential) UnmarshalJSON(data []byte) error {
	type embed ElevenLabsCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ElevenLabsCredential(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "11labs", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElevenLabsCredential) MarshalJSON() ([]byte, error) {
	type embed ElevenLabsCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
		Provider:  "11labs",
	}
	return json.Marshal(marshaler)
}

func (e *ElevenLabsCredential) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElevenLabsVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
	VoiceId *ElevenLabsVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Defines the stability for voice settings.
	Stability *float64 `json:"stability,omitempty" url:"stability,omitempty"`
	// Defines the similarity boost for voice settings.
	SimilarityBoost *float64 `json:"similarityBoost,omitempty" url:"similarityBoost,omitempty"`
	// Defines the style for voice settings.
	Style *float64 `json:"style,omitempty" url:"style,omitempty"`
	// Defines the use speaker boost for voice settings.
	UseSpeakerBoost *bool `json:"useSpeakerBoost,omitempty" url:"useSpeakerBoost,omitempty"`
	// Defines the optimize streaming latency for voice settings. Defaults to 3.
	OptimizeStreamingLatency *float64 `json:"optimizeStreamingLatency,omitempty" url:"optimizeStreamingLatency,omitempty"`
	// This enables the use of https://elevenlabs.io/docs/speech-synthesis/prompting#pronunciation. Defaults to false to save latency.
	//
	// @default false
	EnableSsmlParsing *bool `json:"enableSsmlParsing,omitempty" url:"enableSsmlParsing,omitempty"`
	// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
	Model *ElevenLabsVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the language (ISO 639-1) that is enforced for the model. Currently only Turbo v2.5 supports language enforcement. For other models, an error will be returned if language code is provided.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ElevenLabsVoice) GetVoiceId() *ElevenLabsVoiceId {
	if e == nil {
		return nil
	}
	return e.VoiceId
}

func (e *ElevenLabsVoice) GetStability() *float64 {
	if e == nil {
		return nil
	}
	return e.Stability
}

func (e *ElevenLabsVoice) GetSimilarityBoost() *float64 {
	if e == nil {
		return nil
	}
	return e.SimilarityBoost
}

func (e *ElevenLabsVoice) GetStyle() *float64 {
	if e == nil {
		return nil
	}
	return e.Style
}

func (e *ElevenLabsVoice) GetUseSpeakerBoost() *bool {
	if e == nil {
		return nil
	}
	return e.UseSpeakerBoost
}

func (e *ElevenLabsVoice) GetOptimizeStreamingLatency() *float64 {
	if e == nil {
		return nil
	}
	return e.OptimizeStreamingLatency
}

func (e *ElevenLabsVoice) GetEnableSsmlParsing() *bool {
	if e == nil {
		return nil
	}
	return e.EnableSsmlParsing
}

func (e *ElevenLabsVoice) GetModel() *ElevenLabsVoiceModel {
	if e == nil {
		return nil
	}
	return e.Model
}

func (e *ElevenLabsVoice) GetChunkPlan() *ChunkPlan {
	if e == nil {
		return nil
	}
	return e.ChunkPlan
}

func (e *ElevenLabsVoice) GetLanguage() *string {
	if e == nil {
		return nil
	}
	return e.Language
}

func (e *ElevenLabsVoice) GetFallbackPlan() *FallbackPlan {
	if e == nil {
		return nil
	}
	return e.FallbackPlan
}

func (e *ElevenLabsVoice) Provider() string {
	return e.provider
}

func (e *ElevenLabsVoice) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElevenLabsVoice) UnmarshalJSON(data []byte) error {
	type embed ElevenLabsVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ElevenLabsVoice(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "11labs", unmarshaler.Provider)
	}
	e.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "provider")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElevenLabsVoice) MarshalJSON() ([]byte, error) {
	type embed ElevenLabsVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*e),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (e *ElevenLabsVoice) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
type ElevenLabsVoiceId struct {
	ElevenLabsVoiceIdEnum ElevenLabsVoiceIdEnum
	String                string

	typ string
}

func (e *ElevenLabsVoiceId) GetElevenLabsVoiceIdEnum() ElevenLabsVoiceIdEnum {
	if e == nil {
		return ""
	}
	return e.ElevenLabsVoiceIdEnum
}

func (e *ElevenLabsVoiceId) GetString() string {
	if e == nil {
		return ""
	}
	return e.String
}

func (e *ElevenLabsVoiceId) UnmarshalJSON(data []byte) error {
	var valueElevenLabsVoiceIdEnum ElevenLabsVoiceIdEnum
	if err := json.Unmarshal(data, &valueElevenLabsVoiceIdEnum); err == nil {
		e.typ = "ElevenLabsVoiceIdEnum"
		e.ElevenLabsVoiceIdEnum = valueElevenLabsVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typ = "String"
		e.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e ElevenLabsVoiceId) MarshalJSON() ([]byte, error) {
	if e.typ == "ElevenLabsVoiceIdEnum" || e.ElevenLabsVoiceIdEnum != "" {
		return json.Marshal(e.ElevenLabsVoiceIdEnum)
	}
	if e.typ == "String" || e.String != "" {
		return json.Marshal(e.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ElevenLabsVoiceIdVisitor interface {
	VisitElevenLabsVoiceIdEnum(ElevenLabsVoiceIdEnum) error
	VisitString(string) error
}

func (e *ElevenLabsVoiceId) Accept(visitor ElevenLabsVoiceIdVisitor) error {
	if e.typ == "ElevenLabsVoiceIdEnum" || e.ElevenLabsVoiceIdEnum != "" {
		return visitor.VisitElevenLabsVoiceIdEnum(e.ElevenLabsVoiceIdEnum)
	}
	if e.typ == "String" || e.String != "" {
		return visitor.VisitString(e.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type ElevenLabsVoiceIdEnum string

const (
	ElevenLabsVoiceIdEnumBurt    ElevenLabsVoiceIdEnum = "burt"
	ElevenLabsVoiceIdEnumMarissa ElevenLabsVoiceIdEnum = "marissa"
	ElevenLabsVoiceIdEnumAndrea  ElevenLabsVoiceIdEnum = "andrea"
	ElevenLabsVoiceIdEnumSarah   ElevenLabsVoiceIdEnum = "sarah"
	ElevenLabsVoiceIdEnumPhillip ElevenLabsVoiceIdEnum = "phillip"
	ElevenLabsVoiceIdEnumSteve   ElevenLabsVoiceIdEnum = "steve"
	ElevenLabsVoiceIdEnumJoseph  ElevenLabsVoiceIdEnum = "joseph"
	ElevenLabsVoiceIdEnumMyra    ElevenLabsVoiceIdEnum = "myra"
	ElevenLabsVoiceIdEnumPaula   ElevenLabsVoiceIdEnum = "paula"
	ElevenLabsVoiceIdEnumRyan    ElevenLabsVoiceIdEnum = "ryan"
	ElevenLabsVoiceIdEnumDrew    ElevenLabsVoiceIdEnum = "drew"
	ElevenLabsVoiceIdEnumPaul    ElevenLabsVoiceIdEnum = "paul"
	ElevenLabsVoiceIdEnumMrb     ElevenLabsVoiceIdEnum = "mrb"
	ElevenLabsVoiceIdEnumMatilda ElevenLabsVoiceIdEnum = "matilda"
	ElevenLabsVoiceIdEnumMark    ElevenLabsVoiceIdEnum = "mark"
)

func NewElevenLabsVoiceIdEnumFromString(s string) (ElevenLabsVoiceIdEnum, error) {
	switch s {
	case "burt":
		return ElevenLabsVoiceIdEnumBurt, nil
	case "marissa":
		return ElevenLabsVoiceIdEnumMarissa, nil
	case "andrea":
		return ElevenLabsVoiceIdEnumAndrea, nil
	case "sarah":
		return ElevenLabsVoiceIdEnumSarah, nil
	case "phillip":
		return ElevenLabsVoiceIdEnumPhillip, nil
	case "steve":
		return ElevenLabsVoiceIdEnumSteve, nil
	case "joseph":
		return ElevenLabsVoiceIdEnumJoseph, nil
	case "myra":
		return ElevenLabsVoiceIdEnumMyra, nil
	case "paula":
		return ElevenLabsVoiceIdEnumPaula, nil
	case "ryan":
		return ElevenLabsVoiceIdEnumRyan, nil
	case "drew":
		return ElevenLabsVoiceIdEnumDrew, nil
	case "paul":
		return ElevenLabsVoiceIdEnumPaul, nil
	case "mrb":
		return ElevenLabsVoiceIdEnumMrb, nil
	case "matilda":
		return ElevenLabsVoiceIdEnumMatilda, nil
	case "mark":
		return ElevenLabsVoiceIdEnumMark, nil
	}
	var t ElevenLabsVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ElevenLabsVoiceIdEnum) Ptr() *ElevenLabsVoiceIdEnum {
	return &e
}

// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
type ElevenLabsVoiceModel string

const (
	ElevenLabsVoiceModelElevenMultilingualV2 ElevenLabsVoiceModel = "eleven_multilingual_v2"
	ElevenLabsVoiceModelElevenTurboV2        ElevenLabsVoiceModel = "eleven_turbo_v2"
	ElevenLabsVoiceModelElevenTurboV25       ElevenLabsVoiceModel = "eleven_turbo_v2_5"
	ElevenLabsVoiceModelElevenFlashV2        ElevenLabsVoiceModel = "eleven_flash_v2"
	ElevenLabsVoiceModelElevenFlashV25       ElevenLabsVoiceModel = "eleven_flash_v2_5"
	ElevenLabsVoiceModelElevenMonolingualV1  ElevenLabsVoiceModel = "eleven_monolingual_v1"
)

func NewElevenLabsVoiceModelFromString(s string) (ElevenLabsVoiceModel, error) {
	switch s {
	case "eleven_multilingual_v2":
		return ElevenLabsVoiceModelElevenMultilingualV2, nil
	case "eleven_turbo_v2":
		return ElevenLabsVoiceModelElevenTurboV2, nil
	case "eleven_turbo_v2_5":
		return ElevenLabsVoiceModelElevenTurboV25, nil
	case "eleven_flash_v2":
		return ElevenLabsVoiceModelElevenFlashV2, nil
	case "eleven_flash_v2_5":
		return ElevenLabsVoiceModelElevenFlashV25, nil
	case "eleven_monolingual_v1":
		return ElevenLabsVoiceModelElevenMonolingualV1, nil
	}
	var t ElevenLabsVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ElevenLabsVoiceModel) Ptr() *ElevenLabsVoiceModel {
	return &e
}

type ExactReplacement struct {
	// This is the exact replacement type. You can use this to replace a specific word or phrase with a different word or phrase.
	//
	// Usage:
	// - Replace "hello" with "hi": { type: 'exact', key: 'hello', value: 'hi' }
	// - Replace "good morning" with "good day": { type: 'exact', key: 'good morning', value: 'good day' }
	// - Replace a specific name: { type: 'exact', key: 'John Doe', value: 'Jane Smith' }
	// - Replace an acronym: { type: 'exact', key: 'AI', value: 'Artificial Intelligence' }
	// - Replace a company name with its phonetic pronunciation: { type: 'exact', key: 'Vapi', value: 'Vappy' }
	// This is the key to replace.
	Key string `json:"key" url:"key"`
	// This is the value that will replace the match.
	Value string `json:"value" url:"value"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExactReplacement) GetKey() string {
	if e == nil {
		return ""
	}
	return e.Key
}

func (e *ExactReplacement) GetValue() string {
	if e == nil {
		return ""
	}
	return e.Value
}

func (e *ExactReplacement) Type() string {
	return e.type_
}

func (e *ExactReplacement) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExactReplacement) UnmarshalJSON(data []byte) error {
	type embed ExactReplacement
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ExactReplacement(unmarshaler.embed)
	if unmarshaler.Type != "exact" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "exact", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExactReplacement) MarshalJSON() ([]byte, error) {
	type embed ExactReplacement
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
		Type:  "exact",
	}
	return json.Marshal(marshaler)
}

func (e *ExactReplacement) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FallbackAzureVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackAzureVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan  `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	OneOf     interface{} `json:"oneOf,omitempty" url:"oneOf,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackAzureVoice) GetVoiceId() *FallbackAzureVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackAzureVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackAzureVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackAzureVoice) GetOneOf() interface{} {
	if f == nil {
		return nil
	}
	return f.OneOf
}

func (f *FallbackAzureVoice) Provider() string {
	return f.provider
}

func (f *FallbackAzureVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackAzureVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackAzureVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackAzureVoice(unmarshaler.embed)
	if unmarshaler.Provider != "azure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "azure", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackAzureVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackAzureVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "azure",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackAzureVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackAzureVoiceId struct {
	FallbackAzureVoiceVoiceId FallbackAzureVoiceVoiceId
	String                    string

	typ string
}

func (f *FallbackAzureVoiceId) GetFallbackAzureVoiceVoiceId() FallbackAzureVoiceVoiceId {
	if f == nil {
		return ""
	}
	return f.FallbackAzureVoiceVoiceId
}

func (f *FallbackAzureVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackAzureVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackAzureVoiceVoiceId FallbackAzureVoiceVoiceId
	if err := json.Unmarshal(data, &valueFallbackAzureVoiceVoiceId); err == nil {
		f.typ = "FallbackAzureVoiceVoiceId"
		f.FallbackAzureVoiceVoiceId = valueFallbackAzureVoiceVoiceId
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackAzureVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackAzureVoiceVoiceId" || f.FallbackAzureVoiceVoiceId != "" {
		return json.Marshal(f.FallbackAzureVoiceVoiceId)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackAzureVoiceIdVisitor interface {
	VisitFallbackAzureVoiceVoiceId(FallbackAzureVoiceVoiceId) error
	VisitString(string) error
}

func (f *FallbackAzureVoiceId) Accept(visitor FallbackAzureVoiceIdVisitor) error {
	if f.typ == "FallbackAzureVoiceVoiceId" || f.FallbackAzureVoiceVoiceId != "" {
		return visitor.VisitFallbackAzureVoiceVoiceId(f.FallbackAzureVoiceVoiceId)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackAzureVoiceVoiceId string

const (
	FallbackAzureVoiceVoiceIdAndrew FallbackAzureVoiceVoiceId = "andrew"
	FallbackAzureVoiceVoiceIdBrian  FallbackAzureVoiceVoiceId = "brian"
	FallbackAzureVoiceVoiceIdEmma   FallbackAzureVoiceVoiceId = "emma"
)

func NewFallbackAzureVoiceVoiceIdFromString(s string) (FallbackAzureVoiceVoiceId, error) {
	switch s {
	case "andrew":
		return FallbackAzureVoiceVoiceIdAndrew, nil
	case "brian":
		return FallbackAzureVoiceVoiceIdBrian, nil
	case "emma":
		return FallbackAzureVoiceVoiceIdEmma, nil
	}
	var t FallbackAzureVoiceVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackAzureVoiceVoiceId) Ptr() *FallbackAzureVoiceVoiceId {
	return &f
}

type FallbackCartesiaVoice struct {
	// This is the voice provider that will be used.
	// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
	Model *FallbackCartesiaVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
	Language *FallbackCartesiaVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the provider-specific ID that will be used.
	VoiceId string `json:"voiceId" url:"voiceId"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackCartesiaVoice) GetModel() *FallbackCartesiaVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackCartesiaVoice) GetLanguage() *FallbackCartesiaVoiceLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackCartesiaVoice) GetVoiceId() string {
	if f == nil {
		return ""
	}
	return f.VoiceId
}

func (f *FallbackCartesiaVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackCartesiaVoice) Provider() string {
	return f.provider
}

func (f *FallbackCartesiaVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackCartesiaVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackCartesiaVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackCartesiaVoice(unmarshaler.embed)
	if unmarshaler.Provider != "cartesia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "cartesia", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackCartesiaVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackCartesiaVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "cartesia",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackCartesiaVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the language that will be used. This is optional and will default to the correct language for the voiceId.
type FallbackCartesiaVoiceLanguage string

const (
	FallbackCartesiaVoiceLanguageEn FallbackCartesiaVoiceLanguage = "en"
	FallbackCartesiaVoiceLanguageDe FallbackCartesiaVoiceLanguage = "de"
	FallbackCartesiaVoiceLanguageEs FallbackCartesiaVoiceLanguage = "es"
	FallbackCartesiaVoiceLanguageFr FallbackCartesiaVoiceLanguage = "fr"
	FallbackCartesiaVoiceLanguageJa FallbackCartesiaVoiceLanguage = "ja"
	FallbackCartesiaVoiceLanguagePt FallbackCartesiaVoiceLanguage = "pt"
	FallbackCartesiaVoiceLanguageZh FallbackCartesiaVoiceLanguage = "zh"
	FallbackCartesiaVoiceLanguageHi FallbackCartesiaVoiceLanguage = "hi"
	FallbackCartesiaVoiceLanguageIt FallbackCartesiaVoiceLanguage = "it"
	FallbackCartesiaVoiceLanguageKo FallbackCartesiaVoiceLanguage = "ko"
	FallbackCartesiaVoiceLanguageNl FallbackCartesiaVoiceLanguage = "nl"
	FallbackCartesiaVoiceLanguagePl FallbackCartesiaVoiceLanguage = "pl"
	FallbackCartesiaVoiceLanguageRu FallbackCartesiaVoiceLanguage = "ru"
	FallbackCartesiaVoiceLanguageSv FallbackCartesiaVoiceLanguage = "sv"
	FallbackCartesiaVoiceLanguageTr FallbackCartesiaVoiceLanguage = "tr"
)

func NewFallbackCartesiaVoiceLanguageFromString(s string) (FallbackCartesiaVoiceLanguage, error) {
	switch s {
	case "en":
		return FallbackCartesiaVoiceLanguageEn, nil
	case "de":
		return FallbackCartesiaVoiceLanguageDe, nil
	case "es":
		return FallbackCartesiaVoiceLanguageEs, nil
	case "fr":
		return FallbackCartesiaVoiceLanguageFr, nil
	case "ja":
		return FallbackCartesiaVoiceLanguageJa, nil
	case "pt":
		return FallbackCartesiaVoiceLanguagePt, nil
	case "zh":
		return FallbackCartesiaVoiceLanguageZh, nil
	case "hi":
		return FallbackCartesiaVoiceLanguageHi, nil
	case "it":
		return FallbackCartesiaVoiceLanguageIt, nil
	case "ko":
		return FallbackCartesiaVoiceLanguageKo, nil
	case "nl":
		return FallbackCartesiaVoiceLanguageNl, nil
	case "pl":
		return FallbackCartesiaVoiceLanguagePl, nil
	case "ru":
		return FallbackCartesiaVoiceLanguageRu, nil
	case "sv":
		return FallbackCartesiaVoiceLanguageSv, nil
	case "tr":
		return FallbackCartesiaVoiceLanguageTr, nil
	}
	var t FallbackCartesiaVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackCartesiaVoiceLanguage) Ptr() *FallbackCartesiaVoiceLanguage {
	return &f
}

// This is the model that will be used. This is optional and will default to the correct model for the voiceId.
type FallbackCartesiaVoiceModel string

const (
	FallbackCartesiaVoiceModelSonicEnglish      FallbackCartesiaVoiceModel = "sonic-english"
	FallbackCartesiaVoiceModelSonicMultilingual FallbackCartesiaVoiceModel = "sonic-multilingual"
	FallbackCartesiaVoiceModelSonicPreview      FallbackCartesiaVoiceModel = "sonic-preview"
	FallbackCartesiaVoiceModelSonic             FallbackCartesiaVoiceModel = "sonic"
)

func NewFallbackCartesiaVoiceModelFromString(s string) (FallbackCartesiaVoiceModel, error) {
	switch s {
	case "sonic-english":
		return FallbackCartesiaVoiceModelSonicEnglish, nil
	case "sonic-multilingual":
		return FallbackCartesiaVoiceModelSonicMultilingual, nil
	case "sonic-preview":
		return FallbackCartesiaVoiceModelSonicPreview, nil
	case "sonic":
		return FallbackCartesiaVoiceModelSonic, nil
	}
	var t FallbackCartesiaVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackCartesiaVoiceModel) Ptr() *FallbackCartesiaVoiceModel {
	return &f
}

type FallbackCustomVoice struct {
	// This is the voice provider that will be used. Use `custom-voice` for providers that are not natively supported.
	// This is where the voice request will be sent.
	//
	// Request Example:
	//
	// POST https://{server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "message": {
	//	    "type": "voice-request",
	//	    "text": "Hello, world!",
	//	    "sampleRate": 24000,
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// Response Expected: 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackCustomVoice) GetServer() *Server {
	if f == nil {
		return nil
	}
	return f.Server
}

func (f *FallbackCustomVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackCustomVoice) Provider() string {
	return f.provider
}

func (f *FallbackCustomVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackCustomVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackCustomVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackCustomVoice(unmarshaler.embed)
	if unmarshaler.Provider != "custom-voice" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "custom-voice", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackCustomVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackCustomVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "custom-voice",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackCustomVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackDeepgramVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackDeepgramVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackDeepgramVoice) GetVoiceId() *FallbackDeepgramVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackDeepgramVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackDeepgramVoice) Provider() string {
	return f.provider
}

func (f *FallbackDeepgramVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackDeepgramVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackDeepgramVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackDeepgramVoice(unmarshaler.embed)
	if unmarshaler.Provider != "deepgram" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "deepgram", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackDeepgramVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackDeepgramVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "deepgram",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackDeepgramVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackDeepgramVoiceId struct {
	FallbackDeepgramVoiceIdEnum FallbackDeepgramVoiceIdEnum
	String                      string

	typ string
}

func (f *FallbackDeepgramVoiceId) GetFallbackDeepgramVoiceIdEnum() FallbackDeepgramVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackDeepgramVoiceIdEnum
}

func (f *FallbackDeepgramVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackDeepgramVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackDeepgramVoiceIdEnum FallbackDeepgramVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackDeepgramVoiceIdEnum); err == nil {
		f.typ = "FallbackDeepgramVoiceIdEnum"
		f.FallbackDeepgramVoiceIdEnum = valueFallbackDeepgramVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackDeepgramVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackDeepgramVoiceIdEnum" || f.FallbackDeepgramVoiceIdEnum != "" {
		return json.Marshal(f.FallbackDeepgramVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackDeepgramVoiceIdVisitor interface {
	VisitFallbackDeepgramVoiceIdEnum(FallbackDeepgramVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackDeepgramVoiceId) Accept(visitor FallbackDeepgramVoiceIdVisitor) error {
	if f.typ == "FallbackDeepgramVoiceIdEnum" || f.FallbackDeepgramVoiceIdEnum != "" {
		return visitor.VisitFallbackDeepgramVoiceIdEnum(f.FallbackDeepgramVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackDeepgramVoiceIdEnum string

const (
	FallbackDeepgramVoiceIdEnumAsteria FallbackDeepgramVoiceIdEnum = "asteria"
	FallbackDeepgramVoiceIdEnumLuna    FallbackDeepgramVoiceIdEnum = "luna"
	FallbackDeepgramVoiceIdEnumStella  FallbackDeepgramVoiceIdEnum = "stella"
	FallbackDeepgramVoiceIdEnumAthena  FallbackDeepgramVoiceIdEnum = "athena"
	FallbackDeepgramVoiceIdEnumHera    FallbackDeepgramVoiceIdEnum = "hera"
	FallbackDeepgramVoiceIdEnumOrion   FallbackDeepgramVoiceIdEnum = "orion"
	FallbackDeepgramVoiceIdEnumArcas   FallbackDeepgramVoiceIdEnum = "arcas"
	FallbackDeepgramVoiceIdEnumPerseus FallbackDeepgramVoiceIdEnum = "perseus"
	FallbackDeepgramVoiceIdEnumAngus   FallbackDeepgramVoiceIdEnum = "angus"
	FallbackDeepgramVoiceIdEnumOrpheus FallbackDeepgramVoiceIdEnum = "orpheus"
	FallbackDeepgramVoiceIdEnumHelios  FallbackDeepgramVoiceIdEnum = "helios"
	FallbackDeepgramVoiceIdEnumZeus    FallbackDeepgramVoiceIdEnum = "zeus"
)

func NewFallbackDeepgramVoiceIdEnumFromString(s string) (FallbackDeepgramVoiceIdEnum, error) {
	switch s {
	case "asteria":
		return FallbackDeepgramVoiceIdEnumAsteria, nil
	case "luna":
		return FallbackDeepgramVoiceIdEnumLuna, nil
	case "stella":
		return FallbackDeepgramVoiceIdEnumStella, nil
	case "athena":
		return FallbackDeepgramVoiceIdEnumAthena, nil
	case "hera":
		return FallbackDeepgramVoiceIdEnumHera, nil
	case "orion":
		return FallbackDeepgramVoiceIdEnumOrion, nil
	case "arcas":
		return FallbackDeepgramVoiceIdEnumArcas, nil
	case "perseus":
		return FallbackDeepgramVoiceIdEnumPerseus, nil
	case "angus":
		return FallbackDeepgramVoiceIdEnumAngus, nil
	case "orpheus":
		return FallbackDeepgramVoiceIdEnumOrpheus, nil
	case "helios":
		return FallbackDeepgramVoiceIdEnumHelios, nil
	case "zeus":
		return FallbackDeepgramVoiceIdEnumZeus, nil
	}
	var t FallbackDeepgramVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackDeepgramVoiceIdEnum) Ptr() *FallbackDeepgramVoiceIdEnum {
	return &f
}

type FallbackElevenLabsVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
	VoiceId *FallbackElevenLabsVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Defines the stability for voice settings.
	Stability *float64 `json:"stability,omitempty" url:"stability,omitempty"`
	// Defines the similarity boost for voice settings.
	SimilarityBoost *float64 `json:"similarityBoost,omitempty" url:"similarityBoost,omitempty"`
	// Defines the style for voice settings.
	Style *float64 `json:"style,omitempty" url:"style,omitempty"`
	// Defines the use speaker boost for voice settings.
	UseSpeakerBoost *bool `json:"useSpeakerBoost,omitempty" url:"useSpeakerBoost,omitempty"`
	// Defines the optimize streaming latency for voice settings. Defaults to 3.
	OptimizeStreamingLatency *float64 `json:"optimizeStreamingLatency,omitempty" url:"optimizeStreamingLatency,omitempty"`
	// This enables the use of https://elevenlabs.io/docs/speech-synthesis/prompting#pronunciation. Defaults to false to save latency.
	//
	// @default false
	EnableSsmlParsing *bool `json:"enableSsmlParsing,omitempty" url:"enableSsmlParsing,omitempty"`
	// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
	Model *FallbackElevenLabsVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the language (ISO 639-1) that is enforced for the model. Currently only Turbo v2.5 supports language enforcement. For other models, an error will be returned if language code is provided.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackElevenLabsVoice) GetVoiceId() *FallbackElevenLabsVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackElevenLabsVoice) GetStability() *float64 {
	if f == nil {
		return nil
	}
	return f.Stability
}

func (f *FallbackElevenLabsVoice) GetSimilarityBoost() *float64 {
	if f == nil {
		return nil
	}
	return f.SimilarityBoost
}

func (f *FallbackElevenLabsVoice) GetStyle() *float64 {
	if f == nil {
		return nil
	}
	return f.Style
}

func (f *FallbackElevenLabsVoice) GetUseSpeakerBoost() *bool {
	if f == nil {
		return nil
	}
	return f.UseSpeakerBoost
}

func (f *FallbackElevenLabsVoice) GetOptimizeStreamingLatency() *float64 {
	if f == nil {
		return nil
	}
	return f.OptimizeStreamingLatency
}

func (f *FallbackElevenLabsVoice) GetEnableSsmlParsing() *bool {
	if f == nil {
		return nil
	}
	return f.EnableSsmlParsing
}

func (f *FallbackElevenLabsVoice) GetModel() *FallbackElevenLabsVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackElevenLabsVoice) GetLanguage() *string {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackElevenLabsVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackElevenLabsVoice) Provider() string {
	return f.provider
}

func (f *FallbackElevenLabsVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackElevenLabsVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackElevenLabsVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackElevenLabsVoice(unmarshaler.embed)
	if unmarshaler.Provider != "11labs" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "11labs", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackElevenLabsVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackElevenLabsVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "11labs",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackElevenLabsVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.
type FallbackElevenLabsVoiceId struct {
	FallbackElevenLabsVoiceIdEnum FallbackElevenLabsVoiceIdEnum
	String                        string

	typ string
}

func (f *FallbackElevenLabsVoiceId) GetFallbackElevenLabsVoiceIdEnum() FallbackElevenLabsVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackElevenLabsVoiceIdEnum
}

func (f *FallbackElevenLabsVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackElevenLabsVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackElevenLabsVoiceIdEnum FallbackElevenLabsVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackElevenLabsVoiceIdEnum); err == nil {
		f.typ = "FallbackElevenLabsVoiceIdEnum"
		f.FallbackElevenLabsVoiceIdEnum = valueFallbackElevenLabsVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackElevenLabsVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackElevenLabsVoiceIdEnum" || f.FallbackElevenLabsVoiceIdEnum != "" {
		return json.Marshal(f.FallbackElevenLabsVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackElevenLabsVoiceIdVisitor interface {
	VisitFallbackElevenLabsVoiceIdEnum(FallbackElevenLabsVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackElevenLabsVoiceId) Accept(visitor FallbackElevenLabsVoiceIdVisitor) error {
	if f.typ == "FallbackElevenLabsVoiceIdEnum" || f.FallbackElevenLabsVoiceIdEnum != "" {
		return visitor.VisitFallbackElevenLabsVoiceIdEnum(f.FallbackElevenLabsVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackElevenLabsVoiceIdEnum string

const (
	FallbackElevenLabsVoiceIdEnumBurt    FallbackElevenLabsVoiceIdEnum = "burt"
	FallbackElevenLabsVoiceIdEnumMarissa FallbackElevenLabsVoiceIdEnum = "marissa"
	FallbackElevenLabsVoiceIdEnumAndrea  FallbackElevenLabsVoiceIdEnum = "andrea"
	FallbackElevenLabsVoiceIdEnumSarah   FallbackElevenLabsVoiceIdEnum = "sarah"
	FallbackElevenLabsVoiceIdEnumPhillip FallbackElevenLabsVoiceIdEnum = "phillip"
	FallbackElevenLabsVoiceIdEnumSteve   FallbackElevenLabsVoiceIdEnum = "steve"
	FallbackElevenLabsVoiceIdEnumJoseph  FallbackElevenLabsVoiceIdEnum = "joseph"
	FallbackElevenLabsVoiceIdEnumMyra    FallbackElevenLabsVoiceIdEnum = "myra"
	FallbackElevenLabsVoiceIdEnumPaula   FallbackElevenLabsVoiceIdEnum = "paula"
	FallbackElevenLabsVoiceIdEnumRyan    FallbackElevenLabsVoiceIdEnum = "ryan"
	FallbackElevenLabsVoiceIdEnumDrew    FallbackElevenLabsVoiceIdEnum = "drew"
	FallbackElevenLabsVoiceIdEnumPaul    FallbackElevenLabsVoiceIdEnum = "paul"
	FallbackElevenLabsVoiceIdEnumMrb     FallbackElevenLabsVoiceIdEnum = "mrb"
	FallbackElevenLabsVoiceIdEnumMatilda FallbackElevenLabsVoiceIdEnum = "matilda"
	FallbackElevenLabsVoiceIdEnumMark    FallbackElevenLabsVoiceIdEnum = "mark"
)

func NewFallbackElevenLabsVoiceIdEnumFromString(s string) (FallbackElevenLabsVoiceIdEnum, error) {
	switch s {
	case "burt":
		return FallbackElevenLabsVoiceIdEnumBurt, nil
	case "marissa":
		return FallbackElevenLabsVoiceIdEnumMarissa, nil
	case "andrea":
		return FallbackElevenLabsVoiceIdEnumAndrea, nil
	case "sarah":
		return FallbackElevenLabsVoiceIdEnumSarah, nil
	case "phillip":
		return FallbackElevenLabsVoiceIdEnumPhillip, nil
	case "steve":
		return FallbackElevenLabsVoiceIdEnumSteve, nil
	case "joseph":
		return FallbackElevenLabsVoiceIdEnumJoseph, nil
	case "myra":
		return FallbackElevenLabsVoiceIdEnumMyra, nil
	case "paula":
		return FallbackElevenLabsVoiceIdEnumPaula, nil
	case "ryan":
		return FallbackElevenLabsVoiceIdEnumRyan, nil
	case "drew":
		return FallbackElevenLabsVoiceIdEnumDrew, nil
	case "paul":
		return FallbackElevenLabsVoiceIdEnumPaul, nil
	case "mrb":
		return FallbackElevenLabsVoiceIdEnumMrb, nil
	case "matilda":
		return FallbackElevenLabsVoiceIdEnumMatilda, nil
	case "mark":
		return FallbackElevenLabsVoiceIdEnumMark, nil
	}
	var t FallbackElevenLabsVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackElevenLabsVoiceIdEnum) Ptr() *FallbackElevenLabsVoiceIdEnum {
	return &f
}

// This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.
type FallbackElevenLabsVoiceModel string

const (
	FallbackElevenLabsVoiceModelElevenMultilingualV2 FallbackElevenLabsVoiceModel = "eleven_multilingual_v2"
	FallbackElevenLabsVoiceModelElevenTurboV2        FallbackElevenLabsVoiceModel = "eleven_turbo_v2"
	FallbackElevenLabsVoiceModelElevenTurboV25       FallbackElevenLabsVoiceModel = "eleven_turbo_v2_5"
	FallbackElevenLabsVoiceModelElevenFlashV2        FallbackElevenLabsVoiceModel = "eleven_flash_v2"
	FallbackElevenLabsVoiceModelElevenFlashV25       FallbackElevenLabsVoiceModel = "eleven_flash_v2_5"
	FallbackElevenLabsVoiceModelElevenMonolingualV1  FallbackElevenLabsVoiceModel = "eleven_monolingual_v1"
)

func NewFallbackElevenLabsVoiceModelFromString(s string) (FallbackElevenLabsVoiceModel, error) {
	switch s {
	case "eleven_multilingual_v2":
		return FallbackElevenLabsVoiceModelElevenMultilingualV2, nil
	case "eleven_turbo_v2":
		return FallbackElevenLabsVoiceModelElevenTurboV2, nil
	case "eleven_turbo_v2_5":
		return FallbackElevenLabsVoiceModelElevenTurboV25, nil
	case "eleven_flash_v2":
		return FallbackElevenLabsVoiceModelElevenFlashV2, nil
	case "eleven_flash_v2_5":
		return FallbackElevenLabsVoiceModelElevenFlashV25, nil
	case "eleven_monolingual_v1":
		return FallbackElevenLabsVoiceModelElevenMonolingualV1, nil
	}
	var t FallbackElevenLabsVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackElevenLabsVoiceModel) Ptr() *FallbackElevenLabsVoiceModel {
	return &f
}

// This is the provider-specific ID that will be used.
type FallbackLmntVoiceId struct {
	FallbackLmntVoiceIdEnum FallbackLmntVoiceIdEnum
	String                  string

	typ string
}

func (f *FallbackLmntVoiceId) GetFallbackLmntVoiceIdEnum() FallbackLmntVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackLmntVoiceIdEnum
}

func (f *FallbackLmntVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackLmntVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackLmntVoiceIdEnum FallbackLmntVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackLmntVoiceIdEnum); err == nil {
		f.typ = "FallbackLmntVoiceIdEnum"
		f.FallbackLmntVoiceIdEnum = valueFallbackLmntVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackLmntVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackLmntVoiceIdEnum" || f.FallbackLmntVoiceIdEnum != "" {
		return json.Marshal(f.FallbackLmntVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackLmntVoiceIdVisitor interface {
	VisitFallbackLmntVoiceIdEnum(FallbackLmntVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackLmntVoiceId) Accept(visitor FallbackLmntVoiceIdVisitor) error {
	if f.typ == "FallbackLmntVoiceIdEnum" || f.FallbackLmntVoiceIdEnum != "" {
		return visitor.VisitFallbackLmntVoiceIdEnum(f.FallbackLmntVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackLmntVoiceIdEnum string

const (
	FallbackLmntVoiceIdEnumLily   FallbackLmntVoiceIdEnum = "lily"
	FallbackLmntVoiceIdEnumDaniel FallbackLmntVoiceIdEnum = "daniel"
)

func NewFallbackLmntVoiceIdEnumFromString(s string) (FallbackLmntVoiceIdEnum, error) {
	switch s {
	case "lily":
		return FallbackLmntVoiceIdEnumLily, nil
	case "daniel":
		return FallbackLmntVoiceIdEnumDaniel, nil
	}
	var t FallbackLmntVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackLmntVoiceIdEnum) Ptr() *FallbackLmntVoiceIdEnum {
	return &f
}

type FallbackLmntVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackLmntVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackLmntVoice) GetVoiceId() *FallbackLmntVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackLmntVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackLmntVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackLmntVoice) Provider() string {
	return f.provider
}

func (f *FallbackLmntVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackLmntVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackLmntVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackLmntVoice(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "lmnt", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackLmntVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackLmntVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackLmntVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackNeetsVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackNeetsVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackNeetsVoice) GetVoiceId() *FallbackNeetsVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackNeetsVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackNeetsVoice) Provider() string {
	return f.provider
}

func (f *FallbackNeetsVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackNeetsVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackNeetsVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackNeetsVoice(unmarshaler.embed)
	if unmarshaler.Provider != "neets" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "neets", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackNeetsVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackNeetsVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "neets",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackNeetsVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackNeetsVoiceId struct {
	FallbackNeetsVoiceIdEnum FallbackNeetsVoiceIdEnum
	String                   string

	typ string
}

func (f *FallbackNeetsVoiceId) GetFallbackNeetsVoiceIdEnum() FallbackNeetsVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackNeetsVoiceIdEnum
}

func (f *FallbackNeetsVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackNeetsVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackNeetsVoiceIdEnum FallbackNeetsVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackNeetsVoiceIdEnum); err == nil {
		f.typ = "FallbackNeetsVoiceIdEnum"
		f.FallbackNeetsVoiceIdEnum = valueFallbackNeetsVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackNeetsVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackNeetsVoiceIdEnum" || f.FallbackNeetsVoiceIdEnum != "" {
		return json.Marshal(f.FallbackNeetsVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackNeetsVoiceIdVisitor interface {
	VisitFallbackNeetsVoiceIdEnum(FallbackNeetsVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackNeetsVoiceId) Accept(visitor FallbackNeetsVoiceIdVisitor) error {
	if f.typ == "FallbackNeetsVoiceIdEnum" || f.FallbackNeetsVoiceIdEnum != "" {
		return visitor.VisitFallbackNeetsVoiceIdEnum(f.FallbackNeetsVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackNeetsVoiceIdEnum string

const (
	FallbackNeetsVoiceIdEnumVits FallbackNeetsVoiceIdEnum = "vits"
)

func NewFallbackNeetsVoiceIdEnumFromString(s string) (FallbackNeetsVoiceIdEnum, error) {
	switch s {
	case "vits":
		return FallbackNeetsVoiceIdEnumVits, nil
	}
	var t FallbackNeetsVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackNeetsVoiceIdEnum) Ptr() *FallbackNeetsVoiceIdEnum {
	return &f
}

// This is the provider-specific ID that will be used.
// Please note that ash, ballad, coral, sage, and verse may only be used with realtime models.
type FallbackOpenAiVoiceId string

const (
	FallbackOpenAiVoiceIdAlloy   FallbackOpenAiVoiceId = "alloy"
	FallbackOpenAiVoiceIdEcho    FallbackOpenAiVoiceId = "echo"
	FallbackOpenAiVoiceIdFable   FallbackOpenAiVoiceId = "fable"
	FallbackOpenAiVoiceIdOnyx    FallbackOpenAiVoiceId = "onyx"
	FallbackOpenAiVoiceIdNova    FallbackOpenAiVoiceId = "nova"
	FallbackOpenAiVoiceIdShimmer FallbackOpenAiVoiceId = "shimmer"
	FallbackOpenAiVoiceIdAsh     FallbackOpenAiVoiceId = "ash"
	FallbackOpenAiVoiceIdBallad  FallbackOpenAiVoiceId = "ballad"
	FallbackOpenAiVoiceIdCoral   FallbackOpenAiVoiceId = "coral"
	FallbackOpenAiVoiceIdSage    FallbackOpenAiVoiceId = "sage"
	FallbackOpenAiVoiceIdVerse   FallbackOpenAiVoiceId = "verse"
)

func NewFallbackOpenAiVoiceIdFromString(s string) (FallbackOpenAiVoiceId, error) {
	switch s {
	case "alloy":
		return FallbackOpenAiVoiceIdAlloy, nil
	case "echo":
		return FallbackOpenAiVoiceIdEcho, nil
	case "fable":
		return FallbackOpenAiVoiceIdFable, nil
	case "onyx":
		return FallbackOpenAiVoiceIdOnyx, nil
	case "nova":
		return FallbackOpenAiVoiceIdNova, nil
	case "shimmer":
		return FallbackOpenAiVoiceIdShimmer, nil
	case "ash":
		return FallbackOpenAiVoiceIdAsh, nil
	case "ballad":
		return FallbackOpenAiVoiceIdBallad, nil
	case "coral":
		return FallbackOpenAiVoiceIdCoral, nil
	case "sage":
		return FallbackOpenAiVoiceIdSage, nil
	case "verse":
		return FallbackOpenAiVoiceIdVerse, nil
	}
	var t FallbackOpenAiVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackOpenAiVoiceId) Ptr() *FallbackOpenAiVoiceId {
	return &f
}

type FallbackOpenAiVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	// Please note that ash, ballad, coral, sage, and verse may only be used with realtime models.
	VoiceId FallbackOpenAiVoiceId `json:"voiceId" url:"voiceId"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackOpenAiVoice) GetVoiceId() FallbackOpenAiVoiceId {
	if f == nil {
		return ""
	}
	return f.VoiceId
}

func (f *FallbackOpenAiVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackOpenAiVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackOpenAiVoice) Provider() string {
	return f.provider
}

func (f *FallbackOpenAiVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackOpenAiVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackOpenAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackOpenAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "openai", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackOpenAiVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackOpenAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackOpenAiVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackPlan struct {
	// This is the list of voices to fallback to in the event that the primary voice provider fails.
	Voices []*FallbackPlanVoicesItem `json:"voices,omitempty" url:"voices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackPlan) GetVoices() []*FallbackPlanVoicesItem {
	if f == nil {
		return nil
	}
	return f.Voices
}

func (f *FallbackPlan) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackPlan) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackPlanVoicesItem struct {
	FallbackAzureVoice      *FallbackAzureVoice
	FallbackCartesiaVoice   *FallbackCartesiaVoice
	FallbackCustomVoice     *FallbackCustomVoice
	FallbackDeepgramVoice   *FallbackDeepgramVoice
	FallbackElevenLabsVoice *FallbackElevenLabsVoice
	FallbackLmntVoice       *FallbackLmntVoice
	FallbackNeetsVoice      *FallbackNeetsVoice
	FallbackOpenAiVoice     *FallbackOpenAiVoice
	FallbackPlayHtVoice     *FallbackPlayHtVoice
	FallbackRimeAiVoice     *FallbackRimeAiVoice
	FallbackSmallestAiVoice *FallbackSmallestAiVoice
	FallbackTavusVoice      *FallbackTavusVoice

	typ string
}

func (f *FallbackPlanVoicesItem) GetFallbackAzureVoice() *FallbackAzureVoice {
	if f == nil {
		return nil
	}
	return f.FallbackAzureVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackCartesiaVoice() *FallbackCartesiaVoice {
	if f == nil {
		return nil
	}
	return f.FallbackCartesiaVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackCustomVoice() *FallbackCustomVoice {
	if f == nil {
		return nil
	}
	return f.FallbackCustomVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackDeepgramVoice() *FallbackDeepgramVoice {
	if f == nil {
		return nil
	}
	return f.FallbackDeepgramVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackElevenLabsVoice() *FallbackElevenLabsVoice {
	if f == nil {
		return nil
	}
	return f.FallbackElevenLabsVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackLmntVoice() *FallbackLmntVoice {
	if f == nil {
		return nil
	}
	return f.FallbackLmntVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackNeetsVoice() *FallbackNeetsVoice {
	if f == nil {
		return nil
	}
	return f.FallbackNeetsVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackOpenAiVoice() *FallbackOpenAiVoice {
	if f == nil {
		return nil
	}
	return f.FallbackOpenAiVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackPlayHtVoice() *FallbackPlayHtVoice {
	if f == nil {
		return nil
	}
	return f.FallbackPlayHtVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackRimeAiVoice() *FallbackRimeAiVoice {
	if f == nil {
		return nil
	}
	return f.FallbackRimeAiVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackSmallestAiVoice() *FallbackSmallestAiVoice {
	if f == nil {
		return nil
	}
	return f.FallbackSmallestAiVoice
}

func (f *FallbackPlanVoicesItem) GetFallbackTavusVoice() *FallbackTavusVoice {
	if f == nil {
		return nil
	}
	return f.FallbackTavusVoice
}

func (f *FallbackPlanVoicesItem) UnmarshalJSON(data []byte) error {
	valueFallbackAzureVoice := new(FallbackAzureVoice)
	if err := json.Unmarshal(data, &valueFallbackAzureVoice); err == nil {
		f.typ = "FallbackAzureVoice"
		f.FallbackAzureVoice = valueFallbackAzureVoice
		return nil
	}
	valueFallbackCartesiaVoice := new(FallbackCartesiaVoice)
	if err := json.Unmarshal(data, &valueFallbackCartesiaVoice); err == nil {
		f.typ = "FallbackCartesiaVoice"
		f.FallbackCartesiaVoice = valueFallbackCartesiaVoice
		return nil
	}
	valueFallbackCustomVoice := new(FallbackCustomVoice)
	if err := json.Unmarshal(data, &valueFallbackCustomVoice); err == nil {
		f.typ = "FallbackCustomVoice"
		f.FallbackCustomVoice = valueFallbackCustomVoice
		return nil
	}
	valueFallbackDeepgramVoice := new(FallbackDeepgramVoice)
	if err := json.Unmarshal(data, &valueFallbackDeepgramVoice); err == nil {
		f.typ = "FallbackDeepgramVoice"
		f.FallbackDeepgramVoice = valueFallbackDeepgramVoice
		return nil
	}
	valueFallbackElevenLabsVoice := new(FallbackElevenLabsVoice)
	if err := json.Unmarshal(data, &valueFallbackElevenLabsVoice); err == nil {
		f.typ = "FallbackElevenLabsVoice"
		f.FallbackElevenLabsVoice = valueFallbackElevenLabsVoice
		return nil
	}
	valueFallbackLmntVoice := new(FallbackLmntVoice)
	if err := json.Unmarshal(data, &valueFallbackLmntVoice); err == nil {
		f.typ = "FallbackLmntVoice"
		f.FallbackLmntVoice = valueFallbackLmntVoice
		return nil
	}
	valueFallbackNeetsVoice := new(FallbackNeetsVoice)
	if err := json.Unmarshal(data, &valueFallbackNeetsVoice); err == nil {
		f.typ = "FallbackNeetsVoice"
		f.FallbackNeetsVoice = valueFallbackNeetsVoice
		return nil
	}
	valueFallbackOpenAiVoice := new(FallbackOpenAiVoice)
	if err := json.Unmarshal(data, &valueFallbackOpenAiVoice); err == nil {
		f.typ = "FallbackOpenAiVoice"
		f.FallbackOpenAiVoice = valueFallbackOpenAiVoice
		return nil
	}
	valueFallbackPlayHtVoice := new(FallbackPlayHtVoice)
	if err := json.Unmarshal(data, &valueFallbackPlayHtVoice); err == nil {
		f.typ = "FallbackPlayHtVoice"
		f.FallbackPlayHtVoice = valueFallbackPlayHtVoice
		return nil
	}
	valueFallbackRimeAiVoice := new(FallbackRimeAiVoice)
	if err := json.Unmarshal(data, &valueFallbackRimeAiVoice); err == nil {
		f.typ = "FallbackRimeAiVoice"
		f.FallbackRimeAiVoice = valueFallbackRimeAiVoice
		return nil
	}
	valueFallbackSmallestAiVoice := new(FallbackSmallestAiVoice)
	if err := json.Unmarshal(data, &valueFallbackSmallestAiVoice); err == nil {
		f.typ = "FallbackSmallestAiVoice"
		f.FallbackSmallestAiVoice = valueFallbackSmallestAiVoice
		return nil
	}
	valueFallbackTavusVoice := new(FallbackTavusVoice)
	if err := json.Unmarshal(data, &valueFallbackTavusVoice); err == nil {
		f.typ = "FallbackTavusVoice"
		f.FallbackTavusVoice = valueFallbackTavusVoice
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackPlanVoicesItem) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackAzureVoice" || f.FallbackAzureVoice != nil {
		return json.Marshal(f.FallbackAzureVoice)
	}
	if f.typ == "FallbackCartesiaVoice" || f.FallbackCartesiaVoice != nil {
		return json.Marshal(f.FallbackCartesiaVoice)
	}
	if f.typ == "FallbackCustomVoice" || f.FallbackCustomVoice != nil {
		return json.Marshal(f.FallbackCustomVoice)
	}
	if f.typ == "FallbackDeepgramVoice" || f.FallbackDeepgramVoice != nil {
		return json.Marshal(f.FallbackDeepgramVoice)
	}
	if f.typ == "FallbackElevenLabsVoice" || f.FallbackElevenLabsVoice != nil {
		return json.Marshal(f.FallbackElevenLabsVoice)
	}
	if f.typ == "FallbackLmntVoice" || f.FallbackLmntVoice != nil {
		return json.Marshal(f.FallbackLmntVoice)
	}
	if f.typ == "FallbackNeetsVoice" || f.FallbackNeetsVoice != nil {
		return json.Marshal(f.FallbackNeetsVoice)
	}
	if f.typ == "FallbackOpenAiVoice" || f.FallbackOpenAiVoice != nil {
		return json.Marshal(f.FallbackOpenAiVoice)
	}
	if f.typ == "FallbackPlayHtVoice" || f.FallbackPlayHtVoice != nil {
		return json.Marshal(f.FallbackPlayHtVoice)
	}
	if f.typ == "FallbackRimeAiVoice" || f.FallbackRimeAiVoice != nil {
		return json.Marshal(f.FallbackRimeAiVoice)
	}
	if f.typ == "FallbackSmallestAiVoice" || f.FallbackSmallestAiVoice != nil {
		return json.Marshal(f.FallbackSmallestAiVoice)
	}
	if f.typ == "FallbackTavusVoice" || f.FallbackTavusVoice != nil {
		return json.Marshal(f.FallbackTavusVoice)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackPlanVoicesItemVisitor interface {
	VisitFallbackAzureVoice(*FallbackAzureVoice) error
	VisitFallbackCartesiaVoice(*FallbackCartesiaVoice) error
	VisitFallbackCustomVoice(*FallbackCustomVoice) error
	VisitFallbackDeepgramVoice(*FallbackDeepgramVoice) error
	VisitFallbackElevenLabsVoice(*FallbackElevenLabsVoice) error
	VisitFallbackLmntVoice(*FallbackLmntVoice) error
	VisitFallbackNeetsVoice(*FallbackNeetsVoice) error
	VisitFallbackOpenAiVoice(*FallbackOpenAiVoice) error
	VisitFallbackPlayHtVoice(*FallbackPlayHtVoice) error
	VisitFallbackRimeAiVoice(*FallbackRimeAiVoice) error
	VisitFallbackSmallestAiVoice(*FallbackSmallestAiVoice) error
	VisitFallbackTavusVoice(*FallbackTavusVoice) error
}

func (f *FallbackPlanVoicesItem) Accept(visitor FallbackPlanVoicesItemVisitor) error {
	if f.typ == "FallbackAzureVoice" || f.FallbackAzureVoice != nil {
		return visitor.VisitFallbackAzureVoice(f.FallbackAzureVoice)
	}
	if f.typ == "FallbackCartesiaVoice" || f.FallbackCartesiaVoice != nil {
		return visitor.VisitFallbackCartesiaVoice(f.FallbackCartesiaVoice)
	}
	if f.typ == "FallbackCustomVoice" || f.FallbackCustomVoice != nil {
		return visitor.VisitFallbackCustomVoice(f.FallbackCustomVoice)
	}
	if f.typ == "FallbackDeepgramVoice" || f.FallbackDeepgramVoice != nil {
		return visitor.VisitFallbackDeepgramVoice(f.FallbackDeepgramVoice)
	}
	if f.typ == "FallbackElevenLabsVoice" || f.FallbackElevenLabsVoice != nil {
		return visitor.VisitFallbackElevenLabsVoice(f.FallbackElevenLabsVoice)
	}
	if f.typ == "FallbackLmntVoice" || f.FallbackLmntVoice != nil {
		return visitor.VisitFallbackLmntVoice(f.FallbackLmntVoice)
	}
	if f.typ == "FallbackNeetsVoice" || f.FallbackNeetsVoice != nil {
		return visitor.VisitFallbackNeetsVoice(f.FallbackNeetsVoice)
	}
	if f.typ == "FallbackOpenAiVoice" || f.FallbackOpenAiVoice != nil {
		return visitor.VisitFallbackOpenAiVoice(f.FallbackOpenAiVoice)
	}
	if f.typ == "FallbackPlayHtVoice" || f.FallbackPlayHtVoice != nil {
		return visitor.VisitFallbackPlayHtVoice(f.FallbackPlayHtVoice)
	}
	if f.typ == "FallbackRimeAiVoice" || f.FallbackRimeAiVoice != nil {
		return visitor.VisitFallbackRimeAiVoice(f.FallbackRimeAiVoice)
	}
	if f.typ == "FallbackSmallestAiVoice" || f.FallbackSmallestAiVoice != nil {
		return visitor.VisitFallbackSmallestAiVoice(f.FallbackSmallestAiVoice)
	}
	if f.typ == "FallbackTavusVoice" || f.FallbackTavusVoice != nil {
		return visitor.VisitFallbackTavusVoice(f.FallbackTavusVoice)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// This is the provider-specific ID that will be used.
type FallbackPlayHtVoiceId struct {
	FallbackPlayHtVoiceIdEnum FallbackPlayHtVoiceIdEnum
	String                    string

	typ string
}

func (f *FallbackPlayHtVoiceId) GetFallbackPlayHtVoiceIdEnum() FallbackPlayHtVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackPlayHtVoiceIdEnum
}

func (f *FallbackPlayHtVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackPlayHtVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackPlayHtVoiceIdEnum FallbackPlayHtVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackPlayHtVoiceIdEnum); err == nil {
		f.typ = "FallbackPlayHtVoiceIdEnum"
		f.FallbackPlayHtVoiceIdEnum = valueFallbackPlayHtVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackPlayHtVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackPlayHtVoiceIdEnum" || f.FallbackPlayHtVoiceIdEnum != "" {
		return json.Marshal(f.FallbackPlayHtVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackPlayHtVoiceIdVisitor interface {
	VisitFallbackPlayHtVoiceIdEnum(FallbackPlayHtVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackPlayHtVoiceId) Accept(visitor FallbackPlayHtVoiceIdVisitor) error {
	if f.typ == "FallbackPlayHtVoiceIdEnum" || f.FallbackPlayHtVoiceIdEnum != "" {
		return visitor.VisitFallbackPlayHtVoiceIdEnum(f.FallbackPlayHtVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackPlayHtVoiceIdEnum string

const (
	FallbackPlayHtVoiceIdEnumJennifer FallbackPlayHtVoiceIdEnum = "jennifer"
	FallbackPlayHtVoiceIdEnumMelissa  FallbackPlayHtVoiceIdEnum = "melissa"
	FallbackPlayHtVoiceIdEnumWill     FallbackPlayHtVoiceIdEnum = "will"
	FallbackPlayHtVoiceIdEnumChris    FallbackPlayHtVoiceIdEnum = "chris"
	FallbackPlayHtVoiceIdEnumMatt     FallbackPlayHtVoiceIdEnum = "matt"
	FallbackPlayHtVoiceIdEnumJack     FallbackPlayHtVoiceIdEnum = "jack"
	FallbackPlayHtVoiceIdEnumRuby     FallbackPlayHtVoiceIdEnum = "ruby"
	FallbackPlayHtVoiceIdEnumDavis    FallbackPlayHtVoiceIdEnum = "davis"
	FallbackPlayHtVoiceIdEnumDonna    FallbackPlayHtVoiceIdEnum = "donna"
	FallbackPlayHtVoiceIdEnumMichael  FallbackPlayHtVoiceIdEnum = "michael"
)

func NewFallbackPlayHtVoiceIdEnumFromString(s string) (FallbackPlayHtVoiceIdEnum, error) {
	switch s {
	case "jennifer":
		return FallbackPlayHtVoiceIdEnumJennifer, nil
	case "melissa":
		return FallbackPlayHtVoiceIdEnumMelissa, nil
	case "will":
		return FallbackPlayHtVoiceIdEnumWill, nil
	case "chris":
		return FallbackPlayHtVoiceIdEnumChris, nil
	case "matt":
		return FallbackPlayHtVoiceIdEnumMatt, nil
	case "jack":
		return FallbackPlayHtVoiceIdEnumJack, nil
	case "ruby":
		return FallbackPlayHtVoiceIdEnumRuby, nil
	case "davis":
		return FallbackPlayHtVoiceIdEnumDavis, nil
	case "donna":
		return FallbackPlayHtVoiceIdEnumDonna, nil
	case "michael":
		return FallbackPlayHtVoiceIdEnumMichael, nil
	}
	var t FallbackPlayHtVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackPlayHtVoiceIdEnum) Ptr() *FallbackPlayHtVoiceIdEnum {
	return &f
}

type FallbackPlayHtVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackPlayHtVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// A floating point number between 0, exclusive, and 2, inclusive. If equal to null or not provided, the model's default temperature will be used. The temperature parameter controls variance. Lower temperatures result in more predictable results, higher temperatures allow each run to vary more, so the voice may sound less like the baseline voice.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// An emotion to be applied to the speech.
	Emotion *FallbackPlayHtVoiceEmotion `json:"emotion,omitempty" url:"emotion,omitempty"`
	// A number between 1 and 6. Use lower numbers to reduce how unique your chosen voice will be compared to other voices.
	VoiceGuidance *float64 `json:"voiceGuidance,omitempty" url:"voiceGuidance,omitempty"`
	// A number between 1 and 30. Use lower numbers to to reduce how strong your chosen emotion will be. Higher numbers will create a very emotional performance.
	StyleGuidance *float64 `json:"styleGuidance,omitempty" url:"styleGuidance,omitempty"`
	// A number between 1 and 2. This number influences how closely the generated speech adheres to the input text. Use lower values to create more fluid speech, but with a higher chance of deviating from the input text. Higher numbers will make the generated speech more accurate to the input text, ensuring that the words spoken align closely with the provided text.
	TextGuidance *float64 `json:"textGuidance,omitempty" url:"textGuidance,omitempty"`
	// Playht voice model/engine to use.
	Model *FallbackPlayHtVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// The language to use for the speech.
	Language *FallbackPlayHtVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackPlayHtVoice) GetVoiceId() *FallbackPlayHtVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackPlayHtVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackPlayHtVoice) GetTemperature() *float64 {
	if f == nil {
		return nil
	}
	return f.Temperature
}

func (f *FallbackPlayHtVoice) GetEmotion() *FallbackPlayHtVoiceEmotion {
	if f == nil {
		return nil
	}
	return f.Emotion
}

func (f *FallbackPlayHtVoice) GetVoiceGuidance() *float64 {
	if f == nil {
		return nil
	}
	return f.VoiceGuidance
}

func (f *FallbackPlayHtVoice) GetStyleGuidance() *float64 {
	if f == nil {
		return nil
	}
	return f.StyleGuidance
}

func (f *FallbackPlayHtVoice) GetTextGuidance() *float64 {
	if f == nil {
		return nil
	}
	return f.TextGuidance
}

func (f *FallbackPlayHtVoice) GetModel() *FallbackPlayHtVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackPlayHtVoice) GetLanguage() *FallbackPlayHtVoiceLanguage {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *FallbackPlayHtVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackPlayHtVoice) Provider() string {
	return f.provider
}

func (f *FallbackPlayHtVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackPlayHtVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackPlayHtVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackPlayHtVoice(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "playht", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackPlayHtVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackPlayHtVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackPlayHtVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// An emotion to be applied to the speech.
type FallbackPlayHtVoiceEmotion string

const (
	FallbackPlayHtVoiceEmotionFemaleHappy     FallbackPlayHtVoiceEmotion = "female_happy"
	FallbackPlayHtVoiceEmotionFemaleSad       FallbackPlayHtVoiceEmotion = "female_sad"
	FallbackPlayHtVoiceEmotionFemaleAngry     FallbackPlayHtVoiceEmotion = "female_angry"
	FallbackPlayHtVoiceEmotionFemaleFearful   FallbackPlayHtVoiceEmotion = "female_fearful"
	FallbackPlayHtVoiceEmotionFemaleDisgust   FallbackPlayHtVoiceEmotion = "female_disgust"
	FallbackPlayHtVoiceEmotionFemaleSurprised FallbackPlayHtVoiceEmotion = "female_surprised"
	FallbackPlayHtVoiceEmotionMaleHappy       FallbackPlayHtVoiceEmotion = "male_happy"
	FallbackPlayHtVoiceEmotionMaleSad         FallbackPlayHtVoiceEmotion = "male_sad"
	FallbackPlayHtVoiceEmotionMaleAngry       FallbackPlayHtVoiceEmotion = "male_angry"
	FallbackPlayHtVoiceEmotionMaleFearful     FallbackPlayHtVoiceEmotion = "male_fearful"
	FallbackPlayHtVoiceEmotionMaleDisgust     FallbackPlayHtVoiceEmotion = "male_disgust"
	FallbackPlayHtVoiceEmotionMaleSurprised   FallbackPlayHtVoiceEmotion = "male_surprised"
)

func NewFallbackPlayHtVoiceEmotionFromString(s string) (FallbackPlayHtVoiceEmotion, error) {
	switch s {
	case "female_happy":
		return FallbackPlayHtVoiceEmotionFemaleHappy, nil
	case "female_sad":
		return FallbackPlayHtVoiceEmotionFemaleSad, nil
	case "female_angry":
		return FallbackPlayHtVoiceEmotionFemaleAngry, nil
	case "female_fearful":
		return FallbackPlayHtVoiceEmotionFemaleFearful, nil
	case "female_disgust":
		return FallbackPlayHtVoiceEmotionFemaleDisgust, nil
	case "female_surprised":
		return FallbackPlayHtVoiceEmotionFemaleSurprised, nil
	case "male_happy":
		return FallbackPlayHtVoiceEmotionMaleHappy, nil
	case "male_sad":
		return FallbackPlayHtVoiceEmotionMaleSad, nil
	case "male_angry":
		return FallbackPlayHtVoiceEmotionMaleAngry, nil
	case "male_fearful":
		return FallbackPlayHtVoiceEmotionMaleFearful, nil
	case "male_disgust":
		return FallbackPlayHtVoiceEmotionMaleDisgust, nil
	case "male_surprised":
		return FallbackPlayHtVoiceEmotionMaleSurprised, nil
	}
	var t FallbackPlayHtVoiceEmotion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackPlayHtVoiceEmotion) Ptr() *FallbackPlayHtVoiceEmotion {
	return &f
}

// The language to use for the speech.
type FallbackPlayHtVoiceLanguage string

const (
	FallbackPlayHtVoiceLanguageAfrikaans  FallbackPlayHtVoiceLanguage = "afrikaans"
	FallbackPlayHtVoiceLanguageAlbanian   FallbackPlayHtVoiceLanguage = "albanian"
	FallbackPlayHtVoiceLanguageAmharic    FallbackPlayHtVoiceLanguage = "amharic"
	FallbackPlayHtVoiceLanguageArabic     FallbackPlayHtVoiceLanguage = "arabic"
	FallbackPlayHtVoiceLanguageBengali    FallbackPlayHtVoiceLanguage = "bengali"
	FallbackPlayHtVoiceLanguageBulgarian  FallbackPlayHtVoiceLanguage = "bulgarian"
	FallbackPlayHtVoiceLanguageCatalan    FallbackPlayHtVoiceLanguage = "catalan"
	FallbackPlayHtVoiceLanguageCroatian   FallbackPlayHtVoiceLanguage = "croatian"
	FallbackPlayHtVoiceLanguageCzech      FallbackPlayHtVoiceLanguage = "czech"
	FallbackPlayHtVoiceLanguageDanish     FallbackPlayHtVoiceLanguage = "danish"
	FallbackPlayHtVoiceLanguageDutch      FallbackPlayHtVoiceLanguage = "dutch"
	FallbackPlayHtVoiceLanguageEnglish    FallbackPlayHtVoiceLanguage = "english"
	FallbackPlayHtVoiceLanguageFrench     FallbackPlayHtVoiceLanguage = "french"
	FallbackPlayHtVoiceLanguageGalician   FallbackPlayHtVoiceLanguage = "galician"
	FallbackPlayHtVoiceLanguageGerman     FallbackPlayHtVoiceLanguage = "german"
	FallbackPlayHtVoiceLanguageGreek      FallbackPlayHtVoiceLanguage = "greek"
	FallbackPlayHtVoiceLanguageHebrew     FallbackPlayHtVoiceLanguage = "hebrew"
	FallbackPlayHtVoiceLanguageHindi      FallbackPlayHtVoiceLanguage = "hindi"
	FallbackPlayHtVoiceLanguageHungarian  FallbackPlayHtVoiceLanguage = "hungarian"
	FallbackPlayHtVoiceLanguageIndonesian FallbackPlayHtVoiceLanguage = "indonesian"
	FallbackPlayHtVoiceLanguageItalian    FallbackPlayHtVoiceLanguage = "italian"
	FallbackPlayHtVoiceLanguageJapanese   FallbackPlayHtVoiceLanguage = "japanese"
	FallbackPlayHtVoiceLanguageKorean     FallbackPlayHtVoiceLanguage = "korean"
	FallbackPlayHtVoiceLanguageMalay      FallbackPlayHtVoiceLanguage = "malay"
	FallbackPlayHtVoiceLanguageMandarin   FallbackPlayHtVoiceLanguage = "mandarin"
	FallbackPlayHtVoiceLanguagePolish     FallbackPlayHtVoiceLanguage = "polish"
	FallbackPlayHtVoiceLanguagePortuguese FallbackPlayHtVoiceLanguage = "portuguese"
	FallbackPlayHtVoiceLanguageRussian    FallbackPlayHtVoiceLanguage = "russian"
	FallbackPlayHtVoiceLanguageSerbian    FallbackPlayHtVoiceLanguage = "serbian"
	FallbackPlayHtVoiceLanguageSpanish    FallbackPlayHtVoiceLanguage = "spanish"
	FallbackPlayHtVoiceLanguageSwedish    FallbackPlayHtVoiceLanguage = "swedish"
	FallbackPlayHtVoiceLanguageTagalog    FallbackPlayHtVoiceLanguage = "tagalog"
	FallbackPlayHtVoiceLanguageThai       FallbackPlayHtVoiceLanguage = "thai"
	FallbackPlayHtVoiceLanguageTurkish    FallbackPlayHtVoiceLanguage = "turkish"
	FallbackPlayHtVoiceLanguageUkrainian  FallbackPlayHtVoiceLanguage = "ukrainian"
	FallbackPlayHtVoiceLanguageUrdu       FallbackPlayHtVoiceLanguage = "urdu"
	FallbackPlayHtVoiceLanguageXhosa      FallbackPlayHtVoiceLanguage = "xhosa"
)

func NewFallbackPlayHtVoiceLanguageFromString(s string) (FallbackPlayHtVoiceLanguage, error) {
	switch s {
	case "afrikaans":
		return FallbackPlayHtVoiceLanguageAfrikaans, nil
	case "albanian":
		return FallbackPlayHtVoiceLanguageAlbanian, nil
	case "amharic":
		return FallbackPlayHtVoiceLanguageAmharic, nil
	case "arabic":
		return FallbackPlayHtVoiceLanguageArabic, nil
	case "bengali":
		return FallbackPlayHtVoiceLanguageBengali, nil
	case "bulgarian":
		return FallbackPlayHtVoiceLanguageBulgarian, nil
	case "catalan":
		return FallbackPlayHtVoiceLanguageCatalan, nil
	case "croatian":
		return FallbackPlayHtVoiceLanguageCroatian, nil
	case "czech":
		return FallbackPlayHtVoiceLanguageCzech, nil
	case "danish":
		return FallbackPlayHtVoiceLanguageDanish, nil
	case "dutch":
		return FallbackPlayHtVoiceLanguageDutch, nil
	case "english":
		return FallbackPlayHtVoiceLanguageEnglish, nil
	case "french":
		return FallbackPlayHtVoiceLanguageFrench, nil
	case "galician":
		return FallbackPlayHtVoiceLanguageGalician, nil
	case "german":
		return FallbackPlayHtVoiceLanguageGerman, nil
	case "greek":
		return FallbackPlayHtVoiceLanguageGreek, nil
	case "hebrew":
		return FallbackPlayHtVoiceLanguageHebrew, nil
	case "hindi":
		return FallbackPlayHtVoiceLanguageHindi, nil
	case "hungarian":
		return FallbackPlayHtVoiceLanguageHungarian, nil
	case "indonesian":
		return FallbackPlayHtVoiceLanguageIndonesian, nil
	case "italian":
		return FallbackPlayHtVoiceLanguageItalian, nil
	case "japanese":
		return FallbackPlayHtVoiceLanguageJapanese, nil
	case "korean":
		return FallbackPlayHtVoiceLanguageKorean, nil
	case "malay":
		return FallbackPlayHtVoiceLanguageMalay, nil
	case "mandarin":
		return FallbackPlayHtVoiceLanguageMandarin, nil
	case "polish":
		return FallbackPlayHtVoiceLanguagePolish, nil
	case "portuguese":
		return FallbackPlayHtVoiceLanguagePortuguese, nil
	case "russian":
		return FallbackPlayHtVoiceLanguageRussian, nil
	case "serbian":
		return FallbackPlayHtVoiceLanguageSerbian, nil
	case "spanish":
		return FallbackPlayHtVoiceLanguageSpanish, nil
	case "swedish":
		return FallbackPlayHtVoiceLanguageSwedish, nil
	case "tagalog":
		return FallbackPlayHtVoiceLanguageTagalog, nil
	case "thai":
		return FallbackPlayHtVoiceLanguageThai, nil
	case "turkish":
		return FallbackPlayHtVoiceLanguageTurkish, nil
	case "ukrainian":
		return FallbackPlayHtVoiceLanguageUkrainian, nil
	case "urdu":
		return FallbackPlayHtVoiceLanguageUrdu, nil
	case "xhosa":
		return FallbackPlayHtVoiceLanguageXhosa, nil
	}
	var t FallbackPlayHtVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackPlayHtVoiceLanguage) Ptr() *FallbackPlayHtVoiceLanguage {
	return &f
}

// Playht voice model/engine to use.
type FallbackPlayHtVoiceModel string

const (
	FallbackPlayHtVoiceModelPlayHt20      FallbackPlayHtVoiceModel = "PlayHT2.0"
	FallbackPlayHtVoiceModelPlayHt20Turbo FallbackPlayHtVoiceModel = "PlayHT2.0-turbo"
	FallbackPlayHtVoiceModelPlay30Mini    FallbackPlayHtVoiceModel = "Play3.0-mini"
)

func NewFallbackPlayHtVoiceModelFromString(s string) (FallbackPlayHtVoiceModel, error) {
	switch s {
	case "PlayHT2.0":
		return FallbackPlayHtVoiceModelPlayHt20, nil
	case "PlayHT2.0-turbo":
		return FallbackPlayHtVoiceModelPlayHt20Turbo, nil
	case "Play3.0-mini":
		return FallbackPlayHtVoiceModelPlay30Mini, nil
	}
	var t FallbackPlayHtVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackPlayHtVoiceModel) Ptr() *FallbackPlayHtVoiceModel {
	return &f
}

// This is the provider-specific ID that will be used.
type FallbackRimeAiVoiceId struct {
	FallbackRimeAiVoiceIdEnum FallbackRimeAiVoiceIdEnum
	String                    string

	typ string
}

func (f *FallbackRimeAiVoiceId) GetFallbackRimeAiVoiceIdEnum() FallbackRimeAiVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackRimeAiVoiceIdEnum
}

func (f *FallbackRimeAiVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackRimeAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackRimeAiVoiceIdEnum FallbackRimeAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackRimeAiVoiceIdEnum); err == nil {
		f.typ = "FallbackRimeAiVoiceIdEnum"
		f.FallbackRimeAiVoiceIdEnum = valueFallbackRimeAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackRimeAiVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackRimeAiVoiceIdEnum" || f.FallbackRimeAiVoiceIdEnum != "" {
		return json.Marshal(f.FallbackRimeAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackRimeAiVoiceIdVisitor interface {
	VisitFallbackRimeAiVoiceIdEnum(FallbackRimeAiVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackRimeAiVoiceId) Accept(visitor FallbackRimeAiVoiceIdVisitor) error {
	if f.typ == "FallbackRimeAiVoiceIdEnum" || f.FallbackRimeAiVoiceIdEnum != "" {
		return visitor.VisitFallbackRimeAiVoiceIdEnum(f.FallbackRimeAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackRimeAiVoiceIdEnum string

const (
	FallbackRimeAiVoiceIdEnumMarsh      FallbackRimeAiVoiceIdEnum = "marsh"
	FallbackRimeAiVoiceIdEnumBayou      FallbackRimeAiVoiceIdEnum = "bayou"
	FallbackRimeAiVoiceIdEnumCreek      FallbackRimeAiVoiceIdEnum = "creek"
	FallbackRimeAiVoiceIdEnumBrook      FallbackRimeAiVoiceIdEnum = "brook"
	FallbackRimeAiVoiceIdEnumFlower     FallbackRimeAiVoiceIdEnum = "flower"
	FallbackRimeAiVoiceIdEnumSpore      FallbackRimeAiVoiceIdEnum = "spore"
	FallbackRimeAiVoiceIdEnumGlacier    FallbackRimeAiVoiceIdEnum = "glacier"
	FallbackRimeAiVoiceIdEnumGulch      FallbackRimeAiVoiceIdEnum = "gulch"
	FallbackRimeAiVoiceIdEnumAlpine     FallbackRimeAiVoiceIdEnum = "alpine"
	FallbackRimeAiVoiceIdEnumCove       FallbackRimeAiVoiceIdEnum = "cove"
	FallbackRimeAiVoiceIdEnumLagoon     FallbackRimeAiVoiceIdEnum = "lagoon"
	FallbackRimeAiVoiceIdEnumTundra     FallbackRimeAiVoiceIdEnum = "tundra"
	FallbackRimeAiVoiceIdEnumSteppe     FallbackRimeAiVoiceIdEnum = "steppe"
	FallbackRimeAiVoiceIdEnumMesa       FallbackRimeAiVoiceIdEnum = "mesa"
	FallbackRimeAiVoiceIdEnumGrove      FallbackRimeAiVoiceIdEnum = "grove"
	FallbackRimeAiVoiceIdEnumRainforest FallbackRimeAiVoiceIdEnum = "rainforest"
	FallbackRimeAiVoiceIdEnumMoraine    FallbackRimeAiVoiceIdEnum = "moraine"
	FallbackRimeAiVoiceIdEnumWildflower FallbackRimeAiVoiceIdEnum = "wildflower"
	FallbackRimeAiVoiceIdEnumPeak       FallbackRimeAiVoiceIdEnum = "peak"
	FallbackRimeAiVoiceIdEnumBoulder    FallbackRimeAiVoiceIdEnum = "boulder"
	FallbackRimeAiVoiceIdEnumAbbie      FallbackRimeAiVoiceIdEnum = "abbie"
	FallbackRimeAiVoiceIdEnumAllison    FallbackRimeAiVoiceIdEnum = "allison"
	FallbackRimeAiVoiceIdEnumAlly       FallbackRimeAiVoiceIdEnum = "ally"
	FallbackRimeAiVoiceIdEnumAlona      FallbackRimeAiVoiceIdEnum = "alona"
	FallbackRimeAiVoiceIdEnumAmber      FallbackRimeAiVoiceIdEnum = "amber"
	FallbackRimeAiVoiceIdEnumAna        FallbackRimeAiVoiceIdEnum = "ana"
	FallbackRimeAiVoiceIdEnumAntoine    FallbackRimeAiVoiceIdEnum = "antoine"
	FallbackRimeAiVoiceIdEnumArmon      FallbackRimeAiVoiceIdEnum = "armon"
	FallbackRimeAiVoiceIdEnumBrenda     FallbackRimeAiVoiceIdEnum = "brenda"
	FallbackRimeAiVoiceIdEnumBrittany   FallbackRimeAiVoiceIdEnum = "brittany"
	FallbackRimeAiVoiceIdEnumCarol      FallbackRimeAiVoiceIdEnum = "carol"
	FallbackRimeAiVoiceIdEnumColin      FallbackRimeAiVoiceIdEnum = "colin"
	FallbackRimeAiVoiceIdEnumCourtney   FallbackRimeAiVoiceIdEnum = "courtney"
	FallbackRimeAiVoiceIdEnumElena      FallbackRimeAiVoiceIdEnum = "elena"
	FallbackRimeAiVoiceIdEnumElliot     FallbackRimeAiVoiceIdEnum = "elliot"
	FallbackRimeAiVoiceIdEnumEva        FallbackRimeAiVoiceIdEnum = "eva"
	FallbackRimeAiVoiceIdEnumGeoff      FallbackRimeAiVoiceIdEnum = "geoff"
	FallbackRimeAiVoiceIdEnumGerald     FallbackRimeAiVoiceIdEnum = "gerald"
	FallbackRimeAiVoiceIdEnumHank       FallbackRimeAiVoiceIdEnum = "hank"
	FallbackRimeAiVoiceIdEnumHelen      FallbackRimeAiVoiceIdEnum = "helen"
	FallbackRimeAiVoiceIdEnumHera       FallbackRimeAiVoiceIdEnum = "hera"
	FallbackRimeAiVoiceIdEnumJen        FallbackRimeAiVoiceIdEnum = "jen"
	FallbackRimeAiVoiceIdEnumJoe        FallbackRimeAiVoiceIdEnum = "joe"
	FallbackRimeAiVoiceIdEnumJoy        FallbackRimeAiVoiceIdEnum = "joy"
	FallbackRimeAiVoiceIdEnumJuan       FallbackRimeAiVoiceIdEnum = "juan"
	FallbackRimeAiVoiceIdEnumKendra     FallbackRimeAiVoiceIdEnum = "kendra"
	FallbackRimeAiVoiceIdEnumKendrick   FallbackRimeAiVoiceIdEnum = "kendrick"
	FallbackRimeAiVoiceIdEnumKenneth    FallbackRimeAiVoiceIdEnum = "kenneth"
	FallbackRimeAiVoiceIdEnumKevin      FallbackRimeAiVoiceIdEnum = "kevin"
	FallbackRimeAiVoiceIdEnumKris       FallbackRimeAiVoiceIdEnum = "kris"
	FallbackRimeAiVoiceIdEnumLinda      FallbackRimeAiVoiceIdEnum = "linda"
	FallbackRimeAiVoiceIdEnumMadison    FallbackRimeAiVoiceIdEnum = "madison"
	FallbackRimeAiVoiceIdEnumMarge      FallbackRimeAiVoiceIdEnum = "marge"
	FallbackRimeAiVoiceIdEnumMarina     FallbackRimeAiVoiceIdEnum = "marina"
	FallbackRimeAiVoiceIdEnumMarissa    FallbackRimeAiVoiceIdEnum = "marissa"
	FallbackRimeAiVoiceIdEnumMarta      FallbackRimeAiVoiceIdEnum = "marta"
	FallbackRimeAiVoiceIdEnumMaya       FallbackRimeAiVoiceIdEnum = "maya"
	FallbackRimeAiVoiceIdEnumNicholas   FallbackRimeAiVoiceIdEnum = "nicholas"
	FallbackRimeAiVoiceIdEnumNyles      FallbackRimeAiVoiceIdEnum = "nyles"
	FallbackRimeAiVoiceIdEnumPhil       FallbackRimeAiVoiceIdEnum = "phil"
	FallbackRimeAiVoiceIdEnumReba       FallbackRimeAiVoiceIdEnum = "reba"
	FallbackRimeAiVoiceIdEnumRex        FallbackRimeAiVoiceIdEnum = "rex"
	FallbackRimeAiVoiceIdEnumRick       FallbackRimeAiVoiceIdEnum = "rick"
	FallbackRimeAiVoiceIdEnumRitu       FallbackRimeAiVoiceIdEnum = "ritu"
	FallbackRimeAiVoiceIdEnumRob        FallbackRimeAiVoiceIdEnum = "rob"
	FallbackRimeAiVoiceIdEnumRodney     FallbackRimeAiVoiceIdEnum = "rodney"
	FallbackRimeAiVoiceIdEnumRohan      FallbackRimeAiVoiceIdEnum = "rohan"
	FallbackRimeAiVoiceIdEnumRosco      FallbackRimeAiVoiceIdEnum = "rosco"
	FallbackRimeAiVoiceIdEnumSamantha   FallbackRimeAiVoiceIdEnum = "samantha"
	FallbackRimeAiVoiceIdEnumSandy      FallbackRimeAiVoiceIdEnum = "sandy"
	FallbackRimeAiVoiceIdEnumSelena     FallbackRimeAiVoiceIdEnum = "selena"
	FallbackRimeAiVoiceIdEnumSeth       FallbackRimeAiVoiceIdEnum = "seth"
	FallbackRimeAiVoiceIdEnumSharon     FallbackRimeAiVoiceIdEnum = "sharon"
	FallbackRimeAiVoiceIdEnumStan       FallbackRimeAiVoiceIdEnum = "stan"
	FallbackRimeAiVoiceIdEnumTamra      FallbackRimeAiVoiceIdEnum = "tamra"
	FallbackRimeAiVoiceIdEnumTanya      FallbackRimeAiVoiceIdEnum = "tanya"
	FallbackRimeAiVoiceIdEnumTibur      FallbackRimeAiVoiceIdEnum = "tibur"
	FallbackRimeAiVoiceIdEnumTj         FallbackRimeAiVoiceIdEnum = "tj"
	FallbackRimeAiVoiceIdEnumTyler      FallbackRimeAiVoiceIdEnum = "tyler"
	FallbackRimeAiVoiceIdEnumViv        FallbackRimeAiVoiceIdEnum = "viv"
	FallbackRimeAiVoiceIdEnumYadira     FallbackRimeAiVoiceIdEnum = "yadira"
)

func NewFallbackRimeAiVoiceIdEnumFromString(s string) (FallbackRimeAiVoiceIdEnum, error) {
	switch s {
	case "marsh":
		return FallbackRimeAiVoiceIdEnumMarsh, nil
	case "bayou":
		return FallbackRimeAiVoiceIdEnumBayou, nil
	case "creek":
		return FallbackRimeAiVoiceIdEnumCreek, nil
	case "brook":
		return FallbackRimeAiVoiceIdEnumBrook, nil
	case "flower":
		return FallbackRimeAiVoiceIdEnumFlower, nil
	case "spore":
		return FallbackRimeAiVoiceIdEnumSpore, nil
	case "glacier":
		return FallbackRimeAiVoiceIdEnumGlacier, nil
	case "gulch":
		return FallbackRimeAiVoiceIdEnumGulch, nil
	case "alpine":
		return FallbackRimeAiVoiceIdEnumAlpine, nil
	case "cove":
		return FallbackRimeAiVoiceIdEnumCove, nil
	case "lagoon":
		return FallbackRimeAiVoiceIdEnumLagoon, nil
	case "tundra":
		return FallbackRimeAiVoiceIdEnumTundra, nil
	case "steppe":
		return FallbackRimeAiVoiceIdEnumSteppe, nil
	case "mesa":
		return FallbackRimeAiVoiceIdEnumMesa, nil
	case "grove":
		return FallbackRimeAiVoiceIdEnumGrove, nil
	case "rainforest":
		return FallbackRimeAiVoiceIdEnumRainforest, nil
	case "moraine":
		return FallbackRimeAiVoiceIdEnumMoraine, nil
	case "wildflower":
		return FallbackRimeAiVoiceIdEnumWildflower, nil
	case "peak":
		return FallbackRimeAiVoiceIdEnumPeak, nil
	case "boulder":
		return FallbackRimeAiVoiceIdEnumBoulder, nil
	case "abbie":
		return FallbackRimeAiVoiceIdEnumAbbie, nil
	case "allison":
		return FallbackRimeAiVoiceIdEnumAllison, nil
	case "ally":
		return FallbackRimeAiVoiceIdEnumAlly, nil
	case "alona":
		return FallbackRimeAiVoiceIdEnumAlona, nil
	case "amber":
		return FallbackRimeAiVoiceIdEnumAmber, nil
	case "ana":
		return FallbackRimeAiVoiceIdEnumAna, nil
	case "antoine":
		return FallbackRimeAiVoiceIdEnumAntoine, nil
	case "armon":
		return FallbackRimeAiVoiceIdEnumArmon, nil
	case "brenda":
		return FallbackRimeAiVoiceIdEnumBrenda, nil
	case "brittany":
		return FallbackRimeAiVoiceIdEnumBrittany, nil
	case "carol":
		return FallbackRimeAiVoiceIdEnumCarol, nil
	case "colin":
		return FallbackRimeAiVoiceIdEnumColin, nil
	case "courtney":
		return FallbackRimeAiVoiceIdEnumCourtney, nil
	case "elena":
		return FallbackRimeAiVoiceIdEnumElena, nil
	case "elliot":
		return FallbackRimeAiVoiceIdEnumElliot, nil
	case "eva":
		return FallbackRimeAiVoiceIdEnumEva, nil
	case "geoff":
		return FallbackRimeAiVoiceIdEnumGeoff, nil
	case "gerald":
		return FallbackRimeAiVoiceIdEnumGerald, nil
	case "hank":
		return FallbackRimeAiVoiceIdEnumHank, nil
	case "helen":
		return FallbackRimeAiVoiceIdEnumHelen, nil
	case "hera":
		return FallbackRimeAiVoiceIdEnumHera, nil
	case "jen":
		return FallbackRimeAiVoiceIdEnumJen, nil
	case "joe":
		return FallbackRimeAiVoiceIdEnumJoe, nil
	case "joy":
		return FallbackRimeAiVoiceIdEnumJoy, nil
	case "juan":
		return FallbackRimeAiVoiceIdEnumJuan, nil
	case "kendra":
		return FallbackRimeAiVoiceIdEnumKendra, nil
	case "kendrick":
		return FallbackRimeAiVoiceIdEnumKendrick, nil
	case "kenneth":
		return FallbackRimeAiVoiceIdEnumKenneth, nil
	case "kevin":
		return FallbackRimeAiVoiceIdEnumKevin, nil
	case "kris":
		return FallbackRimeAiVoiceIdEnumKris, nil
	case "linda":
		return FallbackRimeAiVoiceIdEnumLinda, nil
	case "madison":
		return FallbackRimeAiVoiceIdEnumMadison, nil
	case "marge":
		return FallbackRimeAiVoiceIdEnumMarge, nil
	case "marina":
		return FallbackRimeAiVoiceIdEnumMarina, nil
	case "marissa":
		return FallbackRimeAiVoiceIdEnumMarissa, nil
	case "marta":
		return FallbackRimeAiVoiceIdEnumMarta, nil
	case "maya":
		return FallbackRimeAiVoiceIdEnumMaya, nil
	case "nicholas":
		return FallbackRimeAiVoiceIdEnumNicholas, nil
	case "nyles":
		return FallbackRimeAiVoiceIdEnumNyles, nil
	case "phil":
		return FallbackRimeAiVoiceIdEnumPhil, nil
	case "reba":
		return FallbackRimeAiVoiceIdEnumReba, nil
	case "rex":
		return FallbackRimeAiVoiceIdEnumRex, nil
	case "rick":
		return FallbackRimeAiVoiceIdEnumRick, nil
	case "ritu":
		return FallbackRimeAiVoiceIdEnumRitu, nil
	case "rob":
		return FallbackRimeAiVoiceIdEnumRob, nil
	case "rodney":
		return FallbackRimeAiVoiceIdEnumRodney, nil
	case "rohan":
		return FallbackRimeAiVoiceIdEnumRohan, nil
	case "rosco":
		return FallbackRimeAiVoiceIdEnumRosco, nil
	case "samantha":
		return FallbackRimeAiVoiceIdEnumSamantha, nil
	case "sandy":
		return FallbackRimeAiVoiceIdEnumSandy, nil
	case "selena":
		return FallbackRimeAiVoiceIdEnumSelena, nil
	case "seth":
		return FallbackRimeAiVoiceIdEnumSeth, nil
	case "sharon":
		return FallbackRimeAiVoiceIdEnumSharon, nil
	case "stan":
		return FallbackRimeAiVoiceIdEnumStan, nil
	case "tamra":
		return FallbackRimeAiVoiceIdEnumTamra, nil
	case "tanya":
		return FallbackRimeAiVoiceIdEnumTanya, nil
	case "tibur":
		return FallbackRimeAiVoiceIdEnumTibur, nil
	case "tj":
		return FallbackRimeAiVoiceIdEnumTj, nil
	case "tyler":
		return FallbackRimeAiVoiceIdEnumTyler, nil
	case "viv":
		return FallbackRimeAiVoiceIdEnumViv, nil
	case "yadira":
		return FallbackRimeAiVoiceIdEnumYadira, nil
	}
	var t FallbackRimeAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackRimeAiVoiceIdEnum) Ptr() *FallbackRimeAiVoiceIdEnum {
	return &f
}

type FallbackRimeAiVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackRimeAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the model that will be used. Defaults to 'v1' when not specified.
	Model *FallbackRimeAiVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackRimeAiVoice) GetVoiceId() *FallbackRimeAiVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackRimeAiVoice) GetModel() *FallbackRimeAiVoiceModel {
	if f == nil {
		return nil
	}
	return f.Model
}

func (f *FallbackRimeAiVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackRimeAiVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackRimeAiVoice) Provider() string {
	return f.provider
}

func (f *FallbackRimeAiVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackRimeAiVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackRimeAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackRimeAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "rime-ai", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackRimeAiVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackRimeAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackRimeAiVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the model that will be used. Defaults to 'v1' when not specified.
type FallbackRimeAiVoiceModel string

const (
	FallbackRimeAiVoiceModelV1   FallbackRimeAiVoiceModel = "v1"
	FallbackRimeAiVoiceModelMist FallbackRimeAiVoiceModel = "mist"
)

func NewFallbackRimeAiVoiceModelFromString(s string) (FallbackRimeAiVoiceModel, error) {
	switch s {
	case "v1":
		return FallbackRimeAiVoiceModelV1, nil
	case "mist":
		return FallbackRimeAiVoiceModelMist, nil
	}
	var t FallbackRimeAiVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackRimeAiVoiceModel) Ptr() *FallbackRimeAiVoiceModel {
	return &f
}

// This is the provider-specific ID that will be used.
type FallbackSmallestAiVoiceId struct {
	FallbackSmallestAiVoiceIdEnum FallbackSmallestAiVoiceIdEnum
	String                        string

	typ string
}

func (f *FallbackSmallestAiVoiceId) GetFallbackSmallestAiVoiceIdEnum() FallbackSmallestAiVoiceIdEnum {
	if f == nil {
		return ""
	}
	return f.FallbackSmallestAiVoiceIdEnum
}

func (f *FallbackSmallestAiVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackSmallestAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueFallbackSmallestAiVoiceIdEnum FallbackSmallestAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueFallbackSmallestAiVoiceIdEnum); err == nil {
		f.typ = "FallbackSmallestAiVoiceIdEnum"
		f.FallbackSmallestAiVoiceIdEnum = valueFallbackSmallestAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackSmallestAiVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "FallbackSmallestAiVoiceIdEnum" || f.FallbackSmallestAiVoiceIdEnum != "" {
		return json.Marshal(f.FallbackSmallestAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackSmallestAiVoiceIdVisitor interface {
	VisitFallbackSmallestAiVoiceIdEnum(FallbackSmallestAiVoiceIdEnum) error
	VisitString(string) error
}

func (f *FallbackSmallestAiVoiceId) Accept(visitor FallbackSmallestAiVoiceIdVisitor) error {
	if f.typ == "FallbackSmallestAiVoiceIdEnum" || f.FallbackSmallestAiVoiceIdEnum != "" {
		return visitor.VisitFallbackSmallestAiVoiceIdEnum(f.FallbackSmallestAiVoiceIdEnum)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackSmallestAiVoiceIdEnum string

const (
	FallbackSmallestAiVoiceIdEnumEmily    FallbackSmallestAiVoiceIdEnum = "emily"
	FallbackSmallestAiVoiceIdEnumJasmine  FallbackSmallestAiVoiceIdEnum = "jasmine"
	FallbackSmallestAiVoiceIdEnumArman    FallbackSmallestAiVoiceIdEnum = "arman"
	FallbackSmallestAiVoiceIdEnumJames    FallbackSmallestAiVoiceIdEnum = "james"
	FallbackSmallestAiVoiceIdEnumMithali  FallbackSmallestAiVoiceIdEnum = "mithali"
	FallbackSmallestAiVoiceIdEnumAravind  FallbackSmallestAiVoiceIdEnum = "aravind"
	FallbackSmallestAiVoiceIdEnumRaj      FallbackSmallestAiVoiceIdEnum = "raj"
	FallbackSmallestAiVoiceIdEnumDiya     FallbackSmallestAiVoiceIdEnum = "diya"
	FallbackSmallestAiVoiceIdEnumRaman    FallbackSmallestAiVoiceIdEnum = "raman"
	FallbackSmallestAiVoiceIdEnumAnanya   FallbackSmallestAiVoiceIdEnum = "ananya"
	FallbackSmallestAiVoiceIdEnumIsha     FallbackSmallestAiVoiceIdEnum = "isha"
	FallbackSmallestAiVoiceIdEnumWilliam  FallbackSmallestAiVoiceIdEnum = "william"
	FallbackSmallestAiVoiceIdEnumAarav    FallbackSmallestAiVoiceIdEnum = "aarav"
	FallbackSmallestAiVoiceIdEnumMonika   FallbackSmallestAiVoiceIdEnum = "monika"
	FallbackSmallestAiVoiceIdEnumNiharika FallbackSmallestAiVoiceIdEnum = "niharika"
	FallbackSmallestAiVoiceIdEnumDeepika  FallbackSmallestAiVoiceIdEnum = "deepika"
	FallbackSmallestAiVoiceIdEnumRaghav   FallbackSmallestAiVoiceIdEnum = "raghav"
	FallbackSmallestAiVoiceIdEnumKajal    FallbackSmallestAiVoiceIdEnum = "kajal"
	FallbackSmallestAiVoiceIdEnumRadhika  FallbackSmallestAiVoiceIdEnum = "radhika"
	FallbackSmallestAiVoiceIdEnumMansi    FallbackSmallestAiVoiceIdEnum = "mansi"
	FallbackSmallestAiVoiceIdEnumNisha    FallbackSmallestAiVoiceIdEnum = "nisha"
	FallbackSmallestAiVoiceIdEnumSaurabh  FallbackSmallestAiVoiceIdEnum = "saurabh"
	FallbackSmallestAiVoiceIdEnumPooja    FallbackSmallestAiVoiceIdEnum = "pooja"
	FallbackSmallestAiVoiceIdEnumSaina    FallbackSmallestAiVoiceIdEnum = "saina"
	FallbackSmallestAiVoiceIdEnumSanya    FallbackSmallestAiVoiceIdEnum = "sanya"
)

func NewFallbackSmallestAiVoiceIdEnumFromString(s string) (FallbackSmallestAiVoiceIdEnum, error) {
	switch s {
	case "emily":
		return FallbackSmallestAiVoiceIdEnumEmily, nil
	case "jasmine":
		return FallbackSmallestAiVoiceIdEnumJasmine, nil
	case "arman":
		return FallbackSmallestAiVoiceIdEnumArman, nil
	case "james":
		return FallbackSmallestAiVoiceIdEnumJames, nil
	case "mithali":
		return FallbackSmallestAiVoiceIdEnumMithali, nil
	case "aravind":
		return FallbackSmallestAiVoiceIdEnumAravind, nil
	case "raj":
		return FallbackSmallestAiVoiceIdEnumRaj, nil
	case "diya":
		return FallbackSmallestAiVoiceIdEnumDiya, nil
	case "raman":
		return FallbackSmallestAiVoiceIdEnumRaman, nil
	case "ananya":
		return FallbackSmallestAiVoiceIdEnumAnanya, nil
	case "isha":
		return FallbackSmallestAiVoiceIdEnumIsha, nil
	case "william":
		return FallbackSmallestAiVoiceIdEnumWilliam, nil
	case "aarav":
		return FallbackSmallestAiVoiceIdEnumAarav, nil
	case "monika":
		return FallbackSmallestAiVoiceIdEnumMonika, nil
	case "niharika":
		return FallbackSmallestAiVoiceIdEnumNiharika, nil
	case "deepika":
		return FallbackSmallestAiVoiceIdEnumDeepika, nil
	case "raghav":
		return FallbackSmallestAiVoiceIdEnumRaghav, nil
	case "kajal":
		return FallbackSmallestAiVoiceIdEnumKajal, nil
	case "radhika":
		return FallbackSmallestAiVoiceIdEnumRadhika, nil
	case "mansi":
		return FallbackSmallestAiVoiceIdEnumMansi, nil
	case "nisha":
		return FallbackSmallestAiVoiceIdEnumNisha, nil
	case "saurabh":
		return FallbackSmallestAiVoiceIdEnumSaurabh, nil
	case "pooja":
		return FallbackSmallestAiVoiceIdEnumPooja, nil
	case "saina":
		return FallbackSmallestAiVoiceIdEnumSaina, nil
	case "sanya":
		return FallbackSmallestAiVoiceIdEnumSanya, nil
	}
	var t FallbackSmallestAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FallbackSmallestAiVoiceIdEnum) Ptr() *FallbackSmallestAiVoiceIdEnum {
	return &f
}

type FallbackSmallestAiVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackSmallestAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Smallest AI voice model to use. Defaults to 'lightning' when not specified.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackSmallestAiVoice) GetVoiceId() *FallbackSmallestAiVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackSmallestAiVoice) GetSpeed() *float64 {
	if f == nil {
		return nil
	}
	return f.Speed
}

func (f *FallbackSmallestAiVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackSmallestAiVoice) Provider() string {
	return f.provider
}

func (f *FallbackSmallestAiVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackSmallestAiVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackSmallestAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackSmallestAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "smallest-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "smallest-ai", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackSmallestAiVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackSmallestAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "smallest-ai",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackSmallestAiVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackTavusVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *FallbackTavusVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the unique identifier for the persona that the replica will use in the conversation.
	PersonaId *string `json:"personaId,omitempty" url:"personaId,omitempty"`
	// This is the url that will receive webhooks with updates regarding the conversation state.
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// This is the name for the conversation.
	ConversationName *string `json:"conversationName,omitempty" url:"conversationName,omitempty"`
	// This is the context that will be appended to any context provided in the persona, if one is provided.
	ConversationalContext *string `json:"conversationalContext,omitempty" url:"conversationalContext,omitempty"`
	// This is the custom greeting that the replica will give once a participant joines the conversation.
	CustomGreeting *string `json:"customGreeting,omitempty" url:"customGreeting,omitempty"`
	// These are optional properties used to customize the conversation.
	Properties *TavusConversationProperties `json:"properties,omitempty" url:"properties,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	provider  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackTavusVoice) GetVoiceId() *FallbackTavusVoiceVoiceId {
	if f == nil {
		return nil
	}
	return f.VoiceId
}

func (f *FallbackTavusVoice) GetPersonaId() *string {
	if f == nil {
		return nil
	}
	return f.PersonaId
}

func (f *FallbackTavusVoice) GetCallbackUrl() *string {
	if f == nil {
		return nil
	}
	return f.CallbackUrl
}

func (f *FallbackTavusVoice) GetConversationName() *string {
	if f == nil {
		return nil
	}
	return f.ConversationName
}

func (f *FallbackTavusVoice) GetConversationalContext() *string {
	if f == nil {
		return nil
	}
	return f.ConversationalContext
}

func (f *FallbackTavusVoice) GetCustomGreeting() *string {
	if f == nil {
		return nil
	}
	return f.CustomGreeting
}

func (f *FallbackTavusVoice) GetProperties() *TavusConversationProperties {
	if f == nil {
		return nil
	}
	return f.Properties
}

func (f *FallbackTavusVoice) GetChunkPlan() *ChunkPlan {
	if f == nil {
		return nil
	}
	return f.ChunkPlan
}

func (f *FallbackTavusVoice) Provider() string {
	return f.provider
}

func (f *FallbackTavusVoice) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackTavusVoice) UnmarshalJSON(data []byte) error {
	type embed FallbackTavusVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackTavusVoice(unmarshaler.embed)
	if unmarshaler.Provider != "tavus" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "tavus", unmarshaler.Provider)
	}
	f.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "provider")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackTavusVoice) MarshalJSON() ([]byte, error) {
	type embed FallbackTavusVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*f),
		Provider: "tavus",
	}
	return json.Marshal(marshaler)
}

func (f *FallbackTavusVoice) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// This is the provider-specific ID that will be used.
type FallbackTavusVoiceVoiceId struct {
	r52da2535aStringLiteral string
	String                  string

	typ string
}

func NewFallbackTavusVoiceVoiceIdWithR52da2535aStringLiteral() *FallbackTavusVoiceVoiceId {
	return &FallbackTavusVoiceVoiceId{typ: "r52da2535aStringLiteral", r52da2535aStringLiteral: "r52da2535a"}
}

func (f *FallbackTavusVoiceVoiceId) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FallbackTavusVoiceVoiceId) R52da2535aStringLiteral() string {
	return f.r52da2535aStringLiteral
}

func (f *FallbackTavusVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueR52da2535aStringLiteral string
	if err := json.Unmarshal(data, &valueR52da2535aStringLiteral); err == nil {
		f.typ = "r52da2535aStringLiteral"
		f.r52da2535aStringLiteral = valueR52da2535aStringLiteral
		if f.r52da2535aStringLiteral != "r52da2535a" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "r52da2535a", valueR52da2535aStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		f.typ = "String"
		f.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackTavusVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if f.typ == "r52da2535aStringLiteral" || f.r52da2535aStringLiteral != "" {
		return json.Marshal("r52da2535a")
	}
	if f.typ == "String" || f.String != "" {
		return json.Marshal(f.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackTavusVoiceVoiceIdVisitor interface {
	VisitR52da2535aStringLiteral(string) error
	VisitString(string) error
}

func (f *FallbackTavusVoiceVoiceId) Accept(visitor FallbackTavusVoiceVoiceIdVisitor) error {
	if f.typ == "r52da2535aStringLiteral" || f.r52da2535aStringLiteral != "" {
		return visitor.VisitR52da2535aStringLiteral(f.r52da2535aStringLiteral)
	}
	if f.typ == "String" || f.String != "" {
		return visitor.VisitString(f.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FormatPlan struct {
	// This determines whether the chunk is formatted before being sent to the voice provider. This helps with enunciation. This includes phone numbers, emails and addresses. Default `true`.
	//
	// Usage:
	// - To rely on the voice provider's formatting logic, set this to `false`.
	//
	// If `voice.chunkPlan.enabled` is `false`, this is automatically `false` since there's no chunk to format.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the cutoff after which a number is converted to individual digits instead of being spoken as words.
	//
	// Example:
	// - If cutoff 2025, "12345" is converted to "1 2 3 4 5" while "1200" is converted to "twelve hundred".
	//
	// Usage:
	// - If your use case doesn't involve IDs like zip codes, set this to a high value.
	// - If your use case involves IDs that are shorter than 5 digits, set this to a lower value.
	//
	// @default 2025
	NumberToDigitsCutoff *float64 `json:"numberToDigitsCutoff,omitempty" url:"numberToDigitsCutoff,omitempty"`
	// These are the custom replacements you can make to the chunk before it is sent to the voice provider.
	//
	// Usage:
	// - To replace a specific word or phrase with a different word or phrase, use the `ExactReplacement` type. Eg. `{ type: 'exact', key: 'hello', value: 'hi' }`
	// - To replace a word or phrase that matches a pattern, use the `RegexReplacement` type. Eg. `{ type: 'regex', regex: '\\b[a-zA-Z]{5}\\b', value: 'hi' }`
	//
	// @default []
	Replacements []*FormatPlanReplacementsItem `json:"replacements,omitempty" url:"replacements,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FormatPlan) GetEnabled() *bool {
	if f == nil {
		return nil
	}
	return f.Enabled
}

func (f *FormatPlan) GetNumberToDigitsCutoff() *float64 {
	if f == nil {
		return nil
	}
	return f.NumberToDigitsCutoff
}

func (f *FormatPlan) GetReplacements() []*FormatPlanReplacementsItem {
	if f == nil {
		return nil
	}
	return f.Replacements
}

func (f *FormatPlan) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FormatPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler FormatPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FormatPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FormatPlan) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FormatPlanReplacementsItem struct {
	ExactReplacement *ExactReplacement
	RegexReplacement *RegexReplacement

	typ string
}

func (f *FormatPlanReplacementsItem) GetExactReplacement() *ExactReplacement {
	if f == nil {
		return nil
	}
	return f.ExactReplacement
}

func (f *FormatPlanReplacementsItem) GetRegexReplacement() *RegexReplacement {
	if f == nil {
		return nil
	}
	return f.RegexReplacement
}

func (f *FormatPlanReplacementsItem) UnmarshalJSON(data []byte) error {
	valueExactReplacement := new(ExactReplacement)
	if err := json.Unmarshal(data, &valueExactReplacement); err == nil {
		f.typ = "ExactReplacement"
		f.ExactReplacement = valueExactReplacement
		return nil
	}
	valueRegexReplacement := new(RegexReplacement)
	if err := json.Unmarshal(data, &valueRegexReplacement); err == nil {
		f.typ = "RegexReplacement"
		f.RegexReplacement = valueRegexReplacement
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FormatPlanReplacementsItem) MarshalJSON() ([]byte, error) {
	if f.typ == "ExactReplacement" || f.ExactReplacement != nil {
		return json.Marshal(f.ExactReplacement)
	}
	if f.typ == "RegexReplacement" || f.RegexReplacement != nil {
		return json.Marshal(f.RegexReplacement)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FormatPlanReplacementsItemVisitor interface {
	VisitExactReplacement(*ExactReplacement) error
	VisitRegexReplacement(*RegexReplacement) error
}

func (f *FormatPlanReplacementsItem) Accept(visitor FormatPlanReplacementsItemVisitor) error {
	if f.typ == "ExactReplacement" || f.ExactReplacement != nil {
		return visitor.VisitExactReplacement(f.ExactReplacement)
	}
	if f.typ == "RegexReplacement" || f.RegexReplacement != nil {
		return visitor.VisitRegexReplacement(f.RegexReplacement)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "function" for Function tool.
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FunctionToolProviderDetails) GetTemplateUrl() *string {
	if f == nil {
		return nil
	}
	return f.TemplateUrl
}

func (f *FunctionToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if f == nil {
		return nil
	}
	return f.SetupInstructions
}

func (f *FunctionToolProviderDetails) Type() string {
	return f.type_
}

func (f *FunctionToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed FunctionToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed FunctionToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionToolProviderDetails) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*FunctionToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "function" for Function tool.
	ToolCall *ToolCall `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FunctionToolWithToolCall) GetAsync() *bool {
	if f == nil {
		return nil
	}
	return f.Async
}

func (f *FunctionToolWithToolCall) GetMessages() []*FunctionToolWithToolCallMessagesItem {
	if f == nil {
		return nil
	}
	return f.Messages
}

func (f *FunctionToolWithToolCall) GetToolCall() *ToolCall {
	if f == nil {
		return nil
	}
	return f.ToolCall
}

func (f *FunctionToolWithToolCall) GetFunction() *OpenAiFunction {
	if f == nil {
		return nil
	}
	return f.Function
}

func (f *FunctionToolWithToolCall) GetServer() *Server {
	if f == nil {
		return nil
	}
	return f.Server
}

func (f *FunctionToolWithToolCall) Type() string {
	return f.type_
}

func (f *FunctionToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FunctionToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed FunctionToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FunctionToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "function", unmarshaler.Type)
	}
	f.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *f, "type")
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FunctionToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed FunctionToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (f *FunctionToolWithToolCall) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FunctionToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (f *FunctionToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if f == nil {
		return nil
	}
	return f.ToolMessageStart
}

func (f *FunctionToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if f == nil {
		return nil
	}
	return f.ToolMessageComplete
}

func (f *FunctionToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if f == nil {
		return nil
	}
	return f.ToolMessageFailed
}

func (f *FunctionToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if f == nil {
		return nil
	}
	return f.ToolMessageDelayed
}

func (f *FunctionToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		f.typ = "ToolMessageStart"
		f.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		f.typ = "ToolMessageComplete"
		f.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		f.typ = "ToolMessageFailed"
		f.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		f.typ = "ToolMessageDelayed"
		f.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FunctionToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return json.Marshal(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return json.Marshal(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return json.Marshal(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return json.Marshal(f.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FunctionToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (f *FunctionToolWithToolCallMessagesItem) Accept(visitor FunctionToolWithToolCallMessagesItemVisitor) error {
	if f.typ == "ToolMessageStart" || f.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(f.ToolMessageStart)
	}
	if f.typ == "ToolMessageComplete" || f.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(f.ToolMessageComplete)
	}
	if f.typ == "ToolMessageFailed" || f.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(f.ToolMessageFailed)
	}
	if f.typ == "ToolMessageDelayed" || f.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(f.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

type GcpCredential struct {
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GcpCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GcpCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GcpCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GcpCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GcpCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GcpCredential) GetGcpKey() *GcpKey {
	if g == nil {
		return nil
	}
	return g.GcpKey
}

func (g *GcpCredential) GetBucketPlan() *BucketPlan {
	if g == nil {
		return nil
	}
	return g.BucketPlan
}

func (g *GcpCredential) Provider() string {
	return g.provider
}

func (g *GcpCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GcpCredential) UnmarshalJSON(data []byte) error {
	type embed GcpCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GcpCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gcp" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gcp", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GcpCredential) MarshalJSON() ([]byte, error) {
	type embed GcpCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "gcp",
	}
	return json.Marshal(marshaler)
}

func (g *GcpCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GcpKey struct {
	// This is the type of the key. Most likely, this is "service_account".
	Type string `json:"type" url:"type"`
	// This is the ID of the Google Cloud project associated with this key.
	ProjectId string `json:"projectId" url:"projectId"`
	// This is the unique identifier for the private key.
	PrivateKeyId string `json:"privateKeyId" url:"privateKeyId"`
	// This is the private key in PEM format.
	//
	// Note: This is not returned in the API.
	PrivateKey string `json:"privateKey" url:"privateKey"`
	// This is the email address associated with the service account.
	ClientEmail string `json:"clientEmail" url:"clientEmail"`
	// This is the unique identifier for the client.
	ClientId string `json:"clientId" url:"clientId"`
	// This is the URI for the auth provider's authorization endpoint.
	AuthUri string `json:"authUri" url:"authUri"`
	// This is the URI for the auth provider's token endpoint.
	TokenUri string `json:"tokenUri" url:"tokenUri"`
	// This is the URL of the public x509 certificate for the auth provider.
	AuthProviderX509CertUrl string `json:"authProviderX509CertUrl" url:"authProviderX509CertUrl"`
	// This is the URL of the public x509 certificate for the client.
	ClientX509CertUrl string `json:"clientX509CertUrl" url:"clientX509CertUrl"`
	// This is the domain associated with the universe this service account belongs to.
	UniverseDomain string `json:"universeDomain" url:"universeDomain"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GcpKey) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GcpKey) GetProjectId() string {
	if g == nil {
		return ""
	}
	return g.ProjectId
}

func (g *GcpKey) GetPrivateKeyId() string {
	if g == nil {
		return ""
	}
	return g.PrivateKeyId
}

func (g *GcpKey) GetPrivateKey() string {
	if g == nil {
		return ""
	}
	return g.PrivateKey
}

func (g *GcpKey) GetClientEmail() string {
	if g == nil {
		return ""
	}
	return g.ClientEmail
}

func (g *GcpKey) GetClientId() string {
	if g == nil {
		return ""
	}
	return g.ClientId
}

func (g *GcpKey) GetAuthUri() string {
	if g == nil {
		return ""
	}
	return g.AuthUri
}

func (g *GcpKey) GetTokenUri() string {
	if g == nil {
		return ""
	}
	return g.TokenUri
}

func (g *GcpKey) GetAuthProviderX509CertUrl() string {
	if g == nil {
		return ""
	}
	return g.AuthProviderX509CertUrl
}

func (g *GcpKey) GetClientX509CertUrl() string {
	if g == nil {
		return ""
	}
	return g.ClientX509CertUrl
}

func (g *GcpKey) GetUniverseDomain() string {
	if g == nil {
		return ""
	}
	return g.UniverseDomain
}

func (g *GcpKey) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GcpKey) UnmarshalJSON(data []byte) error {
	type unmarshaler GcpKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GcpKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GcpKey) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeminiMultimodalLivePrebuiltVoiceConfig struct {
	VoiceName GeminiMultimodalLivePrebuiltVoiceConfigVoiceName `json:"voiceName" url:"voiceName"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeminiMultimodalLivePrebuiltVoiceConfig) GetVoiceName() GeminiMultimodalLivePrebuiltVoiceConfigVoiceName {
	if g == nil {
		return ""
	}
	return g.VoiceName
}

func (g *GeminiMultimodalLivePrebuiltVoiceConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeminiMultimodalLivePrebuiltVoiceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeminiMultimodalLivePrebuiltVoiceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeminiMultimodalLivePrebuiltVoiceConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeminiMultimodalLivePrebuiltVoiceConfig) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeminiMultimodalLivePrebuiltVoiceConfigVoiceName string

const (
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNamePuck   GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Puck"
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameCharon GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Charon"
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameKore   GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Kore"
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameFenrir GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Fenrir"
	GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameAoede  GeminiMultimodalLivePrebuiltVoiceConfigVoiceName = "Aoede"
)

func NewGeminiMultimodalLivePrebuiltVoiceConfigVoiceNameFromString(s string) (GeminiMultimodalLivePrebuiltVoiceConfigVoiceName, error) {
	switch s {
	case "Puck":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNamePuck, nil
	case "Charon":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameCharon, nil
	case "Kore":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameKore, nil
	case "Fenrir":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameFenrir, nil
	case "Aoede":
		return GeminiMultimodalLivePrebuiltVoiceConfigVoiceNameAoede, nil
	}
	var t GeminiMultimodalLivePrebuiltVoiceConfigVoiceName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GeminiMultimodalLivePrebuiltVoiceConfigVoiceName) Ptr() *GeminiMultimodalLivePrebuiltVoiceConfigVoiceName {
	return &g
}

type GeminiMultimodalLiveSpeechConfig struct {
	VoiceConfig *GeminiMultimodalLiveVoiceConfig `json:"voiceConfig,omitempty" url:"voiceConfig,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeminiMultimodalLiveSpeechConfig) GetVoiceConfig() *GeminiMultimodalLiveVoiceConfig {
	if g == nil {
		return nil
	}
	return g.VoiceConfig
}

func (g *GeminiMultimodalLiveSpeechConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeminiMultimodalLiveSpeechConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeminiMultimodalLiveSpeechConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeminiMultimodalLiveSpeechConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeminiMultimodalLiveSpeechConfig) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeminiMultimodalLiveVoiceConfig struct {
	PrebuiltVoiceConfig *GeminiMultimodalLivePrebuiltVoiceConfig `json:"prebuiltVoiceConfig,omitempty" url:"prebuiltVoiceConfig,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeminiMultimodalLiveVoiceConfig) GetPrebuiltVoiceConfig() *GeminiMultimodalLivePrebuiltVoiceConfig {
	if g == nil {
		return nil
	}
	return g.PrebuiltVoiceConfig
}

func (g *GeminiMultimodalLiveVoiceConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeminiMultimodalLiveVoiceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeminiMultimodalLiveVoiceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeminiMultimodalLiveVoiceConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeminiMultimodalLiveVoiceConfig) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolMetadata struct {
	WorkflowId *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	LocationId *string `json:"locationId,omitempty" url:"locationId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GhlToolMetadata) GetWorkflowId() *string {
	if g == nil {
		return nil
	}
	return g.WorkflowId
}

func (g *GhlToolMetadata) GetLocationId() *string {
	if g == nil {
		return nil
	}
	return g.LocationId
}

func (g *GhlToolMetadata) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler GhlToolMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GhlToolMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolMetadata) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "ghl" for GHL tool.
	WorkflowId      *string `json:"workflowId,omitempty" url:"workflowId,omitempty"`
	WorkflowName    *string `json:"workflowName,omitempty" url:"workflowName,omitempty"`
	WebhookHookId   *string `json:"webhookHookId,omitempty" url:"webhookHookId,omitempty"`
	WebhookHookName *string `json:"webhookHookName,omitempty" url:"webhookHookName,omitempty"`
	LocationId      *string `json:"locationId,omitempty" url:"locationId,omitempty"`
	type_           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GhlToolProviderDetails) GetTemplateUrl() *string {
	if g == nil {
		return nil
	}
	return g.TemplateUrl
}

func (g *GhlToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if g == nil {
		return nil
	}
	return g.SetupInstructions
}

func (g *GhlToolProviderDetails) GetWorkflowId() *string {
	if g == nil {
		return nil
	}
	return g.WorkflowId
}

func (g *GhlToolProviderDetails) GetWorkflowName() *string {
	if g == nil {
		return nil
	}
	return g.WorkflowName
}

func (g *GhlToolProviderDetails) GetWebhookHookId() *string {
	if g == nil {
		return nil
	}
	return g.WebhookHookId
}

func (g *GhlToolProviderDetails) GetWebhookHookName() *string {
	if g == nil {
		return nil
	}
	return g.WebhookHookName
}

func (g *GhlToolProviderDetails) GetLocationId() *string {
	if g == nil {
		return nil
	}
	return g.LocationId
}

func (g *GhlToolProviderDetails) Type() string {
	return g.type_
}

func (g *GhlToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed GhlToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GhlToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed GhlToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (g *GhlToolProviderDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*GhlToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "ghl" for GHL tool.
	ToolCall *ToolCall        `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	Metadata *GhlToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GhlToolWithToolCall) GetAsync() *bool {
	if g == nil {
		return nil
	}
	return g.Async
}

func (g *GhlToolWithToolCall) GetMessages() []*GhlToolWithToolCallMessagesItem {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GhlToolWithToolCall) GetToolCall() *ToolCall {
	if g == nil {
		return nil
	}
	return g.ToolCall
}

func (g *GhlToolWithToolCall) GetMetadata() *GhlToolMetadata {
	if g == nil {
		return nil
	}
	return g.Metadata
}

func (g *GhlToolWithToolCall) GetFunction() *OpenAiFunction {
	if g == nil {
		return nil
	}
	return g.Function
}

func (g *GhlToolWithToolCall) GetServer() *Server {
	if g == nil {
		return nil
	}
	return g.Server
}

func (g *GhlToolWithToolCall) Type() string {
	return g.type_
}

func (g *GhlToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GhlToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed GhlToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GhlToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "ghl" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "ghl", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GhlToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed GhlToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "ghl",
	}
	return json.Marshal(marshaler)
}

func (g *GhlToolWithToolCall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GhlToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (g *GhlToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if g == nil {
		return nil
	}
	return g.ToolMessageStart
}

func (g *GhlToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if g == nil {
		return nil
	}
	return g.ToolMessageComplete
}

func (g *GhlToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if g == nil {
		return nil
	}
	return g.ToolMessageFailed
}

func (g *GhlToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if g == nil {
		return nil
	}
	return g.ToolMessageDelayed
}

func (g *GhlToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		g.typ = "ToolMessageStart"
		g.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		g.typ = "ToolMessageComplete"
		g.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		g.typ = "ToolMessageFailed"
		g.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		g.typ = "ToolMessageDelayed"
		g.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GhlToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return json.Marshal(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return json.Marshal(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return json.Marshal(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return json.Marshal(g.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GhlToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (g *GhlToolWithToolCallMessagesItem) Accept(visitor GhlToolWithToolCallMessagesItemVisitor) error {
	if g.typ == "ToolMessageStart" || g.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(g.ToolMessageStart)
	}
	if g.typ == "ToolMessageComplete" || g.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(g.ToolMessageComplete)
	}
	if g.typ == "ToolMessageFailed" || g.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(g.ToolMessageFailed)
	}
	if g.typ == "ToolMessageDelayed" || g.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(g.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GladiaCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GladiaCredential) GetApiKey() string {
	if g == nil {
		return ""
	}
	return g.ApiKey
}

func (g *GladiaCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GladiaCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GladiaCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GladiaCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GladiaCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GladiaCredential) Provider() string {
	return g.provider
}

func (g *GladiaCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GladiaCredential) UnmarshalJSON(data []byte) error {
	type embed GladiaCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GladiaCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gladia", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GladiaCredential) MarshalJSON() ([]byte, error) {
	type embed GladiaCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "gladia",
	}
	return json.Marshal(marshaler)
}

func (g *GladiaCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GladiaTranscriber struct {
	// This is the transcription provider that will be used.
	Model             *GladiaTranscriberModel             `json:"model,omitempty" url:"model,omitempty"`
	LanguageBehaviour *GladiaTranscriberLanguageBehaviour `json:"languageBehaviour,omitempty" url:"languageBehaviour,omitempty"`
	// Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.
	Language *GladiaTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	// Provides a custom vocabulary to the model to improve accuracy of transcribing context specific words, technical terms, names, etc. If empty, this argument is ignored.
	//  Warning : Please be aware that the transcription_hint field has a character limit of 600. If you provide a transcription_hint longer than 600 characters, it will be automatically truncated to meet this limit.
	TranscriptionHint *string `json:"transcriptionHint,omitempty" url:"transcriptionHint,omitempty"`
	// If prosody is true, you will get a transcription that can contain prosodies i.e. (laugh) (giggles) (malefic laugh) (toss) (music) Default value is false.
	Prosody *bool `json:"prosody,omitempty" url:"prosody,omitempty"`
	// If true, audio will be pre-processed to improve accuracy but latency will increase. Default value is false.
	AudioEnhancer *bool `json:"audioEnhancer,omitempty" url:"audioEnhancer,omitempty"`
	provider      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GladiaTranscriber) GetModel() *GladiaTranscriberModel {
	if g == nil {
		return nil
	}
	return g.Model
}

func (g *GladiaTranscriber) GetLanguageBehaviour() *GladiaTranscriberLanguageBehaviour {
	if g == nil {
		return nil
	}
	return g.LanguageBehaviour
}

func (g *GladiaTranscriber) GetLanguage() *GladiaTranscriberLanguage {
	if g == nil {
		return nil
	}
	return g.Language
}

func (g *GladiaTranscriber) GetTranscriptionHint() *string {
	if g == nil {
		return nil
	}
	return g.TranscriptionHint
}

func (g *GladiaTranscriber) GetProsody() *bool {
	if g == nil {
		return nil
	}
	return g.Prosody
}

func (g *GladiaTranscriber) GetAudioEnhancer() *bool {
	if g == nil {
		return nil
	}
	return g.AudioEnhancer
}

func (g *GladiaTranscriber) Provider() string {
	return g.provider
}

func (g *GladiaTranscriber) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GladiaTranscriber) UnmarshalJSON(data []byte) error {
	type embed GladiaTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GladiaTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "gladia" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gladia", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GladiaTranscriber) MarshalJSON() ([]byte, error) {
	type embed GladiaTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "gladia",
	}
	return json.Marshal(marshaler)
}

func (g *GladiaTranscriber) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.
type GladiaTranscriberLanguage string

const (
	GladiaTranscriberLanguageAf   GladiaTranscriberLanguage = "af"
	GladiaTranscriberLanguageSq   GladiaTranscriberLanguage = "sq"
	GladiaTranscriberLanguageAm   GladiaTranscriberLanguage = "am"
	GladiaTranscriberLanguageAr   GladiaTranscriberLanguage = "ar"
	GladiaTranscriberLanguageHy   GladiaTranscriberLanguage = "hy"
	GladiaTranscriberLanguageAs   GladiaTranscriberLanguage = "as"
	GladiaTranscriberLanguageAz   GladiaTranscriberLanguage = "az"
	GladiaTranscriberLanguageBa   GladiaTranscriberLanguage = "ba"
	GladiaTranscriberLanguageEu   GladiaTranscriberLanguage = "eu"
	GladiaTranscriberLanguageBe   GladiaTranscriberLanguage = "be"
	GladiaTranscriberLanguageBn   GladiaTranscriberLanguage = "bn"
	GladiaTranscriberLanguageBs   GladiaTranscriberLanguage = "bs"
	GladiaTranscriberLanguageBr   GladiaTranscriberLanguage = "br"
	GladiaTranscriberLanguageBg   GladiaTranscriberLanguage = "bg"
	GladiaTranscriberLanguageCa   GladiaTranscriberLanguage = "ca"
	GladiaTranscriberLanguageZh   GladiaTranscriberLanguage = "zh"
	GladiaTranscriberLanguageHr   GladiaTranscriberLanguage = "hr"
	GladiaTranscriberLanguageCs   GladiaTranscriberLanguage = "cs"
	GladiaTranscriberLanguageDa   GladiaTranscriberLanguage = "da"
	GladiaTranscriberLanguageNl   GladiaTranscriberLanguage = "nl"
	GladiaTranscriberLanguageEn   GladiaTranscriberLanguage = "en"
	GladiaTranscriberLanguageEt   GladiaTranscriberLanguage = "et"
	GladiaTranscriberLanguageFo   GladiaTranscriberLanguage = "fo"
	GladiaTranscriberLanguageFi   GladiaTranscriberLanguage = "fi"
	GladiaTranscriberLanguageFr   GladiaTranscriberLanguage = "fr"
	GladiaTranscriberLanguageGl   GladiaTranscriberLanguage = "gl"
	GladiaTranscriberLanguageKa   GladiaTranscriberLanguage = "ka"
	GladiaTranscriberLanguageDe   GladiaTranscriberLanguage = "de"
	GladiaTranscriberLanguageEl   GladiaTranscriberLanguage = "el"
	GladiaTranscriberLanguageGu   GladiaTranscriberLanguage = "gu"
	GladiaTranscriberLanguageHt   GladiaTranscriberLanguage = "ht"
	GladiaTranscriberLanguageHa   GladiaTranscriberLanguage = "ha"
	GladiaTranscriberLanguageHaw  GladiaTranscriberLanguage = "haw"
	GladiaTranscriberLanguageHe   GladiaTranscriberLanguage = "he"
	GladiaTranscriberLanguageHi   GladiaTranscriberLanguage = "hi"
	GladiaTranscriberLanguageHu   GladiaTranscriberLanguage = "hu"
	GladiaTranscriberLanguageIs   GladiaTranscriberLanguage = "is"
	GladiaTranscriberLanguageId   GladiaTranscriberLanguage = "id"
	GladiaTranscriberLanguageIt   GladiaTranscriberLanguage = "it"
	GladiaTranscriberLanguageJa   GladiaTranscriberLanguage = "ja"
	GladiaTranscriberLanguageJp   GladiaTranscriberLanguage = "jp"
	GladiaTranscriberLanguageJv   GladiaTranscriberLanguage = "jv"
	GladiaTranscriberLanguageKn   GladiaTranscriberLanguage = "kn"
	GladiaTranscriberLanguageKk   GladiaTranscriberLanguage = "kk"
	GladiaTranscriberLanguageKm   GladiaTranscriberLanguage = "km"
	GladiaTranscriberLanguageKo   GladiaTranscriberLanguage = "ko"
	GladiaTranscriberLanguageLo   GladiaTranscriberLanguage = "lo"
	GladiaTranscriberLanguageLa   GladiaTranscriberLanguage = "la"
	GladiaTranscriberLanguageLv   GladiaTranscriberLanguage = "lv"
	GladiaTranscriberLanguageLn   GladiaTranscriberLanguage = "ln"
	GladiaTranscriberLanguageLt   GladiaTranscriberLanguage = "lt"
	GladiaTranscriberLanguageLb   GladiaTranscriberLanguage = "lb"
	GladiaTranscriberLanguageMk   GladiaTranscriberLanguage = "mk"
	GladiaTranscriberLanguageMg   GladiaTranscriberLanguage = "mg"
	GladiaTranscriberLanguageMs   GladiaTranscriberLanguage = "ms"
	GladiaTranscriberLanguageMl   GladiaTranscriberLanguage = "ml"
	GladiaTranscriberLanguageMt   GladiaTranscriberLanguage = "mt"
	GladiaTranscriberLanguageMi   GladiaTranscriberLanguage = "mi"
	GladiaTranscriberLanguageMr   GladiaTranscriberLanguage = "mr"
	GladiaTranscriberLanguageMn   GladiaTranscriberLanguage = "mn"
	GladiaTranscriberLanguageMymr GladiaTranscriberLanguage = "mymr"
	GladiaTranscriberLanguageNe   GladiaTranscriberLanguage = "ne"
	GladiaTranscriberLanguageNo   GladiaTranscriberLanguage = "no"
	GladiaTranscriberLanguageNn   GladiaTranscriberLanguage = "nn"
	GladiaTranscriberLanguageOc   GladiaTranscriberLanguage = "oc"
	GladiaTranscriberLanguagePs   GladiaTranscriberLanguage = "ps"
	GladiaTranscriberLanguageFa   GladiaTranscriberLanguage = "fa"
	GladiaTranscriberLanguagePl   GladiaTranscriberLanguage = "pl"
	GladiaTranscriberLanguagePt   GladiaTranscriberLanguage = "pt"
	GladiaTranscriberLanguagePa   GladiaTranscriberLanguage = "pa"
	GladiaTranscriberLanguageRo   GladiaTranscriberLanguage = "ro"
	GladiaTranscriberLanguageRu   GladiaTranscriberLanguage = "ru"
	GladiaTranscriberLanguageSa   GladiaTranscriberLanguage = "sa"
	GladiaTranscriberLanguageSr   GladiaTranscriberLanguage = "sr"
	GladiaTranscriberLanguageSn   GladiaTranscriberLanguage = "sn"
	GladiaTranscriberLanguageSd   GladiaTranscriberLanguage = "sd"
	GladiaTranscriberLanguageSi   GladiaTranscriberLanguage = "si"
	GladiaTranscriberLanguageSk   GladiaTranscriberLanguage = "sk"
	GladiaTranscriberLanguageSl   GladiaTranscriberLanguage = "sl"
	GladiaTranscriberLanguageSo   GladiaTranscriberLanguage = "so"
	GladiaTranscriberLanguageEs   GladiaTranscriberLanguage = "es"
	GladiaTranscriberLanguageSu   GladiaTranscriberLanguage = "su"
	GladiaTranscriberLanguageSw   GladiaTranscriberLanguage = "sw"
	GladiaTranscriberLanguageSv   GladiaTranscriberLanguage = "sv"
	GladiaTranscriberLanguageTl   GladiaTranscriberLanguage = "tl"
	GladiaTranscriberLanguageTg   GladiaTranscriberLanguage = "tg"
	GladiaTranscriberLanguageTa   GladiaTranscriberLanguage = "ta"
	GladiaTranscriberLanguageTt   GladiaTranscriberLanguage = "tt"
	GladiaTranscriberLanguageTe   GladiaTranscriberLanguage = "te"
	GladiaTranscriberLanguageTh   GladiaTranscriberLanguage = "th"
	GladiaTranscriberLanguageBo   GladiaTranscriberLanguage = "bo"
	GladiaTranscriberLanguageTr   GladiaTranscriberLanguage = "tr"
	GladiaTranscriberLanguageTk   GladiaTranscriberLanguage = "tk"
	GladiaTranscriberLanguageUk   GladiaTranscriberLanguage = "uk"
	GladiaTranscriberLanguageUr   GladiaTranscriberLanguage = "ur"
	GladiaTranscriberLanguageUz   GladiaTranscriberLanguage = "uz"
	GladiaTranscriberLanguageVi   GladiaTranscriberLanguage = "vi"
	GladiaTranscriberLanguageCy   GladiaTranscriberLanguage = "cy"
	GladiaTranscriberLanguageYi   GladiaTranscriberLanguage = "yi"
	GladiaTranscriberLanguageYo   GladiaTranscriberLanguage = "yo"
)

func NewGladiaTranscriberLanguageFromString(s string) (GladiaTranscriberLanguage, error) {
	switch s {
	case "af":
		return GladiaTranscriberLanguageAf, nil
	case "sq":
		return GladiaTranscriberLanguageSq, nil
	case "am":
		return GladiaTranscriberLanguageAm, nil
	case "ar":
		return GladiaTranscriberLanguageAr, nil
	case "hy":
		return GladiaTranscriberLanguageHy, nil
	case "as":
		return GladiaTranscriberLanguageAs, nil
	case "az":
		return GladiaTranscriberLanguageAz, nil
	case "ba":
		return GladiaTranscriberLanguageBa, nil
	case "eu":
		return GladiaTranscriberLanguageEu, nil
	case "be":
		return GladiaTranscriberLanguageBe, nil
	case "bn":
		return GladiaTranscriberLanguageBn, nil
	case "bs":
		return GladiaTranscriberLanguageBs, nil
	case "br":
		return GladiaTranscriberLanguageBr, nil
	case "bg":
		return GladiaTranscriberLanguageBg, nil
	case "ca":
		return GladiaTranscriberLanguageCa, nil
	case "zh":
		return GladiaTranscriberLanguageZh, nil
	case "hr":
		return GladiaTranscriberLanguageHr, nil
	case "cs":
		return GladiaTranscriberLanguageCs, nil
	case "da":
		return GladiaTranscriberLanguageDa, nil
	case "nl":
		return GladiaTranscriberLanguageNl, nil
	case "en":
		return GladiaTranscriberLanguageEn, nil
	case "et":
		return GladiaTranscriberLanguageEt, nil
	case "fo":
		return GladiaTranscriberLanguageFo, nil
	case "fi":
		return GladiaTranscriberLanguageFi, nil
	case "fr":
		return GladiaTranscriberLanguageFr, nil
	case "gl":
		return GladiaTranscriberLanguageGl, nil
	case "ka":
		return GladiaTranscriberLanguageKa, nil
	case "de":
		return GladiaTranscriberLanguageDe, nil
	case "el":
		return GladiaTranscriberLanguageEl, nil
	case "gu":
		return GladiaTranscriberLanguageGu, nil
	case "ht":
		return GladiaTranscriberLanguageHt, nil
	case "ha":
		return GladiaTranscriberLanguageHa, nil
	case "haw":
		return GladiaTranscriberLanguageHaw, nil
	case "he":
		return GladiaTranscriberLanguageHe, nil
	case "hi":
		return GladiaTranscriberLanguageHi, nil
	case "hu":
		return GladiaTranscriberLanguageHu, nil
	case "is":
		return GladiaTranscriberLanguageIs, nil
	case "id":
		return GladiaTranscriberLanguageId, nil
	case "it":
		return GladiaTranscriberLanguageIt, nil
	case "ja":
		return GladiaTranscriberLanguageJa, nil
	case "jp":
		return GladiaTranscriberLanguageJp, nil
	case "jv":
		return GladiaTranscriberLanguageJv, nil
	case "kn":
		return GladiaTranscriberLanguageKn, nil
	case "kk":
		return GladiaTranscriberLanguageKk, nil
	case "km":
		return GladiaTranscriberLanguageKm, nil
	case "ko":
		return GladiaTranscriberLanguageKo, nil
	case "lo":
		return GladiaTranscriberLanguageLo, nil
	case "la":
		return GladiaTranscriberLanguageLa, nil
	case "lv":
		return GladiaTranscriberLanguageLv, nil
	case "ln":
		return GladiaTranscriberLanguageLn, nil
	case "lt":
		return GladiaTranscriberLanguageLt, nil
	case "lb":
		return GladiaTranscriberLanguageLb, nil
	case "mk":
		return GladiaTranscriberLanguageMk, nil
	case "mg":
		return GladiaTranscriberLanguageMg, nil
	case "ms":
		return GladiaTranscriberLanguageMs, nil
	case "ml":
		return GladiaTranscriberLanguageMl, nil
	case "mt":
		return GladiaTranscriberLanguageMt, nil
	case "mi":
		return GladiaTranscriberLanguageMi, nil
	case "mr":
		return GladiaTranscriberLanguageMr, nil
	case "mn":
		return GladiaTranscriberLanguageMn, nil
	case "mymr":
		return GladiaTranscriberLanguageMymr, nil
	case "ne":
		return GladiaTranscriberLanguageNe, nil
	case "no":
		return GladiaTranscriberLanguageNo, nil
	case "nn":
		return GladiaTranscriberLanguageNn, nil
	case "oc":
		return GladiaTranscriberLanguageOc, nil
	case "ps":
		return GladiaTranscriberLanguagePs, nil
	case "fa":
		return GladiaTranscriberLanguageFa, nil
	case "pl":
		return GladiaTranscriberLanguagePl, nil
	case "pt":
		return GladiaTranscriberLanguagePt, nil
	case "pa":
		return GladiaTranscriberLanguagePa, nil
	case "ro":
		return GladiaTranscriberLanguageRo, nil
	case "ru":
		return GladiaTranscriberLanguageRu, nil
	case "sa":
		return GladiaTranscriberLanguageSa, nil
	case "sr":
		return GladiaTranscriberLanguageSr, nil
	case "sn":
		return GladiaTranscriberLanguageSn, nil
	case "sd":
		return GladiaTranscriberLanguageSd, nil
	case "si":
		return GladiaTranscriberLanguageSi, nil
	case "sk":
		return GladiaTranscriberLanguageSk, nil
	case "sl":
		return GladiaTranscriberLanguageSl, nil
	case "so":
		return GladiaTranscriberLanguageSo, nil
	case "es":
		return GladiaTranscriberLanguageEs, nil
	case "su":
		return GladiaTranscriberLanguageSu, nil
	case "sw":
		return GladiaTranscriberLanguageSw, nil
	case "sv":
		return GladiaTranscriberLanguageSv, nil
	case "tl":
		return GladiaTranscriberLanguageTl, nil
	case "tg":
		return GladiaTranscriberLanguageTg, nil
	case "ta":
		return GladiaTranscriberLanguageTa, nil
	case "tt":
		return GladiaTranscriberLanguageTt, nil
	case "te":
		return GladiaTranscriberLanguageTe, nil
	case "th":
		return GladiaTranscriberLanguageTh, nil
	case "bo":
		return GladiaTranscriberLanguageBo, nil
	case "tr":
		return GladiaTranscriberLanguageTr, nil
	case "tk":
		return GladiaTranscriberLanguageTk, nil
	case "uk":
		return GladiaTranscriberLanguageUk, nil
	case "ur":
		return GladiaTranscriberLanguageUr, nil
	case "uz":
		return GladiaTranscriberLanguageUz, nil
	case "vi":
		return GladiaTranscriberLanguageVi, nil
	case "cy":
		return GladiaTranscriberLanguageCy, nil
	case "yi":
		return GladiaTranscriberLanguageYi, nil
	case "yo":
		return GladiaTranscriberLanguageYo, nil
	}
	var t GladiaTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberLanguage) Ptr() *GladiaTranscriberLanguage {
	return &g
}

type GladiaTranscriberLanguageBehaviour string

const (
	GladiaTranscriberLanguageBehaviourManual                     GladiaTranscriberLanguageBehaviour = "manual"
	GladiaTranscriberLanguageBehaviourAutomaticSingleLanguage    GladiaTranscriberLanguageBehaviour = "automatic single language"
	GladiaTranscriberLanguageBehaviourAutomaticMultipleLanguages GladiaTranscriberLanguageBehaviour = "automatic multiple languages"
)

func NewGladiaTranscriberLanguageBehaviourFromString(s string) (GladiaTranscriberLanguageBehaviour, error) {
	switch s {
	case "manual":
		return GladiaTranscriberLanguageBehaviourManual, nil
	case "automatic single language":
		return GladiaTranscriberLanguageBehaviourAutomaticSingleLanguage, nil
	case "automatic multiple languages":
		return GladiaTranscriberLanguageBehaviourAutomaticMultipleLanguages, nil
	}
	var t GladiaTranscriberLanguageBehaviour
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberLanguageBehaviour) Ptr() *GladiaTranscriberLanguageBehaviour {
	return &g
}

type GladiaTranscriberModel string

const (
	GladiaTranscriberModelFast     GladiaTranscriberModel = "fast"
	GladiaTranscriberModelAccurate GladiaTranscriberModel = "accurate"
)

func NewGladiaTranscriberModelFromString(s string) (GladiaTranscriberModel, error) {
	switch s {
	case "fast":
		return GladiaTranscriberModelFast, nil
	case "accurate":
		return GladiaTranscriberModelAccurate, nil
	}
	var t GladiaTranscriberModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GladiaTranscriberModel) Ptr() *GladiaTranscriberModel {
	return &g
}

type GoHighLevelCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoHighLevelCredential) GetApiKey() string {
	if g == nil {
		return ""
	}
	return g.ApiKey
}

func (g *GoHighLevelCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoHighLevelCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoHighLevelCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoHighLevelCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoHighLevelCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GoHighLevelCredential) Provider() string {
	return g.provider
}

func (g *GoHighLevelCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoHighLevelCredential) UnmarshalJSON(data []byte) error {
	type embed GoHighLevelCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoHighLevelCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "gohighlevel" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gohighlevel", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoHighLevelCredential) MarshalJSON() ([]byte, error) {
	type embed GoHighLevelCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "gohighlevel",
	}
	return json.Marshal(marshaler)
}

func (g *GoHighLevelCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleCredential struct {
	// This is the key for Gemini in Google AI Studio. Get it from here: https://aistudio.google.com/app/apikey
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleCredential) GetApiKey() string {
	if g == nil {
		return ""
	}
	return g.ApiKey
}

func (g *GoogleCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GoogleCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GoogleCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GoogleCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GoogleCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GoogleCredential) Provider() string {
	return g.provider
}

func (g *GoogleCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleCredential) UnmarshalJSON(data []byte) error {
	type embed GoogleCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleCredential) MarshalJSON() ([]byte, error) {
	type embed GoogleCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "google",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*GoogleModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the Google model that will be used.
	Model GoogleModelModel `json:"model" url:"model"`
	// This is the session configuration for the Gemini Flash 2.0 Multimodal Live API.
	// Only applicable if the model `gemini-2.0-flash-realtime-exp` is selected.
	RealtimeConfig *GoogleRealtimeConfig `json:"realtimeConfig,omitempty" url:"realtimeConfig,omitempty"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleModel) GetMessages() []*OpenAiMessage {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GoogleModel) GetTools() []*GoogleModelToolsItem {
	if g == nil {
		return nil
	}
	return g.Tools
}

func (g *GoogleModel) GetToolIds() []string {
	if g == nil {
		return nil
	}
	return g.ToolIds
}

func (g *GoogleModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if g == nil {
		return nil
	}
	return g.KnowledgeBase
}

func (g *GoogleModel) GetKnowledgeBaseId() *string {
	if g == nil {
		return nil
	}
	return g.KnowledgeBaseId
}

func (g *GoogleModel) GetModel() GoogleModelModel {
	if g == nil {
		return ""
	}
	return g.Model
}

func (g *GoogleModel) GetRealtimeConfig() *GoogleRealtimeConfig {
	if g == nil {
		return nil
	}
	return g.RealtimeConfig
}

func (g *GoogleModel) GetTemperature() *float64 {
	if g == nil {
		return nil
	}
	return g.Temperature
}

func (g *GoogleModel) GetMaxTokens() *float64 {
	if g == nil {
		return nil
	}
	return g.MaxTokens
}

func (g *GoogleModel) GetEmotionRecognitionEnabled() *bool {
	if g == nil {
		return nil
	}
	return g.EmotionRecognitionEnabled
}

func (g *GoogleModel) GetNumFastTurns() *float64 {
	if g == nil {
		return nil
	}
	return g.NumFastTurns
}

func (g *GoogleModel) Provider() string {
	return g.provider
}

func (g *GoogleModel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleModel) UnmarshalJSON(data []byte) error {
	type embed GoogleModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleModel(unmarshaler.embed)
	if unmarshaler.Provider != "google" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "google", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleModel) MarshalJSON() ([]byte, error) {
	type embed GoogleModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "google",
	}
	return json.Marshal(marshaler)
}

func (g *GoogleModel) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// This is the Google model that will be used.
type GoogleModelModel string

const (
	GoogleModelModelGemini20FlashExp         GoogleModelModel = "gemini-2.0-flash-exp"
	GoogleModelModelGemini20FlashRealtimeExp GoogleModelModel = "gemini-2.0-flash-realtime-exp"
	GoogleModelModelGemini15Flash            GoogleModelModel = "gemini-1.5-flash"
	GoogleModelModelGemini15Flash002         GoogleModelModel = "gemini-1.5-flash-002"
	GoogleModelModelGemini15Pro              GoogleModelModel = "gemini-1.5-pro"
	GoogleModelModelGemini15Pro002           GoogleModelModel = "gemini-1.5-pro-002"
	GoogleModelModelGemini10Pro              GoogleModelModel = "gemini-1.0-pro"
)

func NewGoogleModelModelFromString(s string) (GoogleModelModel, error) {
	switch s {
	case "gemini-2.0-flash-exp":
		return GoogleModelModelGemini20FlashExp, nil
	case "gemini-2.0-flash-realtime-exp":
		return GoogleModelModelGemini20FlashRealtimeExp, nil
	case "gemini-1.5-flash":
		return GoogleModelModelGemini15Flash, nil
	case "gemini-1.5-flash-002":
		return GoogleModelModelGemini15Flash002, nil
	case "gemini-1.5-pro":
		return GoogleModelModelGemini15Pro, nil
	case "gemini-1.5-pro-002":
		return GoogleModelModelGemini15Pro002, nil
	case "gemini-1.0-pro":
		return GoogleModelModelGemini10Pro, nil
	}
	var t GoogleModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GoogleModelModel) Ptr() *GoogleModelModel {
	return &g
}

type GoogleModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (g *GoogleModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if g == nil {
		return nil
	}
	return g.CreateDtmfToolDto
}

func (g *GoogleModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if g == nil {
		return nil
	}
	return g.CreateEndCallToolDto
}

func (g *GoogleModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if g == nil {
		return nil
	}
	return g.CreateVoicemailToolDto
}

func (g *GoogleModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if g == nil {
		return nil
	}
	return g.CreateFunctionToolDto
}

func (g *GoogleModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGhlToolDto
}

func (g *GoogleModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if g == nil {
		return nil
	}
	return g.CreateMakeToolDto
}

func (g *GoogleModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if g == nil {
		return nil
	}
	return g.CreateTransferCallToolDto
}

func (g *GoogleModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		g.typ = "CreateDtmfToolDto"
		g.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		g.typ = "CreateEndCallToolDto"
		g.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		g.typ = "CreateVoicemailToolDto"
		g.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		g.typ = "CreateFunctionToolDto"
		g.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		g.typ = "CreateGhlToolDto"
		g.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		g.typ = "CreateMakeToolDto"
		g.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		g.typ = "CreateTransferCallToolDto"
		g.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GoogleModelToolsItem) MarshalJSON() ([]byte, error) {
	if g.typ == "CreateDtmfToolDto" || g.CreateDtmfToolDto != nil {
		return json.Marshal(g.CreateDtmfToolDto)
	}
	if g.typ == "CreateEndCallToolDto" || g.CreateEndCallToolDto != nil {
		return json.Marshal(g.CreateEndCallToolDto)
	}
	if g.typ == "CreateVoicemailToolDto" || g.CreateVoicemailToolDto != nil {
		return json.Marshal(g.CreateVoicemailToolDto)
	}
	if g.typ == "CreateFunctionToolDto" || g.CreateFunctionToolDto != nil {
		return json.Marshal(g.CreateFunctionToolDto)
	}
	if g.typ == "CreateGhlToolDto" || g.CreateGhlToolDto != nil {
		return json.Marshal(g.CreateGhlToolDto)
	}
	if g.typ == "CreateMakeToolDto" || g.CreateMakeToolDto != nil {
		return json.Marshal(g.CreateMakeToolDto)
	}
	if g.typ == "CreateTransferCallToolDto" || g.CreateTransferCallToolDto != nil {
		return json.Marshal(g.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (g *GoogleModelToolsItem) Accept(visitor GoogleModelToolsItemVisitor) error {
	if g.typ == "CreateDtmfToolDto" || g.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(g.CreateDtmfToolDto)
	}
	if g.typ == "CreateEndCallToolDto" || g.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(g.CreateEndCallToolDto)
	}
	if g.typ == "CreateVoicemailToolDto" || g.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(g.CreateVoicemailToolDto)
	}
	if g.typ == "CreateFunctionToolDto" || g.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(g.CreateFunctionToolDto)
	}
	if g.typ == "CreateGhlToolDto" || g.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(g.CreateGhlToolDto)
	}
	if g.typ == "CreateMakeToolDto" || g.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(g.CreateMakeToolDto)
	}
	if g.typ == "CreateTransferCallToolDto" || g.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(g.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GoogleRealtimeConfig struct {
	// This is the nucleus sampling parameter that controls the cumulative probability of tokens considered during text generation.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	TopP *float64 `json:"topP,omitempty" url:"topP,omitempty"`
	// This is the top-k sampling parameter that limits the number of highest probability tokens considered during text generation.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	TopK *float64 `json:"topK,omitempty" url:"topK,omitempty"`
	// This is the presence penalty parameter that influences the model's likelihood to repeat information by penalizing tokens based on their presence in the text.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	PresencePenalty *float64 `json:"presencePenalty,omitempty" url:"presencePenalty,omitempty"`
	// This is the frequency penalty parameter that influences the model's likelihood to repeat tokens by penalizing them based on their frequency in the text.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	FrequencyPenalty *float64 `json:"frequencyPenalty,omitempty" url:"frequencyPenalty,omitempty"`
	// This is the speech configuration object that defines the voice settings to be used for the model's speech output.
	// Only applicable with the Gemini Flash 2.0 Multimodal Live API.
	SpeechConfig *GeminiMultimodalLiveSpeechConfig `json:"speechConfig,omitempty" url:"speechConfig,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GoogleRealtimeConfig) GetTopP() *float64 {
	if g == nil {
		return nil
	}
	return g.TopP
}

func (g *GoogleRealtimeConfig) GetTopK() *float64 {
	if g == nil {
		return nil
	}
	return g.TopK
}

func (g *GoogleRealtimeConfig) GetPresencePenalty() *float64 {
	if g == nil {
		return nil
	}
	return g.PresencePenalty
}

func (g *GoogleRealtimeConfig) GetFrequencyPenalty() *float64 {
	if g == nil {
		return nil
	}
	return g.FrequencyPenalty
}

func (g *GoogleRealtimeConfig) GetSpeechConfig() *GeminiMultimodalLiveSpeechConfig {
	if g == nil {
		return nil
	}
	return g.SpeechConfig
}

func (g *GoogleRealtimeConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleRealtimeConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GoogleRealtimeConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoogleRealtimeConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleRealtimeConfig) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroqCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroqCredential) GetApiKey() string {
	if g == nil {
		return ""
	}
	return g.ApiKey
}

func (g *GroqCredential) GetId() string {
	if g == nil {
		return ""
	}
	return g.Id
}

func (g *GroqCredential) GetOrgId() string {
	if g == nil {
		return ""
	}
	return g.OrgId
}

func (g *GroqCredential) GetCreatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.CreatedAt
}

func (g *GroqCredential) GetUpdatedAt() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.UpdatedAt
}

func (g *GroqCredential) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GroqCredential) Provider() string {
	return g.provider
}

func (g *GroqCredential) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroqCredential) UnmarshalJSON(data []byte) error {
	type embed GroqCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GroqCredential(unmarshaler.embed)
	g.CreatedAt = unmarshaler.CreatedAt.Time()
	g.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "groq", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroqCredential) MarshalJSON() ([]byte, error) {
	type embed GroqCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*g),
		CreatedAt: internal.NewDateTime(g.CreatedAt),
		UpdatedAt: internal.NewDateTime(g.UpdatedAt),
		Provider:  "groq",
	}
	return json.Marshal(marshaler)
}

func (g *GroqCredential) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroqModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*GroqModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model GroqModelModel `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroqModel) GetMessages() []*OpenAiMessage {
	if g == nil {
		return nil
	}
	return g.Messages
}

func (g *GroqModel) GetTools() []*GroqModelToolsItem {
	if g == nil {
		return nil
	}
	return g.Tools
}

func (g *GroqModel) GetToolIds() []string {
	if g == nil {
		return nil
	}
	return g.ToolIds
}

func (g *GroqModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if g == nil {
		return nil
	}
	return g.KnowledgeBase
}

func (g *GroqModel) GetKnowledgeBaseId() *string {
	if g == nil {
		return nil
	}
	return g.KnowledgeBaseId
}

func (g *GroqModel) GetModel() GroqModelModel {
	if g == nil {
		return ""
	}
	return g.Model
}

func (g *GroqModel) GetTemperature() *float64 {
	if g == nil {
		return nil
	}
	return g.Temperature
}

func (g *GroqModel) GetMaxTokens() *float64 {
	if g == nil {
		return nil
	}
	return g.MaxTokens
}

func (g *GroqModel) GetEmotionRecognitionEnabled() *bool {
	if g == nil {
		return nil
	}
	return g.EmotionRecognitionEnabled
}

func (g *GroqModel) GetNumFastTurns() *float64 {
	if g == nil {
		return nil
	}
	return g.NumFastTurns
}

func (g *GroqModel) Provider() string {
	return g.provider
}

func (g *GroqModel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroqModel) UnmarshalJSON(data []byte) error {
	type embed GroqModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GroqModel(unmarshaler.embed)
	if unmarshaler.Provider != "groq" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "groq", unmarshaler.Provider)
	}
	g.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *g, "provider")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroqModel) MarshalJSON() ([]byte, error) {
	type embed GroqModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*g),
		Provider: "groq",
	}
	return json.Marshal(marshaler)
}

func (g *GroqModel) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
type GroqModelModel string

const (
	GroqModelModelLlama3370BVersatile  GroqModelModel = "llama-3.3-70b-versatile"
	GroqModelModelLlama31405BReasoning GroqModelModel = "llama-3.1-405b-reasoning"
	GroqModelModelLlama3170BVersatile  GroqModelModel = "llama-3.1-70b-versatile"
	GroqModelModelLlama318BInstant     GroqModelModel = "llama-3.1-8b-instant"
	GroqModelModelMixtral8X7B32768     GroqModelModel = "mixtral-8x7b-32768"
	GroqModelModelLlama38B8192         GroqModelModel = "llama3-8b-8192"
	GroqModelModelLlama370B8192        GroqModelModel = "llama3-70b-8192"
	GroqModelModelGemma29BIt           GroqModelModel = "gemma2-9b-it"
)

func NewGroqModelModelFromString(s string) (GroqModelModel, error) {
	switch s {
	case "llama-3.3-70b-versatile":
		return GroqModelModelLlama3370BVersatile, nil
	case "llama-3.1-405b-reasoning":
		return GroqModelModelLlama31405BReasoning, nil
	case "llama-3.1-70b-versatile":
		return GroqModelModelLlama3170BVersatile, nil
	case "llama-3.1-8b-instant":
		return GroqModelModelLlama318BInstant, nil
	case "mixtral-8x7b-32768":
		return GroqModelModelMixtral8X7B32768, nil
	case "llama3-8b-8192":
		return GroqModelModelLlama38B8192, nil
	case "llama3-70b-8192":
		return GroqModelModelLlama370B8192, nil
	case "gemma2-9b-it":
		return GroqModelModelGemma29BIt, nil
	}
	var t GroqModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GroqModelModel) Ptr() *GroqModelModel {
	return &g
}

type GroqModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (g *GroqModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if g == nil {
		return nil
	}
	return g.CreateDtmfToolDto
}

func (g *GroqModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if g == nil {
		return nil
	}
	return g.CreateEndCallToolDto
}

func (g *GroqModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if g == nil {
		return nil
	}
	return g.CreateVoicemailToolDto
}

func (g *GroqModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if g == nil {
		return nil
	}
	return g.CreateFunctionToolDto
}

func (g *GroqModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if g == nil {
		return nil
	}
	return g.CreateGhlToolDto
}

func (g *GroqModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if g == nil {
		return nil
	}
	return g.CreateMakeToolDto
}

func (g *GroqModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if g == nil {
		return nil
	}
	return g.CreateTransferCallToolDto
}

func (g *GroqModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		g.typ = "CreateDtmfToolDto"
		g.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		g.typ = "CreateEndCallToolDto"
		g.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		g.typ = "CreateVoicemailToolDto"
		g.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		g.typ = "CreateFunctionToolDto"
		g.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		g.typ = "CreateGhlToolDto"
		g.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		g.typ = "CreateMakeToolDto"
		g.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		g.typ = "CreateTransferCallToolDto"
		g.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroqModelToolsItem) MarshalJSON() ([]byte, error) {
	if g.typ == "CreateDtmfToolDto" || g.CreateDtmfToolDto != nil {
		return json.Marshal(g.CreateDtmfToolDto)
	}
	if g.typ == "CreateEndCallToolDto" || g.CreateEndCallToolDto != nil {
		return json.Marshal(g.CreateEndCallToolDto)
	}
	if g.typ == "CreateVoicemailToolDto" || g.CreateVoicemailToolDto != nil {
		return json.Marshal(g.CreateVoicemailToolDto)
	}
	if g.typ == "CreateFunctionToolDto" || g.CreateFunctionToolDto != nil {
		return json.Marshal(g.CreateFunctionToolDto)
	}
	if g.typ == "CreateGhlToolDto" || g.CreateGhlToolDto != nil {
		return json.Marshal(g.CreateGhlToolDto)
	}
	if g.typ == "CreateMakeToolDto" || g.CreateMakeToolDto != nil {
		return json.Marshal(g.CreateMakeToolDto)
	}
	if g.typ == "CreateTransferCallToolDto" || g.CreateTransferCallToolDto != nil {
		return json.Marshal(g.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroqModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (g *GroqModelToolsItem) Accept(visitor GroqModelToolsItemVisitor) error {
	if g.typ == "CreateDtmfToolDto" || g.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(g.CreateDtmfToolDto)
	}
	if g.typ == "CreateEndCallToolDto" || g.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(g.CreateEndCallToolDto)
	}
	if g.typ == "CreateVoicemailToolDto" || g.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(g.CreateVoicemailToolDto)
	}
	if g.typ == "CreateFunctionToolDto" || g.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(g.CreateFunctionToolDto)
	}
	if g.typ == "CreateGhlToolDto" || g.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(g.CreateGhlToolDto)
	}
	if g.typ == "CreateMakeToolDto" || g.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(g.CreateMakeToolDto)
	}
	if g.typ == "CreateTransferCallToolDto" || g.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(g.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type HandoffStep struct {
	// This is the block to use. To use an existing block, use `blockId`.
	Block *HandoffStepBlock `json:"block,omitempty" url:"block,omitempty"`
	// This is a step that takes a handoff from the previous step. This means it won't return to the calling step. The workflow execution will continue linearly.
	//
	// Use case:
	// - You want to collect information linearly (e.g. a form, provide information, etc).
	// These are the destinations that the step can go to after it's done.
	Destinations []*StepDestination `json:"destinations,omitempty" url:"destinations,omitempty"`
	// This is the name of the step.
	Name string `json:"name" url:"name"`
	// This is the id of the block to use. To use a transient block, use `block`.
	BlockId *string `json:"blockId,omitempty" url:"blockId,omitempty"`
	// This is the input to the block. You can use any key-value map as input to the block.
	//
	// Example:
	//
	//	{
	//	  "name": "John Doe",
	//	  "age": 20
	//	}
	//
	// You can reference any variable in the context of the current block:
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// Example:
	//
	//	{
	//	  "name": "{{my-tool-call-step.output.name}}",
	//	  "age": "{{my-tool-call-step.input.age}}",
	//	  "date": "{{workflow.input.date}}"
	//	}
	//
	// You can dynamically change the key name.
	//
	// Example:
	//
	//	{
	//	  "{{my-tool-call-step.output.key-name-for-name}}": "{{name}}",
	//	  "{{my-tool-call-step.input.key-name-for-age}}": "{{age}}",
	//	  "{{workflow.input.key-name-for-date}}": "{{date}}"
	//	}
	//
	// You can represent the value as a string, number, boolean, array, or object.
	//
	// Example:
	//
	//	{
	//	  "name": "john",
	//	  "age": 20,
	//	  "date": "2021-01-01",
	//	  "metadata": {
	//	    "unique-key": "{{my-tool-call-step.output.unique-key}}"
	//	  },
	//	  "array": ["A", "B", "C"],
	//	}
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.
	Input map[string]interface{} `json:"input,omitempty" url:"input,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HandoffStep) GetBlock() *HandoffStepBlock {
	if h == nil {
		return nil
	}
	return h.Block
}

func (h *HandoffStep) GetDestinations() []*StepDestination {
	if h == nil {
		return nil
	}
	return h.Destinations
}

func (h *HandoffStep) GetName() string {
	if h == nil {
		return ""
	}
	return h.Name
}

func (h *HandoffStep) GetBlockId() *string {
	if h == nil {
		return nil
	}
	return h.BlockId
}

func (h *HandoffStep) GetInput() map[string]interface{} {
	if h == nil {
		return nil
	}
	return h.Input
}

func (h *HandoffStep) Type() string {
	return h.type_
}

func (h *HandoffStep) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HandoffStep) UnmarshalJSON(data []byte) error {
	type embed HandoffStep
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HandoffStep(unmarshaler.embed)
	if unmarshaler.Type != "handoff" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", h, "handoff", unmarshaler.Type)
	}
	h.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *h, "type")
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HandoffStep) MarshalJSON() ([]byte, error) {
	type embed HandoffStep
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*h),
		Type:  "handoff",
	}
	return json.Marshal(marshaler)
}

func (h *HandoffStep) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// This is the block to use. To use an existing block, use `blockId`.
type HandoffStepBlock struct {
	CreateConversationBlockDto *CreateConversationBlockDto
	CreateToolCallBlockDto     *CreateToolCallBlockDto
	// This is the CreateWorkflowBlockDTO object but Swagger does not display nested schemas correctly.
	CreateWorkflowBlockDto *CreateWorkflowBlockDto

	typ string
}

func (h *HandoffStepBlock) GetCreateConversationBlockDto() *CreateConversationBlockDto {
	if h == nil {
		return nil
	}
	return h.CreateConversationBlockDto
}

func (h *HandoffStepBlock) GetCreateToolCallBlockDto() *CreateToolCallBlockDto {
	if h == nil {
		return nil
	}
	return h.CreateToolCallBlockDto
}

func (h *HandoffStepBlock) GetCreateWorkflowBlockDto() *CreateWorkflowBlockDto {
	if h == nil {
		return nil
	}
	return h.CreateWorkflowBlockDto
}

func (h *HandoffStepBlock) UnmarshalJSON(data []byte) error {
	valueCreateConversationBlockDto := new(CreateConversationBlockDto)
	if err := json.Unmarshal(data, &valueCreateConversationBlockDto); err == nil {
		h.typ = "CreateConversationBlockDto"
		h.CreateConversationBlockDto = valueCreateConversationBlockDto
		return nil
	}
	valueCreateToolCallBlockDto := new(CreateToolCallBlockDto)
	if err := json.Unmarshal(data, &valueCreateToolCallBlockDto); err == nil {
		h.typ = "CreateToolCallBlockDto"
		h.CreateToolCallBlockDto = valueCreateToolCallBlockDto
		return nil
	}
	valueCreateWorkflowBlockDto := new(CreateWorkflowBlockDto)
	if err := json.Unmarshal(data, &valueCreateWorkflowBlockDto); err == nil {
		h.typ = "CreateWorkflowBlockDto"
		h.CreateWorkflowBlockDto = valueCreateWorkflowBlockDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HandoffStepBlock) MarshalJSON() ([]byte, error) {
	if h.typ == "CreateConversationBlockDto" || h.CreateConversationBlockDto != nil {
		return json.Marshal(h.CreateConversationBlockDto)
	}
	if h.typ == "CreateToolCallBlockDto" || h.CreateToolCallBlockDto != nil {
		return json.Marshal(h.CreateToolCallBlockDto)
	}
	if h.typ == "CreateWorkflowBlockDto" || h.CreateWorkflowBlockDto != nil {
		return json.Marshal(h.CreateWorkflowBlockDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HandoffStepBlockVisitor interface {
	VisitCreateConversationBlockDto(*CreateConversationBlockDto) error
	VisitCreateToolCallBlockDto(*CreateToolCallBlockDto) error
	VisitCreateWorkflowBlockDto(*CreateWorkflowBlockDto) error
}

func (h *HandoffStepBlock) Accept(visitor HandoffStepBlockVisitor) error {
	if h.typ == "CreateConversationBlockDto" || h.CreateConversationBlockDto != nil {
		return visitor.VisitCreateConversationBlockDto(h.CreateConversationBlockDto)
	}
	if h.typ == "CreateToolCallBlockDto" || h.CreateToolCallBlockDto != nil {
		return visitor.VisitCreateToolCallBlockDto(h.CreateToolCallBlockDto)
	}
	if h.typ == "CreateWorkflowBlockDto" || h.CreateWorkflowBlockDto != nil {
		return visitor.VisitCreateWorkflowBlockDto(h.CreateWorkflowBlockDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

type ImportVonagePhoneNumberDto struct {
	// This is the fallback destination an inbound call will be transferred to if:
	// 1. `assistantId` is not set
	// 2. `squadId` is not set
	// 3. and, `assistant-request` message to the `serverUrl` fails
	//
	// If this is not set and above conditions are met, the inbound call is hung up with an error message.
	FallbackDestination *ImportVonagePhoneNumberDtoFallbackDestination `json:"fallbackDestination,omitempty" url:"fallbackDestination,omitempty"`
	// These are the digits of the phone number you own on your Vonage.
	VonagePhoneNumber string `json:"vonagePhoneNumber" url:"vonagePhoneNumber"`
	// This is the credential that is used to make outgoing calls, and do operations like call transfer and hang up.
	//
	// You can add the Vonage Credential in the Provider Credentials page on the dashboard to get the credentialId.
	CredentialId string `json:"credentialId" url:"credentialId"`
	// This is the name of the phone number. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the assistant that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the squad that will be used for incoming calls to this phone number.
	//
	// If neither `assistantId` nor `squadId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ImportVonagePhoneNumberDto) GetFallbackDestination() *ImportVonagePhoneNumberDtoFallbackDestination {
	if i == nil {
		return nil
	}
	return i.FallbackDestination
}

func (i *ImportVonagePhoneNumberDto) GetVonagePhoneNumber() string {
	if i == nil {
		return ""
	}
	return i.VonagePhoneNumber
}

func (i *ImportVonagePhoneNumberDto) GetCredentialId() string {
	if i == nil {
		return ""
	}
	return i.CredentialId
}

func (i *ImportVonagePhoneNumberDto) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *ImportVonagePhoneNumberDto) GetAssistantId() *string {
	if i == nil {
		return nil
	}
	return i.AssistantId
}

func (i *ImportVonagePhoneNumberDto) GetSquadId() *string {
	if i == nil {
		return nil
	}
	return i.SquadId
}

func (i *ImportVonagePhoneNumberDto) GetServer() *Server {
	if i == nil {
		return nil
	}
	return i.Server
}

func (i *ImportVonagePhoneNumberDto) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImportVonagePhoneNumberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler ImportVonagePhoneNumberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImportVonagePhoneNumberDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImportVonagePhoneNumberDto) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// This is the fallback destination an inbound call will be transferred to if:
// 1. `assistantId` is not set
// 2. `squadId` is not set
// 3. and, `assistant-request` message to the `serverUrl` fails
//
// If this is not set and above conditions are met, the inbound call is hung up with an error message.
type ImportVonagePhoneNumberDtoFallbackDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if i == nil {
		return nil
	}
	return i.TransferDestinationNumber
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if i == nil {
		return nil
	}
	return i.TransferDestinationSip
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		i.typ = "TransferDestinationNumber"
		i.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		i.typ = "TransferDestinationSip"
		i.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i ImportVonagePhoneNumberDtoFallbackDestination) MarshalJSON() ([]byte, error) {
	if i.typ == "TransferDestinationNumber" || i.TransferDestinationNumber != nil {
		return json.Marshal(i.TransferDestinationNumber)
	}
	if i.typ == "TransferDestinationSip" || i.TransferDestinationSip != nil {
		return json.Marshal(i.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type ImportVonagePhoneNumberDtoFallbackDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (i *ImportVonagePhoneNumberDtoFallbackDestination) Accept(visitor ImportVonagePhoneNumberDtoFallbackDestinationVisitor) error {
	if i.typ == "TransferDestinationNumber" || i.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(i.TransferDestinationNumber)
	}
	if i.typ == "TransferDestinationSip" || i.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(i.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InflectionAiCredential struct {
	// This is the api key for Pi in InflectionAI's console. Get it from here: https://developers.inflection.ai/keys, billing will need to be setup
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InflectionAiCredential) GetApiKey() string {
	if i == nil {
		return ""
	}
	return i.ApiKey
}

func (i *InflectionAiCredential) GetId() string {
	if i == nil {
		return ""
	}
	return i.Id
}

func (i *InflectionAiCredential) GetOrgId() string {
	if i == nil {
		return ""
	}
	return i.OrgId
}

func (i *InflectionAiCredential) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InflectionAiCredential) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InflectionAiCredential) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InflectionAiCredential) Provider() string {
	return i.provider
}

func (i *InflectionAiCredential) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InflectionAiCredential) UnmarshalJSON(data []byte) error {
	type embed InflectionAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InflectionAiCredential(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "inflection-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", i, "inflection-ai", unmarshaler.Provider)
	}
	i.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *i, "provider")
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InflectionAiCredential) MarshalJSON() ([]byte, error) {
	type embed InflectionAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
		Provider:  "inflection-ai",
	}
	return json.Marshal(marshaler)
}

func (i *InflectionAiCredential) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InflectionAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*InflectionAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	model        string
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InflectionAiModel) GetMessages() []*OpenAiMessage {
	if i == nil {
		return nil
	}
	return i.Messages
}

func (i *InflectionAiModel) GetTools() []*InflectionAiModelToolsItem {
	if i == nil {
		return nil
	}
	return i.Tools
}

func (i *InflectionAiModel) GetToolIds() []string {
	if i == nil {
		return nil
	}
	return i.ToolIds
}

func (i *InflectionAiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if i == nil {
		return nil
	}
	return i.KnowledgeBase
}

func (i *InflectionAiModel) GetKnowledgeBaseId() *string {
	if i == nil {
		return nil
	}
	return i.KnowledgeBaseId
}

func (i *InflectionAiModel) GetTemperature() *float64 {
	if i == nil {
		return nil
	}
	return i.Temperature
}

func (i *InflectionAiModel) GetMaxTokens() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxTokens
}

func (i *InflectionAiModel) GetEmotionRecognitionEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.EmotionRecognitionEnabled
}

func (i *InflectionAiModel) GetNumFastTurns() *float64 {
	if i == nil {
		return nil
	}
	return i.NumFastTurns
}

func (i *InflectionAiModel) Model() string {
	return i.model
}

func (i *InflectionAiModel) Provider() string {
	return i.provider
}

func (i *InflectionAiModel) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InflectionAiModel) UnmarshalJSON(data []byte) error {
	type embed InflectionAiModel
	var unmarshaler = struct {
		embed
		Model    string `json:"model"`
		Provider string `json:"provider"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InflectionAiModel(unmarshaler.embed)
	if unmarshaler.Model != "inflection_3_pi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", i, "inflection_3_pi", unmarshaler.Model)
	}
	i.model = unmarshaler.Model
	if unmarshaler.Provider != "inflection-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", i, "inflection-ai", unmarshaler.Provider)
	}
	i.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *i, "model", "provider")
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InflectionAiModel) MarshalJSON() ([]byte, error) {
	type embed InflectionAiModel
	var marshaler = struct {
		embed
		Model    string `json:"model"`
		Provider string `json:"provider"`
	}{
		embed:    embed(*i),
		Model:    "inflection_3_pi",
		Provider: "inflection-ai",
	}
	return json.Marshal(marshaler)
}

func (i *InflectionAiModel) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InflectionAiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (i *InflectionAiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if i == nil {
		return nil
	}
	return i.CreateDtmfToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if i == nil {
		return nil
	}
	return i.CreateEndCallToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if i == nil {
		return nil
	}
	return i.CreateVoicemailToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if i == nil {
		return nil
	}
	return i.CreateFunctionToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if i == nil {
		return nil
	}
	return i.CreateGhlToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if i == nil {
		return nil
	}
	return i.CreateMakeToolDto
}

func (i *InflectionAiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if i == nil {
		return nil
	}
	return i.CreateTransferCallToolDto
}

func (i *InflectionAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		i.typ = "CreateDtmfToolDto"
		i.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		i.typ = "CreateEndCallToolDto"
		i.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		i.typ = "CreateVoicemailToolDto"
		i.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		i.typ = "CreateFunctionToolDto"
		i.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		i.typ = "CreateGhlToolDto"
		i.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		i.typ = "CreateMakeToolDto"
		i.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		i.typ = "CreateTransferCallToolDto"
		i.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InflectionAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if i.typ == "CreateDtmfToolDto" || i.CreateDtmfToolDto != nil {
		return json.Marshal(i.CreateDtmfToolDto)
	}
	if i.typ == "CreateEndCallToolDto" || i.CreateEndCallToolDto != nil {
		return json.Marshal(i.CreateEndCallToolDto)
	}
	if i.typ == "CreateVoicemailToolDto" || i.CreateVoicemailToolDto != nil {
		return json.Marshal(i.CreateVoicemailToolDto)
	}
	if i.typ == "CreateFunctionToolDto" || i.CreateFunctionToolDto != nil {
		return json.Marshal(i.CreateFunctionToolDto)
	}
	if i.typ == "CreateGhlToolDto" || i.CreateGhlToolDto != nil {
		return json.Marshal(i.CreateGhlToolDto)
	}
	if i.typ == "CreateMakeToolDto" || i.CreateMakeToolDto != nil {
		return json.Marshal(i.CreateMakeToolDto)
	}
	if i.typ == "CreateTransferCallToolDto" || i.CreateTransferCallToolDto != nil {
		return json.Marshal(i.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InflectionAiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (i *InflectionAiModelToolsItem) Accept(visitor InflectionAiModelToolsItemVisitor) error {
	if i.typ == "CreateDtmfToolDto" || i.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(i.CreateDtmfToolDto)
	}
	if i.typ == "CreateEndCallToolDto" || i.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(i.CreateEndCallToolDto)
	}
	if i.typ == "CreateVoicemailToolDto" || i.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(i.CreateVoicemailToolDto)
	}
	if i.typ == "CreateFunctionToolDto" || i.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(i.CreateFunctionToolDto)
	}
	if i.typ == "CreateGhlToolDto" || i.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(i.CreateGhlToolDto)
	}
	if i.typ == "CreateMakeToolDto" || i.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(i.CreateMakeToolDto)
	}
	if i.typ == "CreateTransferCallToolDto" || i.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(i.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InviteUserDto struct {
	Emails []string          `json:"emails,omitempty" url:"emails,omitempty"`
	Role   InviteUserDtoRole `json:"role" url:"role"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InviteUserDto) GetEmails() []string {
	if i == nil {
		return nil
	}
	return i.Emails
}

func (i *InviteUserDto) GetRole() InviteUserDtoRole {
	if i == nil {
		return ""
	}
	return i.Role
}

func (i *InviteUserDto) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InviteUserDto) UnmarshalJSON(data []byte) error {
	type unmarshaler InviteUserDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InviteUserDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InviteUserDto) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InviteUserDtoRole string

const (
	InviteUserDtoRoleAdmin  InviteUserDtoRole = "admin"
	InviteUserDtoRoleEditor InviteUserDtoRole = "editor"
	InviteUserDtoRoleViewer InviteUserDtoRole = "viewer"
)

func NewInviteUserDtoRoleFromString(s string) (InviteUserDtoRole, error) {
	switch s {
	case "admin":
		return InviteUserDtoRoleAdmin, nil
	case "editor":
		return InviteUserDtoRoleEditor, nil
	case "viewer":
		return InviteUserDtoRoleViewer, nil
	}
	var t InviteUserDtoRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InviteUserDtoRole) Ptr() *InviteUserDtoRole {
	return &i
}

type JsonSchema struct {
	// This is the type of output you'd like.
	//
	// `string`, `number`, `integer`, `boolean` are the primitive types and should be obvious.
	//
	// `array` and `object` are more interesting and quite powerful. They allow you to define nested structures.
	//
	// For `array`, you can define the schema of the items in the array using the `items` property.
	//
	// For `object`, you can define the properties of the object using the `properties` property.
	Type JsonSchemaType `json:"type" url:"type"`
	// This is required if the type is "array". This is the schema of the items in the array.
	//
	// This is of type JsonSchema. However, Swagger doesn't support circular references.
	Items map[string]interface{} `json:"items,omitempty" url:"items,omitempty"`
	// This is required if the type is "object". This specifies the properties of the object.
	//
	// This is a map of string to JsonSchema. However, Swagger doesn't support circular references.
	Properties map[string]interface{} `json:"properties,omitempty" url:"properties,omitempty"`
	// This is the description to help the model understand what it needs to output.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// This is a list of properties that are required.
	//
	// This only makes sense if the type is "object".
	Required []string `json:"required,omitempty" url:"required,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JsonSchema) GetType() JsonSchemaType {
	if j == nil {
		return ""
	}
	return j.Type
}

func (j *JsonSchema) GetItems() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.Items
}

func (j *JsonSchema) GetProperties() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.Properties
}

func (j *JsonSchema) GetDescription() *string {
	if j == nil {
		return nil
	}
	return j.Description
}

func (j *JsonSchema) GetRequired() []string {
	if j == nil {
		return nil
	}
	return j.Required
}

func (j *JsonSchema) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonSchema) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// This is the type of output you'd like.
//
// `string`, `number`, `integer`, `boolean` are the primitive types and should be obvious.
//
// `array` and `object` are more interesting and quite powerful. They allow you to define nested structures.
//
// For `array`, you can define the schema of the items in the array using the `items` property.
//
// For `object`, you can define the properties of the object using the `properties` property.
type JsonSchemaType string

const (
	JsonSchemaTypeString  JsonSchemaType = "string"
	JsonSchemaTypeNumber  JsonSchemaType = "number"
	JsonSchemaTypeInteger JsonSchemaType = "integer"
	JsonSchemaTypeBoolean JsonSchemaType = "boolean"
	JsonSchemaTypeArray   JsonSchemaType = "array"
	JsonSchemaTypeObject  JsonSchemaType = "object"
)

func NewJsonSchemaTypeFromString(s string) (JsonSchemaType, error) {
	switch s {
	case "string":
		return JsonSchemaTypeString, nil
	case "number":
		return JsonSchemaTypeNumber, nil
	case "integer":
		return JsonSchemaTypeInteger, nil
	case "boolean":
		return JsonSchemaTypeBoolean, nil
	case "array":
		return JsonSchemaTypeArray, nil
	case "object":
		return JsonSchemaTypeObject, nil
	}
	var t JsonSchemaType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JsonSchemaType) Ptr() *JsonSchemaType {
	return &j
}

type KnowledgeBaseResponseDocument struct {
	// This is the content of the document.
	Content string `json:"content" url:"content"`
	// This is the similarity score of the document.
	Similarity float64 `json:"similarity" url:"similarity"`
	// This is the uuid of the document.
	Uuid *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseResponseDocument) GetContent() string {
	if k == nil {
		return ""
	}
	return k.Content
}

func (k *KnowledgeBaseResponseDocument) GetSimilarity() float64 {
	if k == nil {
		return 0
	}
	return k.Similarity
}

func (k *KnowledgeBaseResponseDocument) GetUuid() *string {
	if k == nil {
		return nil
	}
	return k.Uuid
}

func (k *KnowledgeBaseResponseDocument) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseResponseDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBaseResponseDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBaseResponseDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseResponseDocument) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// This is the provider-specific ID that will be used.
type LmntVoiceId struct {
	LmntVoiceIdEnum LmntVoiceIdEnum
	String          string

	typ string
}

func (l *LmntVoiceId) GetLmntVoiceIdEnum() LmntVoiceIdEnum {
	if l == nil {
		return ""
	}
	return l.LmntVoiceIdEnum
}

func (l *LmntVoiceId) GetString() string {
	if l == nil {
		return ""
	}
	return l.String
}

func (l *LmntVoiceId) UnmarshalJSON(data []byte) error {
	var valueLmntVoiceIdEnum LmntVoiceIdEnum
	if err := json.Unmarshal(data, &valueLmntVoiceIdEnum); err == nil {
		l.typ = "LmntVoiceIdEnum"
		l.LmntVoiceIdEnum = valueLmntVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typ = "String"
		l.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LmntVoiceId) MarshalJSON() ([]byte, error) {
	if l.typ == "LmntVoiceIdEnum" || l.LmntVoiceIdEnum != "" {
		return json.Marshal(l.LmntVoiceIdEnum)
	}
	if l.typ == "String" || l.String != "" {
		return json.Marshal(l.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LmntVoiceIdVisitor interface {
	VisitLmntVoiceIdEnum(LmntVoiceIdEnum) error
	VisitString(string) error
}

func (l *LmntVoiceId) Accept(visitor LmntVoiceIdVisitor) error {
	if l.typ == "LmntVoiceIdEnum" || l.LmntVoiceIdEnum != "" {
		return visitor.VisitLmntVoiceIdEnum(l.LmntVoiceIdEnum)
	}
	if l.typ == "String" || l.String != "" {
		return visitor.VisitString(l.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LmntVoiceIdEnum string

const (
	LmntVoiceIdEnumLily   LmntVoiceIdEnum = "lily"
	LmntVoiceIdEnumDaniel LmntVoiceIdEnum = "daniel"
)

func NewLmntVoiceIdEnumFromString(s string) (LmntVoiceIdEnum, error) {
	switch s {
	case "lily":
		return LmntVoiceIdEnumLily, nil
	case "daniel":
		return LmntVoiceIdEnumDaniel, nil
	}
	var t LmntVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LmntVoiceIdEnum) Ptr() *LmntVoiceIdEnum {
	return &l
}

type LangfuseCredential struct {
	// The public key for Langfuse project. Eg: pk-lf-...
	PublicKey string `json:"publicKey" url:"publicKey"`
	// The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// The host URL for Langfuse project. Eg: https://cloud.langfuse.com
	ApiUrl string `json:"apiUrl" url:"apiUrl"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LangfuseCredential) GetPublicKey() string {
	if l == nil {
		return ""
	}
	return l.PublicKey
}

func (l *LangfuseCredential) GetApiKey() string {
	if l == nil {
		return ""
	}
	return l.ApiKey
}

func (l *LangfuseCredential) GetApiUrl() string {
	if l == nil {
		return ""
	}
	return l.ApiUrl
}

func (l *LangfuseCredential) GetId() string {
	if l == nil {
		return ""
	}
	return l.Id
}

func (l *LangfuseCredential) GetOrgId() string {
	if l == nil {
		return ""
	}
	return l.OrgId
}

func (l *LangfuseCredential) GetCreatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.CreatedAt
}

func (l *LangfuseCredential) GetUpdatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.UpdatedAt
}

func (l *LangfuseCredential) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LangfuseCredential) Provider() string {
	return l.provider
}

func (l *LangfuseCredential) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LangfuseCredential) UnmarshalJSON(data []byte) error {
	type embed LangfuseCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LangfuseCredential(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.Time()
	l.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "langfuse" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "langfuse", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LangfuseCredential) MarshalJSON() ([]byte, error) {
	type embed LangfuseCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*l),
		CreatedAt: internal.NewDateTime(l.CreatedAt),
		UpdatedAt: internal.NewDateTime(l.UpdatedAt),
		Provider:  "langfuse",
	}
	return json.Marshal(marshaler)
}

func (l *LangfuseCredential) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LmntCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LmntCredential) GetApiKey() string {
	if l == nil {
		return ""
	}
	return l.ApiKey
}

func (l *LmntCredential) GetId() string {
	if l == nil {
		return ""
	}
	return l.Id
}

func (l *LmntCredential) GetOrgId() string {
	if l == nil {
		return ""
	}
	return l.OrgId
}

func (l *LmntCredential) GetCreatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.CreatedAt
}

func (l *LmntCredential) GetUpdatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.UpdatedAt
}

func (l *LmntCredential) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LmntCredential) Provider() string {
	return l.provider
}

func (l *LmntCredential) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LmntCredential) UnmarshalJSON(data []byte) error {
	type embed LmntCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LmntCredential(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.Time()
	l.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "lmnt", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LmntCredential) MarshalJSON() ([]byte, error) {
	type embed LmntCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*l),
		CreatedAt: internal.NewDateTime(l.CreatedAt),
		UpdatedAt: internal.NewDateTime(l.UpdatedAt),
		Provider:  "lmnt",
	}
	return json.Marshal(marshaler)
}

func (l *LmntCredential) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LmntVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *LmntVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LmntVoice) GetVoiceId() *LmntVoiceId {
	if l == nil {
		return nil
	}
	return l.VoiceId
}

func (l *LmntVoice) GetSpeed() *float64 {
	if l == nil {
		return nil
	}
	return l.Speed
}

func (l *LmntVoice) GetChunkPlan() *ChunkPlan {
	if l == nil {
		return nil
	}
	return l.ChunkPlan
}

func (l *LmntVoice) GetFallbackPlan() *FallbackPlan {
	if l == nil {
		return nil
	}
	return l.FallbackPlan
}

func (l *LmntVoice) Provider() string {
	return l.provider
}

func (l *LmntVoice) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LmntVoice) UnmarshalJSON(data []byte) error {
	type embed LmntVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LmntVoice(unmarshaler.embed)
	if unmarshaler.Provider != "lmnt" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", l, "lmnt", unmarshaler.Provider)
	}
	l.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *l, "provider")
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LmntVoice) MarshalJSON() ([]byte, error) {
	type embed LmntVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*l),
		Provider: "lmnt",
	}
	return json.Marshal(marshaler)
}

func (l *LmntVoice) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MakeCredential struct {
	// Team ID
	TeamId string `json:"teamId" url:"teamId"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region string `json:"region" url:"region"`
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeCredential) GetTeamId() string {
	if m == nil {
		return ""
	}
	return m.TeamId
}

func (m *MakeCredential) GetRegion() string {
	if m == nil {
		return ""
	}
	return m.Region
}

func (m *MakeCredential) GetApiKey() string {
	if m == nil {
		return ""
	}
	return m.ApiKey
}

func (m *MakeCredential) GetId() string {
	if m == nil {
		return ""
	}
	return m.Id
}

func (m *MakeCredential) GetOrgId() string {
	if m == nil {
		return ""
	}
	return m.OrgId
}

func (m *MakeCredential) GetCreatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.CreatedAt
}

func (m *MakeCredential) GetUpdatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.UpdatedAt
}

func (m *MakeCredential) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MakeCredential) Provider() string {
	return m.provider
}

func (m *MakeCredential) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeCredential) UnmarshalJSON(data []byte) error {
	type embed MakeCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeCredential(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Provider)
	}
	m.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "provider")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeCredential) MarshalJSON() ([]byte, error) {
	type embed MakeCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*m),
		CreatedAt: internal.NewDateTime(m.CreatedAt),
		UpdatedAt: internal.NewDateTime(m.UpdatedAt),
		Provider:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeCredential) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolMetadata struct {
	ScenarioId    *float64 `json:"scenarioId,omitempty" url:"scenarioId,omitempty"`
	TriggerHookId *float64 `json:"triggerHookId,omitempty" url:"triggerHookId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeToolMetadata) GetScenarioId() *float64 {
	if m == nil {
		return nil
	}
	return m.ScenarioId
}

func (m *MakeToolMetadata) GetTriggerHookId() *float64 {
	if m == nil {
		return nil
	}
	return m.TriggerHookId
}

func (m *MakeToolMetadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler MakeToolMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MakeToolMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolMetadata) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolProviderDetails struct {
	// This is the Template URL or the Snapshot URL corresponding to the Template.
	TemplateUrl       *string              `json:"templateUrl,omitempty" url:"templateUrl,omitempty"`
	SetupInstructions []*ToolTemplateSetup `json:"setupInstructions,omitempty" url:"setupInstructions,omitempty"`
	// The type of tool. "make" for Make tool.
	ScenarioId      *float64 `json:"scenarioId,omitempty" url:"scenarioId,omitempty"`
	ScenarioName    *string  `json:"scenarioName,omitempty" url:"scenarioName,omitempty"`
	TriggerHookId   *float64 `json:"triggerHookId,omitempty" url:"triggerHookId,omitempty"`
	TriggerHookName *string  `json:"triggerHookName,omitempty" url:"triggerHookName,omitempty"`
	type_           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeToolProviderDetails) GetTemplateUrl() *string {
	if m == nil {
		return nil
	}
	return m.TemplateUrl
}

func (m *MakeToolProviderDetails) GetSetupInstructions() []*ToolTemplateSetup {
	if m == nil {
		return nil
	}
	return m.SetupInstructions
}

func (m *MakeToolProviderDetails) GetScenarioId() *float64 {
	if m == nil {
		return nil
	}
	return m.ScenarioId
}

func (m *MakeToolProviderDetails) GetScenarioName() *string {
	if m == nil {
		return nil
	}
	return m.ScenarioName
}

func (m *MakeToolProviderDetails) GetTriggerHookId() *float64 {
	if m == nil {
		return nil
	}
	return m.TriggerHookId
}

func (m *MakeToolProviderDetails) GetTriggerHookName() *string {
	if m == nil {
		return nil
	}
	return m.TriggerHookName
}

func (m *MakeToolProviderDetails) Type() string {
	return m.type_
}

func (m *MakeToolProviderDetails) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolProviderDetails) UnmarshalJSON(data []byte) error {
	type embed MakeToolProviderDetails
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeToolProviderDetails(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolProviderDetails) MarshalJSON() ([]byte, error) {
	type embed MakeToolProviderDetails
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeToolProviderDetails) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolWithToolCall struct {
	// This determines if the tool is async.
	//
	// If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.
	//
	// If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.
	//
	// Defaults to synchronous (`false`).
	Async *bool `json:"async,omitempty" url:"async,omitempty"`
	// These are the messages that will be spoken to the user as the tool is running.
	//
	// For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
	Messages []*MakeToolWithToolCallMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// The type of tool. "make" for Make tool.
	ToolCall *ToolCall         `json:"toolCall,omitempty" url:"toolCall,omitempty"`
	Metadata *MakeToolMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	// This is the function definition of the tool.
	//
	// For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
	//
	// An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
	Function *OpenAiFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the server that will be hit when this tool is requested by the model.
	//
	// All requests will be sent with the call object among other things. You can find more details in the Server URL documentation.
	//
	// This overrides the serverUrl set on the org and the phoneNumber. Order of precedence: highest tool.server.url, then assistant.serverUrl, then phoneNumber.serverUrl, then org.serverUrl.
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MakeToolWithToolCall) GetAsync() *bool {
	if m == nil {
		return nil
	}
	return m.Async
}

func (m *MakeToolWithToolCall) GetMessages() []*MakeToolWithToolCallMessagesItem {
	if m == nil {
		return nil
	}
	return m.Messages
}

func (m *MakeToolWithToolCall) GetToolCall() *ToolCall {
	if m == nil {
		return nil
	}
	return m.ToolCall
}

func (m *MakeToolWithToolCall) GetMetadata() *MakeToolMetadata {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *MakeToolWithToolCall) GetFunction() *OpenAiFunction {
	if m == nil {
		return nil
	}
	return m.Function
}

func (m *MakeToolWithToolCall) GetServer() *Server {
	if m == nil {
		return nil
	}
	return m.Server
}

func (m *MakeToolWithToolCall) Type() string {
	return m.type_
}

func (m *MakeToolWithToolCall) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MakeToolWithToolCall) UnmarshalJSON(data []byte) error {
	type embed MakeToolWithToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MakeToolWithToolCall(unmarshaler.embed)
	if unmarshaler.Type != "make" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "make", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MakeToolWithToolCall) MarshalJSON() ([]byte, error) {
	type embed MakeToolWithToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "make",
	}
	return json.Marshal(marshaler)
}

func (m *MakeToolWithToolCall) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MakeToolWithToolCallMessagesItem struct {
	ToolMessageStart    *ToolMessageStart
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed
	ToolMessageDelayed  *ToolMessageDelayed

	typ string
}

func (m *MakeToolWithToolCallMessagesItem) GetToolMessageStart() *ToolMessageStart {
	if m == nil {
		return nil
	}
	return m.ToolMessageStart
}

func (m *MakeToolWithToolCallMessagesItem) GetToolMessageComplete() *ToolMessageComplete {
	if m == nil {
		return nil
	}
	return m.ToolMessageComplete
}

func (m *MakeToolWithToolCallMessagesItem) GetToolMessageFailed() *ToolMessageFailed {
	if m == nil {
		return nil
	}
	return m.ToolMessageFailed
}

func (m *MakeToolWithToolCallMessagesItem) GetToolMessageDelayed() *ToolMessageDelayed {
	if m == nil {
		return nil
	}
	return m.ToolMessageDelayed
}

func (m *MakeToolWithToolCallMessagesItem) UnmarshalJSON(data []byte) error {
	valueToolMessageStart := new(ToolMessageStart)
	if err := json.Unmarshal(data, &valueToolMessageStart); err == nil {
		m.typ = "ToolMessageStart"
		m.ToolMessageStart = valueToolMessageStart
		return nil
	}
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		m.typ = "ToolMessageComplete"
		m.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		m.typ = "ToolMessageFailed"
		m.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	valueToolMessageDelayed := new(ToolMessageDelayed)
	if err := json.Unmarshal(data, &valueToolMessageDelayed); err == nil {
		m.typ = "ToolMessageDelayed"
		m.ToolMessageDelayed = valueToolMessageDelayed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MakeToolWithToolCallMessagesItem) MarshalJSON() ([]byte, error) {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return json.Marshal(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return json.Marshal(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return json.Marshal(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return json.Marshal(m.ToolMessageDelayed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MakeToolWithToolCallMessagesItemVisitor interface {
	VisitToolMessageStart(*ToolMessageStart) error
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
	VisitToolMessageDelayed(*ToolMessageDelayed) error
}

func (m *MakeToolWithToolCallMessagesItem) Accept(visitor MakeToolWithToolCallMessagesItemVisitor) error {
	if m.typ == "ToolMessageStart" || m.ToolMessageStart != nil {
		return visitor.VisitToolMessageStart(m.ToolMessageStart)
	}
	if m.typ == "ToolMessageComplete" || m.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(m.ToolMessageComplete)
	}
	if m.typ == "ToolMessageFailed" || m.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(m.ToolMessageFailed)
	}
	if m.typ == "ToolMessageDelayed" || m.ToolMessageDelayed != nil {
		return visitor.VisitToolMessageDelayed(m.ToolMessageDelayed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", m)
}

type MessagePlan struct {
	// This are the messages that the assistant will speak when the user hasn't responded for `idleTimeoutSeconds`. Each time the timeout is triggered, a random message will be chosen from this array.
	//
	// Usage:
	// - If user gets distracted and doesn't respond for a while, this can be used to grab their attention.
	// - If the transcriber doesn't pick up what the user said, this can be used to ask the user to repeat themselves. (From the perspective of the assistant, the conversation is idle since it didn't "hear" any user messages.)
	//
	// @default null (no idle message is spoken)
	IdleMessages []string `json:"idleMessages,omitempty" url:"idleMessages,omitempty"`
	// This determines the maximum number of times `idleMessages` can be spoken during the call.
	//
	// @default 3
	IdleMessageMaxSpokenCount *float64 `json:"idleMessageMaxSpokenCount,omitempty" url:"idleMessageMaxSpokenCount,omitempty"`
	// This is the timeout in seconds before a message from `idleMessages` is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks.
	//
	// @default 10
	IdleTimeoutSeconds *float64 `json:"idleTimeoutSeconds,omitempty" url:"idleTimeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MessagePlan) GetIdleMessages() []string {
	if m == nil {
		return nil
	}
	return m.IdleMessages
}

func (m *MessagePlan) GetIdleMessageMaxSpokenCount() *float64 {
	if m == nil {
		return nil
	}
	return m.IdleMessageMaxSpokenCount
}

func (m *MessagePlan) GetIdleTimeoutSeconds() *float64 {
	if m == nil {
		return nil
	}
	return m.IdleTimeoutSeconds
}

func (m *MessagePlan) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MessagePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler MessagePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessagePlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessagePlan) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Metrics struct {
	OrgId                            string                 `json:"orgId" url:"orgId"`
	RangeStart                       string                 `json:"rangeStart" url:"rangeStart"`
	RangeEnd                         string                 `json:"rangeEnd" url:"rangeEnd"`
	Bill                             float64                `json:"bill" url:"bill"`
	BillWithinBillingLimit           bool                   `json:"billWithinBillingLimit" url:"billWithinBillingLimit"`
	BillDailyBreakdown               map[string]interface{} `json:"billDailyBreakdown,omitempty" url:"billDailyBreakdown,omitempty"`
	CallActive                       float64                `json:"callActive" url:"callActive"`
	CallActiveWithinConcurrencyLimit bool                   `json:"callActiveWithinConcurrencyLimit" url:"callActiveWithinConcurrencyLimit"`
	CallMinutes                      float64                `json:"callMinutes" url:"callMinutes"`
	CallMinutesDailyBreakdown        map[string]interface{} `json:"callMinutesDailyBreakdown,omitempty" url:"callMinutesDailyBreakdown,omitempty"`
	CallMinutesAverage               float64                `json:"callMinutesAverage" url:"callMinutesAverage"`
	CallMinutesAverageDailyBreakdown map[string]interface{} `json:"callMinutesAverageDailyBreakdown,omitempty" url:"callMinutesAverageDailyBreakdown,omitempty"`
	CallCount                        float64                `json:"callCount" url:"callCount"`
	CallCountDailyBreakdown          map[string]interface{} `json:"callCountDailyBreakdown,omitempty" url:"callCountDailyBreakdown,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Metrics) GetOrgId() string {
	if m == nil {
		return ""
	}
	return m.OrgId
}

func (m *Metrics) GetRangeStart() string {
	if m == nil {
		return ""
	}
	return m.RangeStart
}

func (m *Metrics) GetRangeEnd() string {
	if m == nil {
		return ""
	}
	return m.RangeEnd
}

func (m *Metrics) GetBill() float64 {
	if m == nil {
		return 0
	}
	return m.Bill
}

func (m *Metrics) GetBillWithinBillingLimit() bool {
	if m == nil {
		return false
	}
	return m.BillWithinBillingLimit
}

func (m *Metrics) GetBillDailyBreakdown() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.BillDailyBreakdown
}

func (m *Metrics) GetCallActive() float64 {
	if m == nil {
		return 0
	}
	return m.CallActive
}

func (m *Metrics) GetCallActiveWithinConcurrencyLimit() bool {
	if m == nil {
		return false
	}
	return m.CallActiveWithinConcurrencyLimit
}

func (m *Metrics) GetCallMinutes() float64 {
	if m == nil {
		return 0
	}
	return m.CallMinutes
}

func (m *Metrics) GetCallMinutesDailyBreakdown() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.CallMinutesDailyBreakdown
}

func (m *Metrics) GetCallMinutesAverage() float64 {
	if m == nil {
		return 0
	}
	return m.CallMinutesAverage
}

func (m *Metrics) GetCallMinutesAverageDailyBreakdown() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.CallMinutesAverageDailyBreakdown
}

func (m *Metrics) GetCallCount() float64 {
	if m == nil {
		return 0
	}
	return m.CallCount
}

func (m *Metrics) GetCallCountDailyBreakdown() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.CallCountDailyBreakdown
}

func (m *Metrics) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metrics) UnmarshalJSON(data []byte) error {
	type unmarshaler Metrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metrics(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metrics) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelBasedCondition struct {
	// This condition is based on a model.
	// This is the instruction which should output a boolean value when passed to a model.
	//
	// You can reference any variable in the context of the current block execution (step):
	// - "{{output.your-property-name}}" for current step's output
	// - "{{input.your-property-name}}" for current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// You can also talk about the current step's output or input directly:
	// - "{{output.your-property-name}} is greater than 10"
	// - "{{input.your-property-name}} is greater than 10"
	//
	// Examples:
	//   - "{{input.age}} is greater than 10"
	//   - "{{input.age}} is greater than {{input.age2}}"
	//   - "{{output.age}} is greater than 10"
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	Instruction string `json:"instruction" url:"instruction"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelBasedCondition) GetInstruction() string {
	if m == nil {
		return ""
	}
	return m.Instruction
}

func (m *ModelBasedCondition) Type() string {
	return m.type_
}

func (m *ModelBasedCondition) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelBasedCondition) UnmarshalJSON(data []byte) error {
	type embed ModelBasedCondition
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = ModelBasedCondition(unmarshaler.embed)
	if unmarshaler.Type != "model-based" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", m, "model-based", unmarshaler.Type)
	}
	m.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *m, "type")
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelBasedCondition) MarshalJSON() ([]byte, error) {
	type embed ModelBasedCondition
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "model-based",
	}
	return json.Marshal(marshaler)
}

func (m *ModelBasedCondition) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MonitorPlan struct {
	// This determines whether the assistant's calls allow live listening. Defaults to true.
	//
	// Fetch `call.monitor.listenUrl` to get the live listening URL.
	//
	// @default true
	ListenEnabled *bool `json:"listenEnabled,omitempty" url:"listenEnabled,omitempty"`
	// This determines whether the assistant's calls allow live control. Defaults to true.
	//
	// Fetch `call.monitor.controlUrl` to get the live control URL.
	//
	// To use, send any control message via a POST request to `call.monitor.controlUrl`. Here are the types of controls supported: https://docs.vapi.ai/api-reference/messages/client-inbound-message
	//
	// @default true
	ControlEnabled *bool `json:"controlEnabled,omitempty" url:"controlEnabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MonitorPlan) GetListenEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.ListenEnabled
}

func (m *MonitorPlan) GetControlEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.ControlEnabled
}

func (m *MonitorPlan) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MonitorPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler MonitorPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MonitorPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MonitorPlan) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NeetsVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *NeetsVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NeetsVoice) GetVoiceId() *NeetsVoiceId {
	if n == nil {
		return nil
	}
	return n.VoiceId
}

func (n *NeetsVoice) GetChunkPlan() *ChunkPlan {
	if n == nil {
		return nil
	}
	return n.ChunkPlan
}

func (n *NeetsVoice) GetFallbackPlan() *FallbackPlan {
	if n == nil {
		return nil
	}
	return n.FallbackPlan
}

func (n *NeetsVoice) Provider() string {
	return n.provider
}

func (n *NeetsVoice) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NeetsVoice) UnmarshalJSON(data []byte) error {
	type embed NeetsVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NeetsVoice(unmarshaler.embed)
	if unmarshaler.Provider != "neets" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "neets", unmarshaler.Provider)
	}
	n.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *n, "provider")
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NeetsVoice) MarshalJSON() ([]byte, error) {
	type embed NeetsVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*n),
		Provider: "neets",
	}
	return json.Marshal(marshaler)
}

func (n *NeetsVoice) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// This is the provider-specific ID that will be used.
type NeetsVoiceId struct {
	NeetsVoiceIdEnum NeetsVoiceIdEnum
	String           string

	typ string
}

func (n *NeetsVoiceId) GetNeetsVoiceIdEnum() NeetsVoiceIdEnum {
	if n == nil {
		return ""
	}
	return n.NeetsVoiceIdEnum
}

func (n *NeetsVoiceId) GetString() string {
	if n == nil {
		return ""
	}
	return n.String
}

func (n *NeetsVoiceId) UnmarshalJSON(data []byte) error {
	var valueNeetsVoiceIdEnum NeetsVoiceIdEnum
	if err := json.Unmarshal(data, &valueNeetsVoiceIdEnum); err == nil {
		n.typ = "NeetsVoiceIdEnum"
		n.NeetsVoiceIdEnum = valueNeetsVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		n.typ = "String"
		n.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NeetsVoiceId) MarshalJSON() ([]byte, error) {
	if n.typ == "NeetsVoiceIdEnum" || n.NeetsVoiceIdEnum != "" {
		return json.Marshal(n.NeetsVoiceIdEnum)
	}
	if n.typ == "String" || n.String != "" {
		return json.Marshal(n.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", n)
}

type NeetsVoiceIdVisitor interface {
	VisitNeetsVoiceIdEnum(NeetsVoiceIdEnum) error
	VisitString(string) error
}

func (n *NeetsVoiceId) Accept(visitor NeetsVoiceIdVisitor) error {
	if n.typ == "NeetsVoiceIdEnum" || n.NeetsVoiceIdEnum != "" {
		return visitor.VisitNeetsVoiceIdEnum(n.NeetsVoiceIdEnum)
	}
	if n.typ == "String" || n.String != "" {
		return visitor.VisitString(n.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", n)
}

type NeetsVoiceIdEnum string

const (
	NeetsVoiceIdEnumVits NeetsVoiceIdEnum = "vits"
)

func NewNeetsVoiceIdEnumFromString(s string) (NeetsVoiceIdEnum, error) {
	switch s {
	case "vits":
		return NeetsVoiceIdEnumVits, nil
	}
	var t NeetsVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NeetsVoiceIdEnum) Ptr() *NeetsVoiceIdEnum {
	return &n
}

type OAuth2AuthenticationPlan struct {
	// This is the OAuth2 URL.
	Url string `json:"url" url:"url"`
	// This is the OAuth2 client ID.
	ClientId string `json:"clientId" url:"clientId"`
	// This is the OAuth2 client secret.
	ClientSecret string `json:"clientSecret" url:"clientSecret"`
	type_        string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OAuth2AuthenticationPlan) GetUrl() string {
	if o == nil {
		return ""
	}
	return o.Url
}

func (o *OAuth2AuthenticationPlan) GetClientId() string {
	if o == nil {
		return ""
	}
	return o.ClientId
}

func (o *OAuth2AuthenticationPlan) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *OAuth2AuthenticationPlan) Type() string {
	return o.type_
}

func (o *OAuth2AuthenticationPlan) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuth2AuthenticationPlan) UnmarshalJSON(data []byte) error {
	type embed OAuth2AuthenticationPlan
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OAuth2AuthenticationPlan(unmarshaler.embed)
	if unmarshaler.Type != "oauth2" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "oauth2", unmarshaler.Type)
	}
	o.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "type")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuth2AuthenticationPlan) MarshalJSON() ([]byte, error) {
	type embed OAuth2AuthenticationPlan
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
		Type:  "oauth2",
	}
	return json.Marshal(marshaler)
}

func (o *OAuth2AuthenticationPlan) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type Oauth2AuthenticationSession struct {
	// This is the OAuth2 access token.
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`
	// This is the OAuth2 access token expiration.
	ExpiresAt *time.Time `json:"expiresAt,omitempty" url:"expiresAt,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Oauth2AuthenticationSession) GetAccessToken() *string {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *Oauth2AuthenticationSession) GetExpiresAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

func (o *Oauth2AuthenticationSession) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Oauth2AuthenticationSession) UnmarshalJSON(data []byte) error {
	type embed Oauth2AuthenticationSession
	var unmarshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Oauth2AuthenticationSession(unmarshaler.embed)
	o.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Oauth2AuthenticationSession) MarshalJSON() ([]byte, error) {
	type embed Oauth2AuthenticationSession
	var marshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt,omitempty"`
	}{
		embed:     embed(*o),
		ExpiresAt: internal.NewOptionalDateTime(o.ExpiresAt),
	}
	return json.Marshal(marshaler)
}

func (o *Oauth2AuthenticationSession) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// This is the provider-specific ID that will be used.
// Please note that ash, ballad, coral, sage, and verse may only be used with realtime models.
type OpenAiVoiceId string

const (
	OpenAiVoiceIdAlloy   OpenAiVoiceId = "alloy"
	OpenAiVoiceIdEcho    OpenAiVoiceId = "echo"
	OpenAiVoiceIdFable   OpenAiVoiceId = "fable"
	OpenAiVoiceIdOnyx    OpenAiVoiceId = "onyx"
	OpenAiVoiceIdNova    OpenAiVoiceId = "nova"
	OpenAiVoiceIdShimmer OpenAiVoiceId = "shimmer"
	OpenAiVoiceIdAsh     OpenAiVoiceId = "ash"
	OpenAiVoiceIdBallad  OpenAiVoiceId = "ballad"
	OpenAiVoiceIdCoral   OpenAiVoiceId = "coral"
	OpenAiVoiceIdSage    OpenAiVoiceId = "sage"
	OpenAiVoiceIdVerse   OpenAiVoiceId = "verse"
)

func NewOpenAiVoiceIdFromString(s string) (OpenAiVoiceId, error) {
	switch s {
	case "alloy":
		return OpenAiVoiceIdAlloy, nil
	case "echo":
		return OpenAiVoiceIdEcho, nil
	case "fable":
		return OpenAiVoiceIdFable, nil
	case "onyx":
		return OpenAiVoiceIdOnyx, nil
	case "nova":
		return OpenAiVoiceIdNova, nil
	case "shimmer":
		return OpenAiVoiceIdShimmer, nil
	case "ash":
		return OpenAiVoiceIdAsh, nil
	case "ballad":
		return OpenAiVoiceIdBallad, nil
	case "coral":
		return OpenAiVoiceIdCoral, nil
	case "sage":
		return OpenAiVoiceIdSage, nil
	case "verse":
		return OpenAiVoiceIdVerse, nil
	}
	var t OpenAiVoiceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiVoiceId) Ptr() *OpenAiVoiceId {
	return &o
}

type OpenAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiCredential) GetApiKey() string {
	if o == nil {
		return ""
	}
	return o.ApiKey
}

func (o *OpenAiCredential) GetId() string {
	if o == nil {
		return ""
	}
	return o.Id
}

func (o *OpenAiCredential) GetOrgId() string {
	if o == nil {
		return ""
	}
	return o.OrgId
}

func (o *OpenAiCredential) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *OpenAiCredential) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *OpenAiCredential) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OpenAiCredential) Provider() string {
	return o.provider
}

func (o *OpenAiCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiCredential) UnmarshalJSON(data []byte) error {
	type embed OpenAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiCredential(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiCredential) MarshalJSON() ([]byte, error) {
	type embed OpenAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*o),
		CreatedAt: internal.NewDateTime(o.CreatedAt),
		UpdatedAt: internal.NewDateTime(o.UpdatedAt),
		Provider:  "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiCredential) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiFunction struct {
	// This is a boolean that controls whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the parameters field. Only a subset of JSON Schema is supported when strict is true. Learn more about Structured Outputs in the [OpenAI guide](https://openai.com/index/introducing-structured-outputs-in-the-api/).
	//
	// @default false
	Strict *bool `json:"strict,omitempty" url:"strict,omitempty"`
	// This is the the name of the function to be called.
	//
	// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name" url:"name"`
	// This is the description of what the function does, used by the AI to choose when and how to call the function.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// These are the parameters the functions accepts, described as a JSON Schema object.
	//
	// See the [OpenAI guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema) for documentation about the format.
	//
	// Omitting parameters defines a function with an empty parameter list.
	Parameters *OpenAiFunctionParameters `json:"parameters,omitempty" url:"parameters,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiFunction) GetStrict() *bool {
	if o == nil {
		return nil
	}
	return o.Strict
}

func (o *OpenAiFunction) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *OpenAiFunction) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OpenAiFunction) GetParameters() *OpenAiFunctionParameters {
	if o == nil {
		return nil
	}
	return o.Parameters
}

func (o *OpenAiFunction) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiFunction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiFunction) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiFunctionParameters struct {
	// This must be set to 'object'. It instructs the model to return a JSON object containing the function call properties.
	// This provides a description of the properties required by the function.
	// JSON Schema can be used to specify expectations for each property.
	// Refer to [this doc](https://ajv.js.org/json-schema.html#json-data-type) for a comprehensive guide on JSON Schema.
	Properties map[string]*JsonSchema `json:"properties,omitempty" url:"properties,omitempty"`
	// This specifies the properties that are required by the function.
	Required []string `json:"required,omitempty" url:"required,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiFunctionParameters) GetProperties() map[string]*JsonSchema {
	if o == nil {
		return nil
	}
	return o.Properties
}

func (o *OpenAiFunctionParameters) GetRequired() []string {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *OpenAiFunctionParameters) Type() string {
	return o.type_
}

func (o *OpenAiFunctionParameters) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiFunctionParameters) UnmarshalJSON(data []byte) error {
	type embed OpenAiFunctionParameters
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiFunctionParameters(unmarshaler.embed)
	if unmarshaler.Type != "object" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "object", unmarshaler.Type)
	}
	o.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "type")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiFunctionParameters) MarshalJSON() ([]byte, error) {
	type embed OpenAiFunctionParameters
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
		Type:  "object",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiFunctionParameters) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiMessage struct {
	Content *string           `json:"content,omitempty" url:"content,omitempty"`
	Role    OpenAiMessageRole `json:"role" url:"role"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiMessage) GetContent() *string {
	if o == nil {
		return nil
	}
	return o.Content
}

func (o *OpenAiMessage) GetRole() OpenAiMessageRole {
	if o == nil {
		return ""
	}
	return o.Role
}

func (o *OpenAiMessage) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiMessage) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiMessageRole string

const (
	OpenAiMessageRoleAssistant OpenAiMessageRole = "assistant"
	OpenAiMessageRoleFunction  OpenAiMessageRole = "function"
	OpenAiMessageRoleUser      OpenAiMessageRole = "user"
	OpenAiMessageRoleSystem    OpenAiMessageRole = "system"
	OpenAiMessageRoleTool      OpenAiMessageRole = "tool"
)

func NewOpenAiMessageRoleFromString(s string) (OpenAiMessageRole, error) {
	switch s {
	case "assistant":
		return OpenAiMessageRoleAssistant, nil
	case "function":
		return OpenAiMessageRoleFunction, nil
	case "user":
		return OpenAiMessageRoleUser, nil
	case "system":
		return OpenAiMessageRoleSystem, nil
	case "tool":
		return OpenAiMessageRoleTool, nil
	}
	var t OpenAiMessageRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiMessageRole) Ptr() *OpenAiMessageRole {
	return &o
}

type OpenAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*OpenAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the provider that will be used for the model.
	// This is the OpenAI model that will be used.
	Model OpenAiModelModel `json:"model" url:"model"`
	// These are the fallback models that will be used if the primary model fails. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest fallbacks that make sense.
	FallbackModels         []OpenAiModelFallbackModelsItem `json:"fallbackModels,omitempty" url:"fallbackModels,omitempty"`
	SemanticCachingEnabled *bool                           `json:"semanticCachingEnabled,omitempty" url:"semanticCachingEnabled,omitempty"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiModel) GetMessages() []*OpenAiMessage {
	if o == nil {
		return nil
	}
	return o.Messages
}

func (o *OpenAiModel) GetTools() []*OpenAiModelToolsItem {
	if o == nil {
		return nil
	}
	return o.Tools
}

func (o *OpenAiModel) GetToolIds() []string {
	if o == nil {
		return nil
	}
	return o.ToolIds
}

func (o *OpenAiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if o == nil {
		return nil
	}
	return o.KnowledgeBase
}

func (o *OpenAiModel) GetKnowledgeBaseId() *string {
	if o == nil {
		return nil
	}
	return o.KnowledgeBaseId
}

func (o *OpenAiModel) GetModel() OpenAiModelModel {
	if o == nil {
		return ""
	}
	return o.Model
}

func (o *OpenAiModel) GetFallbackModels() []OpenAiModelFallbackModelsItem {
	if o == nil {
		return nil
	}
	return o.FallbackModels
}

func (o *OpenAiModel) GetSemanticCachingEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.SemanticCachingEnabled
}

func (o *OpenAiModel) GetTemperature() *float64 {
	if o == nil {
		return nil
	}
	return o.Temperature
}

func (o *OpenAiModel) GetMaxTokens() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxTokens
}

func (o *OpenAiModel) GetEmotionRecognitionEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.EmotionRecognitionEnabled
}

func (o *OpenAiModel) GetNumFastTurns() *float64 {
	if o == nil {
		return nil
	}
	return o.NumFastTurns
}

func (o *OpenAiModel) Provider() string {
	return o.provider
}

func (o *OpenAiModel) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiModel) UnmarshalJSON(data []byte) error {
	type embed OpenAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiModel) MarshalJSON() ([]byte, error) {
	type embed OpenAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiModel) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenAiModelFallbackModelsItem string

const (
	OpenAiModelFallbackModelsItemO1Preview                        OpenAiModelFallbackModelsItem = "o1-preview"
	OpenAiModelFallbackModelsItemO1Preview20240912                OpenAiModelFallbackModelsItem = "o1-preview-2024-09-12"
	OpenAiModelFallbackModelsItemO1Mini                           OpenAiModelFallbackModelsItem = "o1-mini"
	OpenAiModelFallbackModelsItemO1Mini20240912                   OpenAiModelFallbackModelsItem = "o1-mini-2024-09-12"
	OpenAiModelFallbackModelsItemGpt4ORealtimePreview20241001     OpenAiModelFallbackModelsItem = "gpt-4o-realtime-preview-2024-10-01"
	OpenAiModelFallbackModelsItemGpt4ORealtimePreview20241217     OpenAiModelFallbackModelsItem = "gpt-4o-realtime-preview-2024-12-17"
	OpenAiModelFallbackModelsItemGpt4OMiniRealtimePreview20241217 OpenAiModelFallbackModelsItem = "gpt-4o-mini-realtime-preview-2024-12-17"
	OpenAiModelFallbackModelsItemGpt4OMini                        OpenAiModelFallbackModelsItem = "gpt-4o-mini"
	OpenAiModelFallbackModelsItemGpt4OMini20240718                OpenAiModelFallbackModelsItem = "gpt-4o-mini-2024-07-18"
	OpenAiModelFallbackModelsItemGpt4O                            OpenAiModelFallbackModelsItem = "gpt-4o"
	OpenAiModelFallbackModelsItemGpt4O20240513                    OpenAiModelFallbackModelsItem = "gpt-4o-2024-05-13"
	OpenAiModelFallbackModelsItemGpt4O20240806                    OpenAiModelFallbackModelsItem = "gpt-4o-2024-08-06"
	OpenAiModelFallbackModelsItemGpt4O20241120                    OpenAiModelFallbackModelsItem = "gpt-4o-2024-11-20"
	OpenAiModelFallbackModelsItemGpt4Turbo                        OpenAiModelFallbackModelsItem = "gpt-4-turbo"
	OpenAiModelFallbackModelsItemGpt4Turbo20240409                OpenAiModelFallbackModelsItem = "gpt-4-turbo-2024-04-09"
	OpenAiModelFallbackModelsItemGpt4TurboPreview                 OpenAiModelFallbackModelsItem = "gpt-4-turbo-preview"
	OpenAiModelFallbackModelsItemGpt40125Preview                  OpenAiModelFallbackModelsItem = "gpt-4-0125-preview"
	OpenAiModelFallbackModelsItemGpt41106Preview                  OpenAiModelFallbackModelsItem = "gpt-4-1106-preview"
	OpenAiModelFallbackModelsItemGpt4                             OpenAiModelFallbackModelsItem = "gpt-4"
	OpenAiModelFallbackModelsItemGpt40613                         OpenAiModelFallbackModelsItem = "gpt-4-0613"
	OpenAiModelFallbackModelsItemGpt35Turbo                       OpenAiModelFallbackModelsItem = "gpt-3.5-turbo"
	OpenAiModelFallbackModelsItemGpt35Turbo0125                   OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-0125"
	OpenAiModelFallbackModelsItemGpt35Turbo1106                   OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-1106"
	OpenAiModelFallbackModelsItemGpt35Turbo16K                    OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-16k"
	OpenAiModelFallbackModelsItemGpt35Turbo0613                   OpenAiModelFallbackModelsItem = "gpt-3.5-turbo-0613"
)

func NewOpenAiModelFallbackModelsItemFromString(s string) (OpenAiModelFallbackModelsItem, error) {
	switch s {
	case "o1-preview":
		return OpenAiModelFallbackModelsItemO1Preview, nil
	case "o1-preview-2024-09-12":
		return OpenAiModelFallbackModelsItemO1Preview20240912, nil
	case "o1-mini":
		return OpenAiModelFallbackModelsItemO1Mini, nil
	case "o1-mini-2024-09-12":
		return OpenAiModelFallbackModelsItemO1Mini20240912, nil
	case "gpt-4o-realtime-preview-2024-10-01":
		return OpenAiModelFallbackModelsItemGpt4ORealtimePreview20241001, nil
	case "gpt-4o-realtime-preview-2024-12-17":
		return OpenAiModelFallbackModelsItemGpt4ORealtimePreview20241217, nil
	case "gpt-4o-mini-realtime-preview-2024-12-17":
		return OpenAiModelFallbackModelsItemGpt4OMiniRealtimePreview20241217, nil
	case "gpt-4o-mini":
		return OpenAiModelFallbackModelsItemGpt4OMini, nil
	case "gpt-4o-mini-2024-07-18":
		return OpenAiModelFallbackModelsItemGpt4OMini20240718, nil
	case "gpt-4o":
		return OpenAiModelFallbackModelsItemGpt4O, nil
	case "gpt-4o-2024-05-13":
		return OpenAiModelFallbackModelsItemGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return OpenAiModelFallbackModelsItemGpt4O20240806, nil
	case "gpt-4o-2024-11-20":
		return OpenAiModelFallbackModelsItemGpt4O20241120, nil
	case "gpt-4-turbo":
		return OpenAiModelFallbackModelsItemGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return OpenAiModelFallbackModelsItemGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return OpenAiModelFallbackModelsItemGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return OpenAiModelFallbackModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return OpenAiModelFallbackModelsItemGpt41106Preview, nil
	case "gpt-4":
		return OpenAiModelFallbackModelsItemGpt4, nil
	case "gpt-4-0613":
		return OpenAiModelFallbackModelsItemGpt40613, nil
	case "gpt-3.5-turbo":
		return OpenAiModelFallbackModelsItemGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return OpenAiModelFallbackModelsItemGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return OpenAiModelFallbackModelsItemGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return OpenAiModelFallbackModelsItemGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return OpenAiModelFallbackModelsItemGpt35Turbo0613, nil
	}
	var t OpenAiModelFallbackModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiModelFallbackModelsItem) Ptr() *OpenAiModelFallbackModelsItem {
	return &o
}

// This is the OpenAI model that will be used.
type OpenAiModelModel string

const (
	OpenAiModelModelO1Preview                        OpenAiModelModel = "o1-preview"
	OpenAiModelModelO1Preview20240912                OpenAiModelModel = "o1-preview-2024-09-12"
	OpenAiModelModelO1Mini                           OpenAiModelModel = "o1-mini"
	OpenAiModelModelO1Mini20240912                   OpenAiModelModel = "o1-mini-2024-09-12"
	OpenAiModelModelGpt4ORealtimePreview20241001     OpenAiModelModel = "gpt-4o-realtime-preview-2024-10-01"
	OpenAiModelModelGpt4ORealtimePreview20241217     OpenAiModelModel = "gpt-4o-realtime-preview-2024-12-17"
	OpenAiModelModelGpt4OMiniRealtimePreview20241217 OpenAiModelModel = "gpt-4o-mini-realtime-preview-2024-12-17"
	OpenAiModelModelGpt4OMini                        OpenAiModelModel = "gpt-4o-mini"
	OpenAiModelModelGpt4OMini20240718                OpenAiModelModel = "gpt-4o-mini-2024-07-18"
	OpenAiModelModelGpt4O                            OpenAiModelModel = "gpt-4o"
	OpenAiModelModelGpt4O20240513                    OpenAiModelModel = "gpt-4o-2024-05-13"
	OpenAiModelModelGpt4O20240806                    OpenAiModelModel = "gpt-4o-2024-08-06"
	OpenAiModelModelGpt4O20241120                    OpenAiModelModel = "gpt-4o-2024-11-20"
	OpenAiModelModelGpt4Turbo                        OpenAiModelModel = "gpt-4-turbo"
	OpenAiModelModelGpt4Turbo20240409                OpenAiModelModel = "gpt-4-turbo-2024-04-09"
	OpenAiModelModelGpt4TurboPreview                 OpenAiModelModel = "gpt-4-turbo-preview"
	OpenAiModelModelGpt40125Preview                  OpenAiModelModel = "gpt-4-0125-preview"
	OpenAiModelModelGpt41106Preview                  OpenAiModelModel = "gpt-4-1106-preview"
	OpenAiModelModelGpt4                             OpenAiModelModel = "gpt-4"
	OpenAiModelModelGpt40613                         OpenAiModelModel = "gpt-4-0613"
	OpenAiModelModelGpt35Turbo                       OpenAiModelModel = "gpt-3.5-turbo"
	OpenAiModelModelGpt35Turbo0125                   OpenAiModelModel = "gpt-3.5-turbo-0125"
	OpenAiModelModelGpt35Turbo1106                   OpenAiModelModel = "gpt-3.5-turbo-1106"
	OpenAiModelModelGpt35Turbo16K                    OpenAiModelModel = "gpt-3.5-turbo-16k"
	OpenAiModelModelGpt35Turbo0613                   OpenAiModelModel = "gpt-3.5-turbo-0613"
)

func NewOpenAiModelModelFromString(s string) (OpenAiModelModel, error) {
	switch s {
	case "o1-preview":
		return OpenAiModelModelO1Preview, nil
	case "o1-preview-2024-09-12":
		return OpenAiModelModelO1Preview20240912, nil
	case "o1-mini":
		return OpenAiModelModelO1Mini, nil
	case "o1-mini-2024-09-12":
		return OpenAiModelModelO1Mini20240912, nil
	case "gpt-4o-realtime-preview-2024-10-01":
		return OpenAiModelModelGpt4ORealtimePreview20241001, nil
	case "gpt-4o-realtime-preview-2024-12-17":
		return OpenAiModelModelGpt4ORealtimePreview20241217, nil
	case "gpt-4o-mini-realtime-preview-2024-12-17":
		return OpenAiModelModelGpt4OMiniRealtimePreview20241217, nil
	case "gpt-4o-mini":
		return OpenAiModelModelGpt4OMini, nil
	case "gpt-4o-mini-2024-07-18":
		return OpenAiModelModelGpt4OMini20240718, nil
	case "gpt-4o":
		return OpenAiModelModelGpt4O, nil
	case "gpt-4o-2024-05-13":
		return OpenAiModelModelGpt4O20240513, nil
	case "gpt-4o-2024-08-06":
		return OpenAiModelModelGpt4O20240806, nil
	case "gpt-4o-2024-11-20":
		return OpenAiModelModelGpt4O20241120, nil
	case "gpt-4-turbo":
		return OpenAiModelModelGpt4Turbo, nil
	case "gpt-4-turbo-2024-04-09":
		return OpenAiModelModelGpt4Turbo20240409, nil
	case "gpt-4-turbo-preview":
		return OpenAiModelModelGpt4TurboPreview, nil
	case "gpt-4-0125-preview":
		return OpenAiModelModelGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return OpenAiModelModelGpt41106Preview, nil
	case "gpt-4":
		return OpenAiModelModelGpt4, nil
	case "gpt-4-0613":
		return OpenAiModelModelGpt40613, nil
	case "gpt-3.5-turbo":
		return OpenAiModelModelGpt35Turbo, nil
	case "gpt-3.5-turbo-0125":
		return OpenAiModelModelGpt35Turbo0125, nil
	case "gpt-3.5-turbo-1106":
		return OpenAiModelModelGpt35Turbo1106, nil
	case "gpt-3.5-turbo-16k":
		return OpenAiModelModelGpt35Turbo16K, nil
	case "gpt-3.5-turbo-0613":
		return OpenAiModelModelGpt35Turbo0613, nil
	}
	var t OpenAiModelModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenAiModelModel) Ptr() *OpenAiModelModel {
	return &o
}

type OpenAiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (o *OpenAiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if o == nil {
		return nil
	}
	return o.CreateDtmfToolDto
}

func (o *OpenAiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if o == nil {
		return nil
	}
	return o.CreateEndCallToolDto
}

func (o *OpenAiModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if o == nil {
		return nil
	}
	return o.CreateVoicemailToolDto
}

func (o *OpenAiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if o == nil {
		return nil
	}
	return o.CreateFunctionToolDto
}

func (o *OpenAiModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGhlToolDto
}

func (o *OpenAiModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if o == nil {
		return nil
	}
	return o.CreateMakeToolDto
}

func (o *OpenAiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if o == nil {
		return nil
	}
	return o.CreateTransferCallToolDto
}

func (o *OpenAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		o.typ = "CreateDtmfToolDto"
		o.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		o.typ = "CreateEndCallToolDto"
		o.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		o.typ = "CreateVoicemailToolDto"
		o.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		o.typ = "CreateFunctionToolDto"
		o.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		o.typ = "CreateGhlToolDto"
		o.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		o.typ = "CreateMakeToolDto"
		o.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		o.typ = "CreateTransferCallToolDto"
		o.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if o.typ == "CreateDtmfToolDto" || o.CreateDtmfToolDto != nil {
		return json.Marshal(o.CreateDtmfToolDto)
	}
	if o.typ == "CreateEndCallToolDto" || o.CreateEndCallToolDto != nil {
		return json.Marshal(o.CreateEndCallToolDto)
	}
	if o.typ == "CreateVoicemailToolDto" || o.CreateVoicemailToolDto != nil {
		return json.Marshal(o.CreateVoicemailToolDto)
	}
	if o.typ == "CreateFunctionToolDto" || o.CreateFunctionToolDto != nil {
		return json.Marshal(o.CreateFunctionToolDto)
	}
	if o.typ == "CreateGhlToolDto" || o.CreateGhlToolDto != nil {
		return json.Marshal(o.CreateGhlToolDto)
	}
	if o.typ == "CreateMakeToolDto" || o.CreateMakeToolDto != nil {
		return json.Marshal(o.CreateMakeToolDto)
	}
	if o.typ == "CreateTransferCallToolDto" || o.CreateTransferCallToolDto != nil {
		return json.Marshal(o.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (o *OpenAiModelToolsItem) Accept(visitor OpenAiModelToolsItemVisitor) error {
	if o.typ == "CreateDtmfToolDto" || o.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(o.CreateDtmfToolDto)
	}
	if o.typ == "CreateEndCallToolDto" || o.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(o.CreateEndCallToolDto)
	}
	if o.typ == "CreateVoicemailToolDto" || o.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(o.CreateVoicemailToolDto)
	}
	if o.typ == "CreateFunctionToolDto" || o.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(o.CreateFunctionToolDto)
	}
	if o.typ == "CreateGhlToolDto" || o.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(o.CreateGhlToolDto)
	}
	if o.typ == "CreateMakeToolDto" || o.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(o.CreateMakeToolDto)
	}
	if o.typ == "CreateTransferCallToolDto" || o.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(o.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenAiVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	// Please note that ash, ballad, coral, sage, and verse may only be used with realtime models.
	VoiceId OpenAiVoiceId `json:"voiceId" url:"voiceId"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenAiVoice) GetVoiceId() OpenAiVoiceId {
	if o == nil {
		return ""
	}
	return o.VoiceId
}

func (o *OpenAiVoice) GetSpeed() *float64 {
	if o == nil {
		return nil
	}
	return o.Speed
}

func (o *OpenAiVoice) GetChunkPlan() *ChunkPlan {
	if o == nil {
		return nil
	}
	return o.ChunkPlan
}

func (o *OpenAiVoice) GetFallbackPlan() *FallbackPlan {
	if o == nil {
		return nil
	}
	return o.FallbackPlan
}

func (o *OpenAiVoice) Provider() string {
	return o.provider
}

func (o *OpenAiVoice) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiVoice) UnmarshalJSON(data []byte) error {
	type embed OpenAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "openai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openai", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiVoice) MarshalJSON() ([]byte, error) {
	type embed OpenAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openai",
	}
	return json.Marshal(marshaler)
}

func (o *OpenAiVoice) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenRouterCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenRouterCredential) GetApiKey() string {
	if o == nil {
		return ""
	}
	return o.ApiKey
}

func (o *OpenRouterCredential) GetId() string {
	if o == nil {
		return ""
	}
	return o.Id
}

func (o *OpenRouterCredential) GetOrgId() string {
	if o == nil {
		return ""
	}
	return o.OrgId
}

func (o *OpenRouterCredential) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *OpenRouterCredential) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *OpenRouterCredential) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OpenRouterCredential) Provider() string {
	return o.provider
}

func (o *OpenRouterCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenRouterCredential) UnmarshalJSON(data []byte) error {
	type embed OpenRouterCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenRouterCredential(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openrouter", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenRouterCredential) MarshalJSON() ([]byte, error) {
	type embed OpenRouterCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*o),
		CreatedAt: internal.NewDateTime(o.CreatedAt),
		UpdatedAt: internal.NewDateTime(o.UpdatedAt),
		Provider:  "openrouter",
	}
	return json.Marshal(marshaler)
}

func (o *OpenRouterCredential) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenRouterModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*OpenRouterModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OpenRouterModel) GetMessages() []*OpenAiMessage {
	if o == nil {
		return nil
	}
	return o.Messages
}

func (o *OpenRouterModel) GetTools() []*OpenRouterModelToolsItem {
	if o == nil {
		return nil
	}
	return o.Tools
}

func (o *OpenRouterModel) GetToolIds() []string {
	if o == nil {
		return nil
	}
	return o.ToolIds
}

func (o *OpenRouterModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if o == nil {
		return nil
	}
	return o.KnowledgeBase
}

func (o *OpenRouterModel) GetKnowledgeBaseId() *string {
	if o == nil {
		return nil
	}
	return o.KnowledgeBaseId
}

func (o *OpenRouterModel) GetModel() string {
	if o == nil {
		return ""
	}
	return o.Model
}

func (o *OpenRouterModel) GetTemperature() *float64 {
	if o == nil {
		return nil
	}
	return o.Temperature
}

func (o *OpenRouterModel) GetMaxTokens() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxTokens
}

func (o *OpenRouterModel) GetEmotionRecognitionEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.EmotionRecognitionEnabled
}

func (o *OpenRouterModel) GetNumFastTurns() *float64 {
	if o == nil {
		return nil
	}
	return o.NumFastTurns
}

func (o *OpenRouterModel) Provider() string {
	return o.provider
}

func (o *OpenRouterModel) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenRouterModel) UnmarshalJSON(data []byte) error {
	type embed OpenRouterModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OpenRouterModel(unmarshaler.embed)
	if unmarshaler.Provider != "openrouter" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", o, "openrouter", unmarshaler.Provider)
	}
	o.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *o, "provider")
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenRouterModel) MarshalJSON() ([]byte, error) {
	type embed OpenRouterModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*o),
		Provider: "openrouter",
	}
	return json.Marshal(marshaler)
}

func (o *OpenRouterModel) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenRouterModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (o *OpenRouterModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if o == nil {
		return nil
	}
	return o.CreateDtmfToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if o == nil {
		return nil
	}
	return o.CreateEndCallToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if o == nil {
		return nil
	}
	return o.CreateVoicemailToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if o == nil {
		return nil
	}
	return o.CreateFunctionToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if o == nil {
		return nil
	}
	return o.CreateGhlToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if o == nil {
		return nil
	}
	return o.CreateMakeToolDto
}

func (o *OpenRouterModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if o == nil {
		return nil
	}
	return o.CreateTransferCallToolDto
}

func (o *OpenRouterModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		o.typ = "CreateDtmfToolDto"
		o.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		o.typ = "CreateEndCallToolDto"
		o.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		o.typ = "CreateVoicemailToolDto"
		o.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		o.typ = "CreateFunctionToolDto"
		o.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		o.typ = "CreateGhlToolDto"
		o.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		o.typ = "CreateMakeToolDto"
		o.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		o.typ = "CreateTransferCallToolDto"
		o.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, o)
}

func (o OpenRouterModelToolsItem) MarshalJSON() ([]byte, error) {
	if o.typ == "CreateDtmfToolDto" || o.CreateDtmfToolDto != nil {
		return json.Marshal(o.CreateDtmfToolDto)
	}
	if o.typ == "CreateEndCallToolDto" || o.CreateEndCallToolDto != nil {
		return json.Marshal(o.CreateEndCallToolDto)
	}
	if o.typ == "CreateVoicemailToolDto" || o.CreateVoicemailToolDto != nil {
		return json.Marshal(o.CreateVoicemailToolDto)
	}
	if o.typ == "CreateFunctionToolDto" || o.CreateFunctionToolDto != nil {
		return json.Marshal(o.CreateFunctionToolDto)
	}
	if o.typ == "CreateGhlToolDto" || o.CreateGhlToolDto != nil {
		return json.Marshal(o.CreateGhlToolDto)
	}
	if o.typ == "CreateMakeToolDto" || o.CreateMakeToolDto != nil {
		return json.Marshal(o.CreateMakeToolDto)
	}
	if o.typ == "CreateTransferCallToolDto" || o.CreateTransferCallToolDto != nil {
		return json.Marshal(o.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", o)
}

type OpenRouterModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (o *OpenRouterModelToolsItem) Accept(visitor OpenRouterModelToolsItemVisitor) error {
	if o.typ == "CreateDtmfToolDto" || o.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(o.CreateDtmfToolDto)
	}
	if o.typ == "CreateEndCallToolDto" || o.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(o.CreateEndCallToolDto)
	}
	if o.typ == "CreateVoicemailToolDto" || o.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(o.CreateVoicemailToolDto)
	}
	if o.typ == "CreateFunctionToolDto" || o.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(o.CreateFunctionToolDto)
	}
	if o.typ == "CreateGhlToolDto" || o.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(o.CreateGhlToolDto)
	}
	if o.typ == "CreateMakeToolDto" || o.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(o.CreateMakeToolDto)
	}
	if o.typ == "CreateTransferCallToolDto" || o.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(o.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", o)
}

type Org struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool         `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// This is the ID of the subscription the org belongs to.
	SubscriptionId *string `json:"subscriptionId,omitempty" url:"subscriptionId,omitempty"`
	// This is the unique identifier for the org.
	Id string `json:"id" url:"id"`
	// This is the ISO 8601 date-time string of when the org was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the org was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the Stripe customer for the org.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty" url:"stripeCustomerId,omitempty"`
	// This is the subscription for the org.
	StripeSubscriptionId *string `json:"stripeSubscriptionId,omitempty" url:"stripeSubscriptionId,omitempty"`
	// This is the subscription's subscription item.
	StripeSubscriptionItemId *string `json:"stripeSubscriptionItemId,omitempty" url:"stripeSubscriptionItemId,omitempty"`
	// This is the subscription's current period start.
	StripeSubscriptionCurrentPeriodStart *time.Time `json:"stripeSubscriptionCurrentPeriodStart,omitempty" url:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	// This is the subscription's status.
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty" url:"stripeSubscriptionStatus,omitempty"`
	// This is the plan for the org.
	Plan *OrgPlan `json:"plan,omitempty" url:"plan,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
	Channel *OrgChannel `json:"channel,omitempty" url:"channel,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Org) GetHipaaEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.HipaaEnabled
}

func (o *Org) GetSubscription() *Subscription {
	if o == nil {
		return nil
	}
	return o.Subscription
}

func (o *Org) GetSubscriptionId() *string {
	if o == nil {
		return nil
	}
	return o.SubscriptionId
}

func (o *Org) GetId() string {
	if o == nil {
		return ""
	}
	return o.Id
}

func (o *Org) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *Org) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *Org) GetStripeCustomerId() *string {
	if o == nil {
		return nil
	}
	return o.StripeCustomerId
}

func (o *Org) GetStripeSubscriptionId() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionId
}

func (o *Org) GetStripeSubscriptionItemId() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionItemId
}

func (o *Org) GetStripeSubscriptionCurrentPeriodStart() *time.Time {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionCurrentPeriodStart
}

func (o *Org) GetStripeSubscriptionStatus() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionStatus
}

func (o *Org) GetPlan() *OrgPlan {
	if o == nil {
		return nil
	}
	return o.Plan
}

func (o *Org) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Org) GetChannel() *OrgChannel {
	if o == nil {
		return nil
	}
	return o.Channel
}

func (o *Org) GetBillingLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.BillingLimit
}

func (o *Org) GetServer() *Server {
	if o == nil {
		return nil
	}
	return o.Server
}

func (o *Org) GetConcurrencyLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.ConcurrencyLimit
}

func (o *Org) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Org) UnmarshalJSON(data []byte) error {
	type embed Org
	var unmarshaler = struct {
		embed
		CreatedAt                            *internal.DateTime `json:"createdAt"`
		UpdatedAt                            *internal.DateTime `json:"updatedAt"`
		StripeSubscriptionCurrentPeriodStart *internal.DateTime `json:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Org(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	o.StripeSubscriptionCurrentPeriodStart = unmarshaler.StripeSubscriptionCurrentPeriodStart.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Org) MarshalJSON() ([]byte, error) {
	type embed Org
	var marshaler = struct {
		embed
		CreatedAt                            *internal.DateTime `json:"createdAt"`
		UpdatedAt                            *internal.DateTime `json:"updatedAt"`
		StripeSubscriptionCurrentPeriodStart *internal.DateTime `json:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	}{
		embed:                                embed(*o),
		CreatedAt:                            internal.NewDateTime(o.CreatedAt),
		UpdatedAt:                            internal.NewDateTime(o.UpdatedAt),
		StripeSubscriptionCurrentPeriodStart: internal.NewOptionalDateTime(o.StripeSubscriptionCurrentPeriodStart),
	}
	return json.Marshal(marshaler)
}

func (o *Org) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
type OrgChannel string

const (
	OrgChannelDefault OrgChannel = "default"
	OrgChannelWeekly  OrgChannel = "weekly"
)

func NewOrgChannelFromString(s string) (OrgChannel, error) {
	switch s {
	case "default":
		return OrgChannelDefault, nil
	case "weekly":
		return OrgChannelWeekly, nil
	}
	var t OrgChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrgChannel) Ptr() *OrgChannel {
	return &o
}

type OrgPlan struct {
	IncludedProviders    []map[string]interface{} `json:"includedProviders,omitempty" url:"includedProviders,omitempty"`
	IncludedMinutes      *float64                 `json:"includedMinutes,omitempty" url:"includedMinutes,omitempty"`
	CostPerOverageMinute *float64                 `json:"costPerOverageMinute,omitempty" url:"costPerOverageMinute,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrgPlan) GetIncludedProviders() []map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.IncludedProviders
}

func (o *OrgPlan) GetIncludedMinutes() *float64 {
	if o == nil {
		return nil
	}
	return o.IncludedMinutes
}

func (o *OrgPlan) GetCostPerOverageMinute() *float64 {
	if o == nil {
		return nil
	}
	return o.CostPerOverageMinute
}

func (o *OrgPlan) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrgPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler OrgPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrgPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrgPlan) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrgWithOrgUser struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool         `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// This is the ID of the subscription the org belongs to.
	SubscriptionId *string `json:"subscriptionId,omitempty" url:"subscriptionId,omitempty"`
	// This is the unique identifier for the org.
	Id string `json:"id" url:"id"`
	// This is the ISO 8601 date-time string of when the org was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the org was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the Stripe customer for the org.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty" url:"stripeCustomerId,omitempty"`
	// This is the subscription for the org.
	StripeSubscriptionId *string `json:"stripeSubscriptionId,omitempty" url:"stripeSubscriptionId,omitempty"`
	// This is the subscription's subscription item.
	StripeSubscriptionItemId *string `json:"stripeSubscriptionItemId,omitempty" url:"stripeSubscriptionItemId,omitempty"`
	// This is the subscription's current period start.
	StripeSubscriptionCurrentPeriodStart *time.Time `json:"stripeSubscriptionCurrentPeriodStart,omitempty" url:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	// This is the subscription's status.
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty" url:"stripeSubscriptionStatus,omitempty"`
	// This is the plan for the org.
	Plan *OrgPlan `json:"plan,omitempty" url:"plan,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
	Channel *OrgWithOrgUserChannel `json:"channel,omitempty" url:"channel,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64            `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`
	InvitedByUserId  *string             `json:"invitedByUserId,omitempty" url:"invitedByUserId,omitempty"`
	Role             *OrgWithOrgUserRole `json:"role,omitempty" url:"role,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrgWithOrgUser) GetHipaaEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.HipaaEnabled
}

func (o *OrgWithOrgUser) GetSubscription() *Subscription {
	if o == nil {
		return nil
	}
	return o.Subscription
}

func (o *OrgWithOrgUser) GetSubscriptionId() *string {
	if o == nil {
		return nil
	}
	return o.SubscriptionId
}

func (o *OrgWithOrgUser) GetId() string {
	if o == nil {
		return ""
	}
	return o.Id
}

func (o *OrgWithOrgUser) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *OrgWithOrgUser) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *OrgWithOrgUser) GetStripeCustomerId() *string {
	if o == nil {
		return nil
	}
	return o.StripeCustomerId
}

func (o *OrgWithOrgUser) GetStripeSubscriptionId() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionId
}

func (o *OrgWithOrgUser) GetStripeSubscriptionItemId() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionItemId
}

func (o *OrgWithOrgUser) GetStripeSubscriptionCurrentPeriodStart() *time.Time {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionCurrentPeriodStart
}

func (o *OrgWithOrgUser) GetStripeSubscriptionStatus() *string {
	if o == nil {
		return nil
	}
	return o.StripeSubscriptionStatus
}

func (o *OrgWithOrgUser) GetPlan() *OrgPlan {
	if o == nil {
		return nil
	}
	return o.Plan
}

func (o *OrgWithOrgUser) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrgWithOrgUser) GetChannel() *OrgWithOrgUserChannel {
	if o == nil {
		return nil
	}
	return o.Channel
}

func (o *OrgWithOrgUser) GetBillingLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.BillingLimit
}

func (o *OrgWithOrgUser) GetServer() *Server {
	if o == nil {
		return nil
	}
	return o.Server
}

func (o *OrgWithOrgUser) GetConcurrencyLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.ConcurrencyLimit
}

func (o *OrgWithOrgUser) GetInvitedByUserId() *string {
	if o == nil {
		return nil
	}
	return o.InvitedByUserId
}

func (o *OrgWithOrgUser) GetRole() *OrgWithOrgUserRole {
	if o == nil {
		return nil
	}
	return o.Role
}

func (o *OrgWithOrgUser) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrgWithOrgUser) UnmarshalJSON(data []byte) error {
	type embed OrgWithOrgUser
	var unmarshaler = struct {
		embed
		CreatedAt                            *internal.DateTime `json:"createdAt"`
		UpdatedAt                            *internal.DateTime `json:"updatedAt"`
		StripeSubscriptionCurrentPeriodStart *internal.DateTime `json:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OrgWithOrgUser(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()
	o.StripeSubscriptionCurrentPeriodStart = unmarshaler.StripeSubscriptionCurrentPeriodStart.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrgWithOrgUser) MarshalJSON() ([]byte, error) {
	type embed OrgWithOrgUser
	var marshaler = struct {
		embed
		CreatedAt                            *internal.DateTime `json:"createdAt"`
		UpdatedAt                            *internal.DateTime `json:"updatedAt"`
		StripeSubscriptionCurrentPeriodStart *internal.DateTime `json:"stripeSubscriptionCurrentPeriodStart,omitempty"`
	}{
		embed:                                embed(*o),
		CreatedAt:                            internal.NewDateTime(o.CreatedAt),
		UpdatedAt:                            internal.NewDateTime(o.UpdatedAt),
		StripeSubscriptionCurrentPeriodStart: internal.NewOptionalDateTime(o.StripeSubscriptionCurrentPeriodStart),
	}
	return json.Marshal(marshaler)
}

func (o *OrgWithOrgUser) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
type OrgWithOrgUserChannel string

const (
	OrgWithOrgUserChannelDefault OrgWithOrgUserChannel = "default"
	OrgWithOrgUserChannelWeekly  OrgWithOrgUserChannel = "weekly"
)

func NewOrgWithOrgUserChannelFromString(s string) (OrgWithOrgUserChannel, error) {
	switch s {
	case "default":
		return OrgWithOrgUserChannelDefault, nil
	case "weekly":
		return OrgWithOrgUserChannelWeekly, nil
	}
	var t OrgWithOrgUserChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrgWithOrgUserChannel) Ptr() *OrgWithOrgUserChannel {
	return &o
}

type OrgWithOrgUserRole string

const (
	OrgWithOrgUserRoleAdmin  OrgWithOrgUserRole = "admin"
	OrgWithOrgUserRoleEditor OrgWithOrgUserRole = "editor"
	OrgWithOrgUserRoleViewer OrgWithOrgUserRole = "viewer"
)

func NewOrgWithOrgUserRoleFromString(s string) (OrgWithOrgUserRole, error) {
	switch s {
	case "admin":
		return OrgWithOrgUserRoleAdmin, nil
	case "editor":
		return OrgWithOrgUserRoleEditor, nil
	case "viewer":
		return OrgWithOrgUserRoleViewer, nil
	}
	var t OrgWithOrgUserRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrgWithOrgUserRole) Ptr() *OrgWithOrgUserRole {
	return &o
}

type PerplexityAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PerplexityAiCredential) GetApiKey() string {
	if p == nil {
		return ""
	}
	return p.ApiKey
}

func (p *PerplexityAiCredential) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PerplexityAiCredential) GetOrgId() string {
	if p == nil {
		return ""
	}
	return p.OrgId
}

func (p *PerplexityAiCredential) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PerplexityAiCredential) GetUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.UpdatedAt
}

func (p *PerplexityAiCredential) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PerplexityAiCredential) Provider() string {
	return p.provider
}

func (p *PerplexityAiCredential) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PerplexityAiCredential) UnmarshalJSON(data []byte) error {
	type embed PerplexityAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PerplexityAiCredential(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "perplexity-ai", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PerplexityAiCredential) MarshalJSON() ([]byte, error) {
	type embed PerplexityAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
		UpdatedAt: internal.NewDateTime(p.UpdatedAt),
		Provider:  "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (p *PerplexityAiCredential) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PerplexityAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*PerplexityAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PerplexityAiModel) GetMessages() []*OpenAiMessage {
	if p == nil {
		return nil
	}
	return p.Messages
}

func (p *PerplexityAiModel) GetTools() []*PerplexityAiModelToolsItem {
	if p == nil {
		return nil
	}
	return p.Tools
}

func (p *PerplexityAiModel) GetToolIds() []string {
	if p == nil {
		return nil
	}
	return p.ToolIds
}

func (p *PerplexityAiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if p == nil {
		return nil
	}
	return p.KnowledgeBase
}

func (p *PerplexityAiModel) GetKnowledgeBaseId() *string {
	if p == nil {
		return nil
	}
	return p.KnowledgeBaseId
}

func (p *PerplexityAiModel) GetModel() string {
	if p == nil {
		return ""
	}
	return p.Model
}

func (p *PerplexityAiModel) GetTemperature() *float64 {
	if p == nil {
		return nil
	}
	return p.Temperature
}

func (p *PerplexityAiModel) GetMaxTokens() *float64 {
	if p == nil {
		return nil
	}
	return p.MaxTokens
}

func (p *PerplexityAiModel) GetEmotionRecognitionEnabled() *bool {
	if p == nil {
		return nil
	}
	return p.EmotionRecognitionEnabled
}

func (p *PerplexityAiModel) GetNumFastTurns() *float64 {
	if p == nil {
		return nil
	}
	return p.NumFastTurns
}

func (p *PerplexityAiModel) Provider() string {
	return p.provider
}

func (p *PerplexityAiModel) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PerplexityAiModel) UnmarshalJSON(data []byte) error {
	type embed PerplexityAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PerplexityAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "perplexity-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "perplexity-ai", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PerplexityAiModel) MarshalJSON() ([]byte, error) {
	type embed PerplexityAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*p),
		Provider: "perplexity-ai",
	}
	return json.Marshal(marshaler)
}

func (p *PerplexityAiModel) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PerplexityAiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (p *PerplexityAiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if p == nil {
		return nil
	}
	return p.CreateDtmfToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if p == nil {
		return nil
	}
	return p.CreateEndCallToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if p == nil {
		return nil
	}
	return p.CreateVoicemailToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if p == nil {
		return nil
	}
	return p.CreateFunctionToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if p == nil {
		return nil
	}
	return p.CreateGhlToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if p == nil {
		return nil
	}
	return p.CreateMakeToolDto
}

func (p *PerplexityAiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if p == nil {
		return nil
	}
	return p.CreateTransferCallToolDto
}

func (p *PerplexityAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		p.typ = "CreateDtmfToolDto"
		p.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		p.typ = "CreateEndCallToolDto"
		p.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		p.typ = "CreateVoicemailToolDto"
		p.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		p.typ = "CreateFunctionToolDto"
		p.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		p.typ = "CreateGhlToolDto"
		p.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		p.typ = "CreateMakeToolDto"
		p.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		p.typ = "CreateTransferCallToolDto"
		p.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PerplexityAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if p.typ == "CreateDtmfToolDto" || p.CreateDtmfToolDto != nil {
		return json.Marshal(p.CreateDtmfToolDto)
	}
	if p.typ == "CreateEndCallToolDto" || p.CreateEndCallToolDto != nil {
		return json.Marshal(p.CreateEndCallToolDto)
	}
	if p.typ == "CreateVoicemailToolDto" || p.CreateVoicemailToolDto != nil {
		return json.Marshal(p.CreateVoicemailToolDto)
	}
	if p.typ == "CreateFunctionToolDto" || p.CreateFunctionToolDto != nil {
		return json.Marshal(p.CreateFunctionToolDto)
	}
	if p.typ == "CreateGhlToolDto" || p.CreateGhlToolDto != nil {
		return json.Marshal(p.CreateGhlToolDto)
	}
	if p.typ == "CreateMakeToolDto" || p.CreateMakeToolDto != nil {
		return json.Marshal(p.CreateMakeToolDto)
	}
	if p.typ == "CreateTransferCallToolDto" || p.CreateTransferCallToolDto != nil {
		return json.Marshal(p.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PerplexityAiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (p *PerplexityAiModelToolsItem) Accept(visitor PerplexityAiModelToolsItemVisitor) error {
	if p.typ == "CreateDtmfToolDto" || p.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(p.CreateDtmfToolDto)
	}
	if p.typ == "CreateEndCallToolDto" || p.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(p.CreateEndCallToolDto)
	}
	if p.typ == "CreateVoicemailToolDto" || p.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(p.CreateVoicemailToolDto)
	}
	if p.typ == "CreateFunctionToolDto" || p.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(p.CreateFunctionToolDto)
	}
	if p.typ == "CreateGhlToolDto" || p.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(p.CreateGhlToolDto)
	}
	if p.typ == "CreateMakeToolDto" || p.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(p.CreateMakeToolDto)
	}
	if p.typ == "CreateTransferCallToolDto" || p.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(p.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PhoneNumberPaginatedResponse struct {
	// A list of phone numbers, which can be of any provider type.
	Results []*PhoneNumberPaginatedResponseResultsItem `json:"results,omitempty" url:"results,omitempty"`
	// Metadata about the pagination.
	Metadata *PaginationMeta `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PhoneNumberPaginatedResponse) GetResults() []*PhoneNumberPaginatedResponseResultsItem {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *PhoneNumberPaginatedResponse) GetMetadata() *PaginationMeta {
	if p == nil {
		return nil
	}
	return p.Metadata
}

func (p *PhoneNumberPaginatedResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhoneNumberPaginatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PhoneNumberPaginatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhoneNumberPaginatedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhoneNumberPaginatedResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhoneNumberPaginatedResponseResultsItem struct {
	ByoPhoneNumber    *ByoPhoneNumber
	TwilioPhoneNumber *TwilioPhoneNumber
	VonagePhoneNumber *VonagePhoneNumber
	VapiPhoneNumber   *VapiPhoneNumber

	typ string
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetByoPhoneNumber() *ByoPhoneNumber {
	if p == nil {
		return nil
	}
	return p.ByoPhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetTwilioPhoneNumber() *TwilioPhoneNumber {
	if p == nil {
		return nil
	}
	return p.TwilioPhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetVonagePhoneNumber() *VonagePhoneNumber {
	if p == nil {
		return nil
	}
	return p.VonagePhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) GetVapiPhoneNumber() *VapiPhoneNumber {
	if p == nil {
		return nil
	}
	return p.VapiPhoneNumber
}

func (p *PhoneNumberPaginatedResponseResultsItem) UnmarshalJSON(data []byte) error {
	valueByoPhoneNumber := new(ByoPhoneNumber)
	if err := json.Unmarshal(data, &valueByoPhoneNumber); err == nil {
		p.typ = "ByoPhoneNumber"
		p.ByoPhoneNumber = valueByoPhoneNumber
		return nil
	}
	valueTwilioPhoneNumber := new(TwilioPhoneNumber)
	if err := json.Unmarshal(data, &valueTwilioPhoneNumber); err == nil {
		p.typ = "TwilioPhoneNumber"
		p.TwilioPhoneNumber = valueTwilioPhoneNumber
		return nil
	}
	valueVonagePhoneNumber := new(VonagePhoneNumber)
	if err := json.Unmarshal(data, &valueVonagePhoneNumber); err == nil {
		p.typ = "VonagePhoneNumber"
		p.VonagePhoneNumber = valueVonagePhoneNumber
		return nil
	}
	valueVapiPhoneNumber := new(VapiPhoneNumber)
	if err := json.Unmarshal(data, &valueVapiPhoneNumber); err == nil {
		p.typ = "VapiPhoneNumber"
		p.VapiPhoneNumber = valueVapiPhoneNumber
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PhoneNumberPaginatedResponseResultsItem) MarshalJSON() ([]byte, error) {
	if p.typ == "ByoPhoneNumber" || p.ByoPhoneNumber != nil {
		return json.Marshal(p.ByoPhoneNumber)
	}
	if p.typ == "TwilioPhoneNumber" || p.TwilioPhoneNumber != nil {
		return json.Marshal(p.TwilioPhoneNumber)
	}
	if p.typ == "VonagePhoneNumber" || p.VonagePhoneNumber != nil {
		return json.Marshal(p.VonagePhoneNumber)
	}
	if p.typ == "VapiPhoneNumber" || p.VapiPhoneNumber != nil {
		return json.Marshal(p.VapiPhoneNumber)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PhoneNumberPaginatedResponseResultsItemVisitor interface {
	VisitByoPhoneNumber(*ByoPhoneNumber) error
	VisitTwilioPhoneNumber(*TwilioPhoneNumber) error
	VisitVonagePhoneNumber(*VonagePhoneNumber) error
	VisitVapiPhoneNumber(*VapiPhoneNumber) error
}

func (p *PhoneNumberPaginatedResponseResultsItem) Accept(visitor PhoneNumberPaginatedResponseResultsItemVisitor) error {
	if p.typ == "ByoPhoneNumber" || p.ByoPhoneNumber != nil {
		return visitor.VisitByoPhoneNumber(p.ByoPhoneNumber)
	}
	if p.typ == "TwilioPhoneNumber" || p.TwilioPhoneNumber != nil {
		return visitor.VisitTwilioPhoneNumber(p.TwilioPhoneNumber)
	}
	if p.typ == "VonagePhoneNumber" || p.VonagePhoneNumber != nil {
		return visitor.VisitVonagePhoneNumber(p.VonagePhoneNumber)
	}
	if p.typ == "VapiPhoneNumber" || p.VapiPhoneNumber != nil {
		return visitor.VisitVapiPhoneNumber(p.VapiPhoneNumber)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// This is the provider-specific ID that will be used.
type PlayHtVoiceId struct {
	PlayHtVoiceIdEnum PlayHtVoiceIdEnum
	String            string

	typ string
}

func (p *PlayHtVoiceId) GetPlayHtVoiceIdEnum() PlayHtVoiceIdEnum {
	if p == nil {
		return ""
	}
	return p.PlayHtVoiceIdEnum
}

func (p *PlayHtVoiceId) GetString() string {
	if p == nil {
		return ""
	}
	return p.String
}

func (p *PlayHtVoiceId) UnmarshalJSON(data []byte) error {
	var valuePlayHtVoiceIdEnum PlayHtVoiceIdEnum
	if err := json.Unmarshal(data, &valuePlayHtVoiceIdEnum); err == nil {
		p.typ = "PlayHtVoiceIdEnum"
		p.PlayHtVoiceIdEnum = valuePlayHtVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		p.typ = "String"
		p.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PlayHtVoiceId) MarshalJSON() ([]byte, error) {
	if p.typ == "PlayHtVoiceIdEnum" || p.PlayHtVoiceIdEnum != "" {
		return json.Marshal(p.PlayHtVoiceIdEnum)
	}
	if p.typ == "String" || p.String != "" {
		return json.Marshal(p.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlayHtVoiceIdVisitor interface {
	VisitPlayHtVoiceIdEnum(PlayHtVoiceIdEnum) error
	VisitString(string) error
}

func (p *PlayHtVoiceId) Accept(visitor PlayHtVoiceIdVisitor) error {
	if p.typ == "PlayHtVoiceIdEnum" || p.PlayHtVoiceIdEnum != "" {
		return visitor.VisitPlayHtVoiceIdEnum(p.PlayHtVoiceIdEnum)
	}
	if p.typ == "String" || p.String != "" {
		return visitor.VisitString(p.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlayHtVoiceIdEnum string

const (
	PlayHtVoiceIdEnumJennifer PlayHtVoiceIdEnum = "jennifer"
	PlayHtVoiceIdEnumMelissa  PlayHtVoiceIdEnum = "melissa"
	PlayHtVoiceIdEnumWill     PlayHtVoiceIdEnum = "will"
	PlayHtVoiceIdEnumChris    PlayHtVoiceIdEnum = "chris"
	PlayHtVoiceIdEnumMatt     PlayHtVoiceIdEnum = "matt"
	PlayHtVoiceIdEnumJack     PlayHtVoiceIdEnum = "jack"
	PlayHtVoiceIdEnumRuby     PlayHtVoiceIdEnum = "ruby"
	PlayHtVoiceIdEnumDavis    PlayHtVoiceIdEnum = "davis"
	PlayHtVoiceIdEnumDonna    PlayHtVoiceIdEnum = "donna"
	PlayHtVoiceIdEnumMichael  PlayHtVoiceIdEnum = "michael"
)

func NewPlayHtVoiceIdEnumFromString(s string) (PlayHtVoiceIdEnum, error) {
	switch s {
	case "jennifer":
		return PlayHtVoiceIdEnumJennifer, nil
	case "melissa":
		return PlayHtVoiceIdEnumMelissa, nil
	case "will":
		return PlayHtVoiceIdEnumWill, nil
	case "chris":
		return PlayHtVoiceIdEnumChris, nil
	case "matt":
		return PlayHtVoiceIdEnumMatt, nil
	case "jack":
		return PlayHtVoiceIdEnumJack, nil
	case "ruby":
		return PlayHtVoiceIdEnumRuby, nil
	case "davis":
		return PlayHtVoiceIdEnumDavis, nil
	case "donna":
		return PlayHtVoiceIdEnumDonna, nil
	case "michael":
		return PlayHtVoiceIdEnumMichael, nil
	}
	var t PlayHtVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceIdEnum) Ptr() *PlayHtVoiceIdEnum {
	return &p
}

type PlayHtCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	UserId   string  `json:"userId" url:"userId"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlayHtCredential) GetApiKey() string {
	if p == nil {
		return ""
	}
	return p.ApiKey
}

func (p *PlayHtCredential) GetId() string {
	if p == nil {
		return ""
	}
	return p.Id
}

func (p *PlayHtCredential) GetOrgId() string {
	if p == nil {
		return ""
	}
	return p.OrgId
}

func (p *PlayHtCredential) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PlayHtCredential) GetUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.UpdatedAt
}

func (p *PlayHtCredential) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PlayHtCredential) GetUserId() string {
	if p == nil {
		return ""
	}
	return p.UserId
}

func (p *PlayHtCredential) Provider() string {
	return p.provider
}

func (p *PlayHtCredential) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlayHtCredential) UnmarshalJSON(data []byte) error {
	type embed PlayHtCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PlayHtCredential(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "playht", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlayHtCredential) MarshalJSON() ([]byte, error) {
	type embed PlayHtCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
		UpdatedAt: internal.NewDateTime(p.UpdatedAt),
		Provider:  "playht",
	}
	return json.Marshal(marshaler)
}

func (p *PlayHtCredential) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlayHtVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *PlayHtVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// A floating point number between 0, exclusive, and 2, inclusive. If equal to null or not provided, the model's default temperature will be used. The temperature parameter controls variance. Lower temperatures result in more predictable results, higher temperatures allow each run to vary more, so the voice may sound less like the baseline voice.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// An emotion to be applied to the speech.
	Emotion *PlayHtVoiceEmotion `json:"emotion,omitempty" url:"emotion,omitempty"`
	// A number between 1 and 6. Use lower numbers to reduce how unique your chosen voice will be compared to other voices.
	VoiceGuidance *float64 `json:"voiceGuidance,omitempty" url:"voiceGuidance,omitempty"`
	// A number between 1 and 30. Use lower numbers to to reduce how strong your chosen emotion will be. Higher numbers will create a very emotional performance.
	StyleGuidance *float64 `json:"styleGuidance,omitempty" url:"styleGuidance,omitempty"`
	// A number between 1 and 2. This number influences how closely the generated speech adheres to the input text. Use lower values to create more fluid speech, but with a higher chance of deviating from the input text. Higher numbers will make the generated speech more accurate to the input text, ensuring that the words spoken align closely with the provided text.
	TextGuidance *float64 `json:"textGuidance,omitempty" url:"textGuidance,omitempty"`
	// Playht voice model/engine to use.
	Model *PlayHtVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// The language to use for the speech.
	Language *PlayHtVoiceLanguage `json:"language,omitempty" url:"language,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlayHtVoice) GetVoiceId() *PlayHtVoiceId {
	if p == nil {
		return nil
	}
	return p.VoiceId
}

func (p *PlayHtVoice) GetSpeed() *float64 {
	if p == nil {
		return nil
	}
	return p.Speed
}

func (p *PlayHtVoice) GetTemperature() *float64 {
	if p == nil {
		return nil
	}
	return p.Temperature
}

func (p *PlayHtVoice) GetEmotion() *PlayHtVoiceEmotion {
	if p == nil {
		return nil
	}
	return p.Emotion
}

func (p *PlayHtVoice) GetVoiceGuidance() *float64 {
	if p == nil {
		return nil
	}
	return p.VoiceGuidance
}

func (p *PlayHtVoice) GetStyleGuidance() *float64 {
	if p == nil {
		return nil
	}
	return p.StyleGuidance
}

func (p *PlayHtVoice) GetTextGuidance() *float64 {
	if p == nil {
		return nil
	}
	return p.TextGuidance
}

func (p *PlayHtVoice) GetModel() *PlayHtVoiceModel {
	if p == nil {
		return nil
	}
	return p.Model
}

func (p *PlayHtVoice) GetLanguage() *PlayHtVoiceLanguage {
	if p == nil {
		return nil
	}
	return p.Language
}

func (p *PlayHtVoice) GetChunkPlan() *ChunkPlan {
	if p == nil {
		return nil
	}
	return p.ChunkPlan
}

func (p *PlayHtVoice) GetFallbackPlan() *FallbackPlan {
	if p == nil {
		return nil
	}
	return p.FallbackPlan
}

func (p *PlayHtVoice) Provider() string {
	return p.provider
}

func (p *PlayHtVoice) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlayHtVoice) UnmarshalJSON(data []byte) error {
	type embed PlayHtVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PlayHtVoice(unmarshaler.embed)
	if unmarshaler.Provider != "playht" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "playht", unmarshaler.Provider)
	}
	p.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "provider")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlayHtVoice) MarshalJSON() ([]byte, error) {
	type embed PlayHtVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*p),
		Provider: "playht",
	}
	return json.Marshal(marshaler)
}

func (p *PlayHtVoice) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An emotion to be applied to the speech.
type PlayHtVoiceEmotion string

const (
	PlayHtVoiceEmotionFemaleHappy     PlayHtVoiceEmotion = "female_happy"
	PlayHtVoiceEmotionFemaleSad       PlayHtVoiceEmotion = "female_sad"
	PlayHtVoiceEmotionFemaleAngry     PlayHtVoiceEmotion = "female_angry"
	PlayHtVoiceEmotionFemaleFearful   PlayHtVoiceEmotion = "female_fearful"
	PlayHtVoiceEmotionFemaleDisgust   PlayHtVoiceEmotion = "female_disgust"
	PlayHtVoiceEmotionFemaleSurprised PlayHtVoiceEmotion = "female_surprised"
	PlayHtVoiceEmotionMaleHappy       PlayHtVoiceEmotion = "male_happy"
	PlayHtVoiceEmotionMaleSad         PlayHtVoiceEmotion = "male_sad"
	PlayHtVoiceEmotionMaleAngry       PlayHtVoiceEmotion = "male_angry"
	PlayHtVoiceEmotionMaleFearful     PlayHtVoiceEmotion = "male_fearful"
	PlayHtVoiceEmotionMaleDisgust     PlayHtVoiceEmotion = "male_disgust"
	PlayHtVoiceEmotionMaleSurprised   PlayHtVoiceEmotion = "male_surprised"
)

func NewPlayHtVoiceEmotionFromString(s string) (PlayHtVoiceEmotion, error) {
	switch s {
	case "female_happy":
		return PlayHtVoiceEmotionFemaleHappy, nil
	case "female_sad":
		return PlayHtVoiceEmotionFemaleSad, nil
	case "female_angry":
		return PlayHtVoiceEmotionFemaleAngry, nil
	case "female_fearful":
		return PlayHtVoiceEmotionFemaleFearful, nil
	case "female_disgust":
		return PlayHtVoiceEmotionFemaleDisgust, nil
	case "female_surprised":
		return PlayHtVoiceEmotionFemaleSurprised, nil
	case "male_happy":
		return PlayHtVoiceEmotionMaleHappy, nil
	case "male_sad":
		return PlayHtVoiceEmotionMaleSad, nil
	case "male_angry":
		return PlayHtVoiceEmotionMaleAngry, nil
	case "male_fearful":
		return PlayHtVoiceEmotionMaleFearful, nil
	case "male_disgust":
		return PlayHtVoiceEmotionMaleDisgust, nil
	case "male_surprised":
		return PlayHtVoiceEmotionMaleSurprised, nil
	}
	var t PlayHtVoiceEmotion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceEmotion) Ptr() *PlayHtVoiceEmotion {
	return &p
}

// The language to use for the speech.
type PlayHtVoiceLanguage string

const (
	PlayHtVoiceLanguageAfrikaans  PlayHtVoiceLanguage = "afrikaans"
	PlayHtVoiceLanguageAlbanian   PlayHtVoiceLanguage = "albanian"
	PlayHtVoiceLanguageAmharic    PlayHtVoiceLanguage = "amharic"
	PlayHtVoiceLanguageArabic     PlayHtVoiceLanguage = "arabic"
	PlayHtVoiceLanguageBengali    PlayHtVoiceLanguage = "bengali"
	PlayHtVoiceLanguageBulgarian  PlayHtVoiceLanguage = "bulgarian"
	PlayHtVoiceLanguageCatalan    PlayHtVoiceLanguage = "catalan"
	PlayHtVoiceLanguageCroatian   PlayHtVoiceLanguage = "croatian"
	PlayHtVoiceLanguageCzech      PlayHtVoiceLanguage = "czech"
	PlayHtVoiceLanguageDanish     PlayHtVoiceLanguage = "danish"
	PlayHtVoiceLanguageDutch      PlayHtVoiceLanguage = "dutch"
	PlayHtVoiceLanguageEnglish    PlayHtVoiceLanguage = "english"
	PlayHtVoiceLanguageFrench     PlayHtVoiceLanguage = "french"
	PlayHtVoiceLanguageGalician   PlayHtVoiceLanguage = "galician"
	PlayHtVoiceLanguageGerman     PlayHtVoiceLanguage = "german"
	PlayHtVoiceLanguageGreek      PlayHtVoiceLanguage = "greek"
	PlayHtVoiceLanguageHebrew     PlayHtVoiceLanguage = "hebrew"
	PlayHtVoiceLanguageHindi      PlayHtVoiceLanguage = "hindi"
	PlayHtVoiceLanguageHungarian  PlayHtVoiceLanguage = "hungarian"
	PlayHtVoiceLanguageIndonesian PlayHtVoiceLanguage = "indonesian"
	PlayHtVoiceLanguageItalian    PlayHtVoiceLanguage = "italian"
	PlayHtVoiceLanguageJapanese   PlayHtVoiceLanguage = "japanese"
	PlayHtVoiceLanguageKorean     PlayHtVoiceLanguage = "korean"
	PlayHtVoiceLanguageMalay      PlayHtVoiceLanguage = "malay"
	PlayHtVoiceLanguageMandarin   PlayHtVoiceLanguage = "mandarin"
	PlayHtVoiceLanguagePolish     PlayHtVoiceLanguage = "polish"
	PlayHtVoiceLanguagePortuguese PlayHtVoiceLanguage = "portuguese"
	PlayHtVoiceLanguageRussian    PlayHtVoiceLanguage = "russian"
	PlayHtVoiceLanguageSerbian    PlayHtVoiceLanguage = "serbian"
	PlayHtVoiceLanguageSpanish    PlayHtVoiceLanguage = "spanish"
	PlayHtVoiceLanguageSwedish    PlayHtVoiceLanguage = "swedish"
	PlayHtVoiceLanguageTagalog    PlayHtVoiceLanguage = "tagalog"
	PlayHtVoiceLanguageThai       PlayHtVoiceLanguage = "thai"
	PlayHtVoiceLanguageTurkish    PlayHtVoiceLanguage = "turkish"
	PlayHtVoiceLanguageUkrainian  PlayHtVoiceLanguage = "ukrainian"
	PlayHtVoiceLanguageUrdu       PlayHtVoiceLanguage = "urdu"
	PlayHtVoiceLanguageXhosa      PlayHtVoiceLanguage = "xhosa"
)

func NewPlayHtVoiceLanguageFromString(s string) (PlayHtVoiceLanguage, error) {
	switch s {
	case "afrikaans":
		return PlayHtVoiceLanguageAfrikaans, nil
	case "albanian":
		return PlayHtVoiceLanguageAlbanian, nil
	case "amharic":
		return PlayHtVoiceLanguageAmharic, nil
	case "arabic":
		return PlayHtVoiceLanguageArabic, nil
	case "bengali":
		return PlayHtVoiceLanguageBengali, nil
	case "bulgarian":
		return PlayHtVoiceLanguageBulgarian, nil
	case "catalan":
		return PlayHtVoiceLanguageCatalan, nil
	case "croatian":
		return PlayHtVoiceLanguageCroatian, nil
	case "czech":
		return PlayHtVoiceLanguageCzech, nil
	case "danish":
		return PlayHtVoiceLanguageDanish, nil
	case "dutch":
		return PlayHtVoiceLanguageDutch, nil
	case "english":
		return PlayHtVoiceLanguageEnglish, nil
	case "french":
		return PlayHtVoiceLanguageFrench, nil
	case "galician":
		return PlayHtVoiceLanguageGalician, nil
	case "german":
		return PlayHtVoiceLanguageGerman, nil
	case "greek":
		return PlayHtVoiceLanguageGreek, nil
	case "hebrew":
		return PlayHtVoiceLanguageHebrew, nil
	case "hindi":
		return PlayHtVoiceLanguageHindi, nil
	case "hungarian":
		return PlayHtVoiceLanguageHungarian, nil
	case "indonesian":
		return PlayHtVoiceLanguageIndonesian, nil
	case "italian":
		return PlayHtVoiceLanguageItalian, nil
	case "japanese":
		return PlayHtVoiceLanguageJapanese, nil
	case "korean":
		return PlayHtVoiceLanguageKorean, nil
	case "malay":
		return PlayHtVoiceLanguageMalay, nil
	case "mandarin":
		return PlayHtVoiceLanguageMandarin, nil
	case "polish":
		return PlayHtVoiceLanguagePolish, nil
	case "portuguese":
		return PlayHtVoiceLanguagePortuguese, nil
	case "russian":
		return PlayHtVoiceLanguageRussian, nil
	case "serbian":
		return PlayHtVoiceLanguageSerbian, nil
	case "spanish":
		return PlayHtVoiceLanguageSpanish, nil
	case "swedish":
		return PlayHtVoiceLanguageSwedish, nil
	case "tagalog":
		return PlayHtVoiceLanguageTagalog, nil
	case "thai":
		return PlayHtVoiceLanguageThai, nil
	case "turkish":
		return PlayHtVoiceLanguageTurkish, nil
	case "ukrainian":
		return PlayHtVoiceLanguageUkrainian, nil
	case "urdu":
		return PlayHtVoiceLanguageUrdu, nil
	case "xhosa":
		return PlayHtVoiceLanguageXhosa, nil
	}
	var t PlayHtVoiceLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceLanguage) Ptr() *PlayHtVoiceLanguage {
	return &p
}

// Playht voice model/engine to use.
type PlayHtVoiceModel string

const (
	PlayHtVoiceModelPlayHt20      PlayHtVoiceModel = "PlayHT2.0"
	PlayHtVoiceModelPlayHt20Turbo PlayHtVoiceModel = "PlayHT2.0-turbo"
	PlayHtVoiceModelPlay30Mini    PlayHtVoiceModel = "Play3.0-mini"
)

func NewPlayHtVoiceModelFromString(s string) (PlayHtVoiceModel, error) {
	switch s {
	case "PlayHT2.0":
		return PlayHtVoiceModelPlayHt20, nil
	case "PlayHT2.0-turbo":
		return PlayHtVoiceModelPlayHt20Turbo, nil
	case "Play3.0-mini":
		return PlayHtVoiceModelPlay30Mini, nil
	}
	var t PlayHtVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlayHtVoiceModel) Ptr() *PlayHtVoiceModel {
	return &p
}

type PunctuationBoundary string

const (
	// 
	PunctuationBoundaryCircle PunctuationBoundary = ""
	// 
	PunctuationBoundaryFullWidthComma PunctuationBoundary = ""
	// .
	PunctuationBoundaryDot PunctuationBoundary = "."
	// !
	PunctuationBoundaryExclamation PunctuationBoundary = "!"
	// ?
	PunctuationBoundaryQuestion PunctuationBoundary = "?"
	// ;
	PunctuationBoundarySemicolon PunctuationBoundary = ";"
	// )
	PunctuationBoundaryParenthesis PunctuationBoundary = ")"
	// 
	PunctuationBoundaryArabicComma PunctuationBoundary = ""
	// 
	PunctuationBoundaryUrduFullStop PunctuationBoundary = ""
	// 
	PunctuationBoundaryBengaliFullStop PunctuationBoundary = ""
	// 
	PunctuationBoundaryDoubleDanda PunctuationBoundary = ""
	// |
	PunctuationBoundaryPipe PunctuationBoundary = "|"
	// ||
	PunctuationBoundaryDoublePipe PunctuationBoundary = "||"
	// ,
	PunctuationBoundaryHalfWidthComma PunctuationBoundary = ","
	// :
	PunctuationBoundaryColon PunctuationBoundary = ":"
)

func NewPunctuationBoundaryFromString(s string) (PunctuationBoundary, error) {
	switch s {
	case "":
		return PunctuationBoundaryCircle, nil
	case "":
		return PunctuationBoundaryFullWidthComma, nil
	case ".":
		return PunctuationBoundaryDot, nil
	case "!":
		return PunctuationBoundaryExclamation, nil
	case "?":
		return PunctuationBoundaryQuestion, nil
	case ";":
		return PunctuationBoundarySemicolon, nil
	case ")":
		return PunctuationBoundaryParenthesis, nil
	case "":
		return PunctuationBoundaryArabicComma, nil
	case "":
		return PunctuationBoundaryUrduFullStop, nil
	case "":
		return PunctuationBoundaryBengaliFullStop, nil
	case "":
		return PunctuationBoundaryDoubleDanda, nil
	case "|":
		return PunctuationBoundaryPipe, nil
	case "||":
		return PunctuationBoundaryDoublePipe, nil
	case ",":
		return PunctuationBoundaryHalfWidthComma, nil
	case ":":
		return PunctuationBoundaryColon, nil
	}
	var t PunctuationBoundary
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PunctuationBoundary) Ptr() *PunctuationBoundary {
	return &p
}

type RegexOption struct {
	// This is the type of the regex option. Options are:
	// - `ignore-case`: Ignores the case of the text being matched. Add
	// - `whole-word`: Matches whole words only.
	// - `multi-line`: Matches across multiple lines.
	Type RegexOptionType `json:"type" url:"type"`
	// This is whether to enable the option.
	//
	// @default false
	Enabled bool `json:"enabled" url:"enabled"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RegexOption) GetType() RegexOptionType {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *RegexOption) GetEnabled() bool {
	if r == nil {
		return false
	}
	return r.Enabled
}

func (r *RegexOption) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RegexOption) UnmarshalJSON(data []byte) error {
	type unmarshaler RegexOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegexOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegexOption) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the type of the regex option. Options are:
// - `ignore-case`: Ignores the case of the text being matched. Add
// - `whole-word`: Matches whole words only.
// - `multi-line`: Matches across multiple lines.
type RegexOptionType string

const (
	RegexOptionTypeIgnoreCase RegexOptionType = "ignore-case"
	RegexOptionTypeWholeWord  RegexOptionType = "whole-word"
	RegexOptionTypeMultiLine  RegexOptionType = "multi-line"
)

func NewRegexOptionTypeFromString(s string) (RegexOptionType, error) {
	switch s {
	case "ignore-case":
		return RegexOptionTypeIgnoreCase, nil
	case "whole-word":
		return RegexOptionTypeWholeWord, nil
	case "multi-line":
		return RegexOptionTypeMultiLine, nil
	}
	var t RegexOptionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RegexOptionType) Ptr() *RegexOptionType {
	return &r
}

type RegexReplacement struct {
	// This is the regex replacement type. You can use this to replace a word or phrase that matches a pattern.
	//
	// Usage:
	// - Replace all numbers with "some number": { type: 'regex', regex: '\\d+', value: 'some number' }
	// - Replace email addresses with "[EMAIL]": { type: 'regex', regex: '\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b', value: '[EMAIL]' }
	// - Replace phone numbers with a formatted version: { type: 'regex', regex: '(\\d{3})(\\d{3})(\\d{4})', value: '($1) $2-$3' }
	// - Replace all instances of "color" or "colour" with "hue": { type: 'regex', regex: 'colou?r', value: 'hue' }
	// - Capitalize the first letter of every sentence: { type: 'regex', regex: '(?<=\\. |^)[a-z]', value: (match) => match.toUpperCase() }
	// This is the regex pattern to replace.
	//
	// Note:
	// - This works by using the `string.replace` method in Node.JS. Eg. `"hello there".replace(/hello/g, "hi")` will return `"hi there"`.
	//
	// Hot tip:
	// - In JavaScript, escape `\` when sending the regex pattern. Eg. `"hello\sthere"` will be sent over the wire as `"hellosthere"`. Send `"hello\\sthere"` instead.
	Regex string `json:"regex" url:"regex"`
	// These are the options for the regex replacement. Defaults to all disabled.
	//
	// @default []
	Options []*RegexOption `json:"options,omitempty" url:"options,omitempty"`
	// This is the value that will replace the match.
	Value string `json:"value" url:"value"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RegexReplacement) GetRegex() string {
	if r == nil {
		return ""
	}
	return r.Regex
}

func (r *RegexReplacement) GetOptions() []*RegexOption {
	if r == nil {
		return nil
	}
	return r.Options
}

func (r *RegexReplacement) GetValue() string {
	if r == nil {
		return ""
	}
	return r.Value
}

func (r *RegexReplacement) Type() string {
	return r.type_
}

func (r *RegexReplacement) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RegexReplacement) UnmarshalJSON(data []byte) error {
	type embed RegexReplacement
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RegexReplacement(unmarshaler.embed)
	if unmarshaler.Type != "regex" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "regex", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegexReplacement) MarshalJSON() ([]byte, error) {
	type embed RegexReplacement
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "regex",
	}
	return json.Marshal(marshaler)
}

func (r *RegexReplacement) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the provider-specific ID that will be used.
type RimeAiVoiceId struct {
	RimeAiVoiceIdEnum RimeAiVoiceIdEnum
	String            string

	typ string
}

func (r *RimeAiVoiceId) GetRimeAiVoiceIdEnum() RimeAiVoiceIdEnum {
	if r == nil {
		return ""
	}
	return r.RimeAiVoiceIdEnum
}

func (r *RimeAiVoiceId) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *RimeAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueRimeAiVoiceIdEnum RimeAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueRimeAiVoiceIdEnum); err == nil {
		r.typ = "RimeAiVoiceIdEnum"
		r.RimeAiVoiceIdEnum = valueRimeAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RimeAiVoiceId) MarshalJSON() ([]byte, error) {
	if r.typ == "RimeAiVoiceIdEnum" || r.RimeAiVoiceIdEnum != "" {
		return json.Marshal(r.RimeAiVoiceIdEnum)
	}
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RimeAiVoiceIdVisitor interface {
	VisitRimeAiVoiceIdEnum(RimeAiVoiceIdEnum) error
	VisitString(string) error
}

func (r *RimeAiVoiceId) Accept(visitor RimeAiVoiceIdVisitor) error {
	if r.typ == "RimeAiVoiceIdEnum" || r.RimeAiVoiceIdEnum != "" {
		return visitor.VisitRimeAiVoiceIdEnum(r.RimeAiVoiceIdEnum)
	}
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RimeAiVoiceIdEnum string

const (
	RimeAiVoiceIdEnumMarsh      RimeAiVoiceIdEnum = "marsh"
	RimeAiVoiceIdEnumBayou      RimeAiVoiceIdEnum = "bayou"
	RimeAiVoiceIdEnumCreek      RimeAiVoiceIdEnum = "creek"
	RimeAiVoiceIdEnumBrook      RimeAiVoiceIdEnum = "brook"
	RimeAiVoiceIdEnumFlower     RimeAiVoiceIdEnum = "flower"
	RimeAiVoiceIdEnumSpore      RimeAiVoiceIdEnum = "spore"
	RimeAiVoiceIdEnumGlacier    RimeAiVoiceIdEnum = "glacier"
	RimeAiVoiceIdEnumGulch      RimeAiVoiceIdEnum = "gulch"
	RimeAiVoiceIdEnumAlpine     RimeAiVoiceIdEnum = "alpine"
	RimeAiVoiceIdEnumCove       RimeAiVoiceIdEnum = "cove"
	RimeAiVoiceIdEnumLagoon     RimeAiVoiceIdEnum = "lagoon"
	RimeAiVoiceIdEnumTundra     RimeAiVoiceIdEnum = "tundra"
	RimeAiVoiceIdEnumSteppe     RimeAiVoiceIdEnum = "steppe"
	RimeAiVoiceIdEnumMesa       RimeAiVoiceIdEnum = "mesa"
	RimeAiVoiceIdEnumGrove      RimeAiVoiceIdEnum = "grove"
	RimeAiVoiceIdEnumRainforest RimeAiVoiceIdEnum = "rainforest"
	RimeAiVoiceIdEnumMoraine    RimeAiVoiceIdEnum = "moraine"
	RimeAiVoiceIdEnumWildflower RimeAiVoiceIdEnum = "wildflower"
	RimeAiVoiceIdEnumPeak       RimeAiVoiceIdEnum = "peak"
	RimeAiVoiceIdEnumBoulder    RimeAiVoiceIdEnum = "boulder"
	RimeAiVoiceIdEnumAbbie      RimeAiVoiceIdEnum = "abbie"
	RimeAiVoiceIdEnumAllison    RimeAiVoiceIdEnum = "allison"
	RimeAiVoiceIdEnumAlly       RimeAiVoiceIdEnum = "ally"
	RimeAiVoiceIdEnumAlona      RimeAiVoiceIdEnum = "alona"
	RimeAiVoiceIdEnumAmber      RimeAiVoiceIdEnum = "amber"
	RimeAiVoiceIdEnumAna        RimeAiVoiceIdEnum = "ana"
	RimeAiVoiceIdEnumAntoine    RimeAiVoiceIdEnum = "antoine"
	RimeAiVoiceIdEnumArmon      RimeAiVoiceIdEnum = "armon"
	RimeAiVoiceIdEnumBrenda     RimeAiVoiceIdEnum = "brenda"
	RimeAiVoiceIdEnumBrittany   RimeAiVoiceIdEnum = "brittany"
	RimeAiVoiceIdEnumCarol      RimeAiVoiceIdEnum = "carol"
	RimeAiVoiceIdEnumColin      RimeAiVoiceIdEnum = "colin"
	RimeAiVoiceIdEnumCourtney   RimeAiVoiceIdEnum = "courtney"
	RimeAiVoiceIdEnumElena      RimeAiVoiceIdEnum = "elena"
	RimeAiVoiceIdEnumElliot     RimeAiVoiceIdEnum = "elliot"
	RimeAiVoiceIdEnumEva        RimeAiVoiceIdEnum = "eva"
	RimeAiVoiceIdEnumGeoff      RimeAiVoiceIdEnum = "geoff"
	RimeAiVoiceIdEnumGerald     RimeAiVoiceIdEnum = "gerald"
	RimeAiVoiceIdEnumHank       RimeAiVoiceIdEnum = "hank"
	RimeAiVoiceIdEnumHelen      RimeAiVoiceIdEnum = "helen"
	RimeAiVoiceIdEnumHera       RimeAiVoiceIdEnum = "hera"
	RimeAiVoiceIdEnumJen        RimeAiVoiceIdEnum = "jen"
	RimeAiVoiceIdEnumJoe        RimeAiVoiceIdEnum = "joe"
	RimeAiVoiceIdEnumJoy        RimeAiVoiceIdEnum = "joy"
	RimeAiVoiceIdEnumJuan       RimeAiVoiceIdEnum = "juan"
	RimeAiVoiceIdEnumKendra     RimeAiVoiceIdEnum = "kendra"
	RimeAiVoiceIdEnumKendrick   RimeAiVoiceIdEnum = "kendrick"
	RimeAiVoiceIdEnumKenneth    RimeAiVoiceIdEnum = "kenneth"
	RimeAiVoiceIdEnumKevin      RimeAiVoiceIdEnum = "kevin"
	RimeAiVoiceIdEnumKris       RimeAiVoiceIdEnum = "kris"
	RimeAiVoiceIdEnumLinda      RimeAiVoiceIdEnum = "linda"
	RimeAiVoiceIdEnumMadison    RimeAiVoiceIdEnum = "madison"
	RimeAiVoiceIdEnumMarge      RimeAiVoiceIdEnum = "marge"
	RimeAiVoiceIdEnumMarina     RimeAiVoiceIdEnum = "marina"
	RimeAiVoiceIdEnumMarissa    RimeAiVoiceIdEnum = "marissa"
	RimeAiVoiceIdEnumMarta      RimeAiVoiceIdEnum = "marta"
	RimeAiVoiceIdEnumMaya       RimeAiVoiceIdEnum = "maya"
	RimeAiVoiceIdEnumNicholas   RimeAiVoiceIdEnum = "nicholas"
	RimeAiVoiceIdEnumNyles      RimeAiVoiceIdEnum = "nyles"
	RimeAiVoiceIdEnumPhil       RimeAiVoiceIdEnum = "phil"
	RimeAiVoiceIdEnumReba       RimeAiVoiceIdEnum = "reba"
	RimeAiVoiceIdEnumRex        RimeAiVoiceIdEnum = "rex"
	RimeAiVoiceIdEnumRick       RimeAiVoiceIdEnum = "rick"
	RimeAiVoiceIdEnumRitu       RimeAiVoiceIdEnum = "ritu"
	RimeAiVoiceIdEnumRob        RimeAiVoiceIdEnum = "rob"
	RimeAiVoiceIdEnumRodney     RimeAiVoiceIdEnum = "rodney"
	RimeAiVoiceIdEnumRohan      RimeAiVoiceIdEnum = "rohan"
	RimeAiVoiceIdEnumRosco      RimeAiVoiceIdEnum = "rosco"
	RimeAiVoiceIdEnumSamantha   RimeAiVoiceIdEnum = "samantha"
	RimeAiVoiceIdEnumSandy      RimeAiVoiceIdEnum = "sandy"
	RimeAiVoiceIdEnumSelena     RimeAiVoiceIdEnum = "selena"
	RimeAiVoiceIdEnumSeth       RimeAiVoiceIdEnum = "seth"
	RimeAiVoiceIdEnumSharon     RimeAiVoiceIdEnum = "sharon"
	RimeAiVoiceIdEnumStan       RimeAiVoiceIdEnum = "stan"
	RimeAiVoiceIdEnumTamra      RimeAiVoiceIdEnum = "tamra"
	RimeAiVoiceIdEnumTanya      RimeAiVoiceIdEnum = "tanya"
	RimeAiVoiceIdEnumTibur      RimeAiVoiceIdEnum = "tibur"
	RimeAiVoiceIdEnumTj         RimeAiVoiceIdEnum = "tj"
	RimeAiVoiceIdEnumTyler      RimeAiVoiceIdEnum = "tyler"
	RimeAiVoiceIdEnumViv        RimeAiVoiceIdEnum = "viv"
	RimeAiVoiceIdEnumYadira     RimeAiVoiceIdEnum = "yadira"
)

func NewRimeAiVoiceIdEnumFromString(s string) (RimeAiVoiceIdEnum, error) {
	switch s {
	case "marsh":
		return RimeAiVoiceIdEnumMarsh, nil
	case "bayou":
		return RimeAiVoiceIdEnumBayou, nil
	case "creek":
		return RimeAiVoiceIdEnumCreek, nil
	case "brook":
		return RimeAiVoiceIdEnumBrook, nil
	case "flower":
		return RimeAiVoiceIdEnumFlower, nil
	case "spore":
		return RimeAiVoiceIdEnumSpore, nil
	case "glacier":
		return RimeAiVoiceIdEnumGlacier, nil
	case "gulch":
		return RimeAiVoiceIdEnumGulch, nil
	case "alpine":
		return RimeAiVoiceIdEnumAlpine, nil
	case "cove":
		return RimeAiVoiceIdEnumCove, nil
	case "lagoon":
		return RimeAiVoiceIdEnumLagoon, nil
	case "tundra":
		return RimeAiVoiceIdEnumTundra, nil
	case "steppe":
		return RimeAiVoiceIdEnumSteppe, nil
	case "mesa":
		return RimeAiVoiceIdEnumMesa, nil
	case "grove":
		return RimeAiVoiceIdEnumGrove, nil
	case "rainforest":
		return RimeAiVoiceIdEnumRainforest, nil
	case "moraine":
		return RimeAiVoiceIdEnumMoraine, nil
	case "wildflower":
		return RimeAiVoiceIdEnumWildflower, nil
	case "peak":
		return RimeAiVoiceIdEnumPeak, nil
	case "boulder":
		return RimeAiVoiceIdEnumBoulder, nil
	case "abbie":
		return RimeAiVoiceIdEnumAbbie, nil
	case "allison":
		return RimeAiVoiceIdEnumAllison, nil
	case "ally":
		return RimeAiVoiceIdEnumAlly, nil
	case "alona":
		return RimeAiVoiceIdEnumAlona, nil
	case "amber":
		return RimeAiVoiceIdEnumAmber, nil
	case "ana":
		return RimeAiVoiceIdEnumAna, nil
	case "antoine":
		return RimeAiVoiceIdEnumAntoine, nil
	case "armon":
		return RimeAiVoiceIdEnumArmon, nil
	case "brenda":
		return RimeAiVoiceIdEnumBrenda, nil
	case "brittany":
		return RimeAiVoiceIdEnumBrittany, nil
	case "carol":
		return RimeAiVoiceIdEnumCarol, nil
	case "colin":
		return RimeAiVoiceIdEnumColin, nil
	case "courtney":
		return RimeAiVoiceIdEnumCourtney, nil
	case "elena":
		return RimeAiVoiceIdEnumElena, nil
	case "elliot":
		return RimeAiVoiceIdEnumElliot, nil
	case "eva":
		return RimeAiVoiceIdEnumEva, nil
	case "geoff":
		return RimeAiVoiceIdEnumGeoff, nil
	case "gerald":
		return RimeAiVoiceIdEnumGerald, nil
	case "hank":
		return RimeAiVoiceIdEnumHank, nil
	case "helen":
		return RimeAiVoiceIdEnumHelen, nil
	case "hera":
		return RimeAiVoiceIdEnumHera, nil
	case "jen":
		return RimeAiVoiceIdEnumJen, nil
	case "joe":
		return RimeAiVoiceIdEnumJoe, nil
	case "joy":
		return RimeAiVoiceIdEnumJoy, nil
	case "juan":
		return RimeAiVoiceIdEnumJuan, nil
	case "kendra":
		return RimeAiVoiceIdEnumKendra, nil
	case "kendrick":
		return RimeAiVoiceIdEnumKendrick, nil
	case "kenneth":
		return RimeAiVoiceIdEnumKenneth, nil
	case "kevin":
		return RimeAiVoiceIdEnumKevin, nil
	case "kris":
		return RimeAiVoiceIdEnumKris, nil
	case "linda":
		return RimeAiVoiceIdEnumLinda, nil
	case "madison":
		return RimeAiVoiceIdEnumMadison, nil
	case "marge":
		return RimeAiVoiceIdEnumMarge, nil
	case "marina":
		return RimeAiVoiceIdEnumMarina, nil
	case "marissa":
		return RimeAiVoiceIdEnumMarissa, nil
	case "marta":
		return RimeAiVoiceIdEnumMarta, nil
	case "maya":
		return RimeAiVoiceIdEnumMaya, nil
	case "nicholas":
		return RimeAiVoiceIdEnumNicholas, nil
	case "nyles":
		return RimeAiVoiceIdEnumNyles, nil
	case "phil":
		return RimeAiVoiceIdEnumPhil, nil
	case "reba":
		return RimeAiVoiceIdEnumReba, nil
	case "rex":
		return RimeAiVoiceIdEnumRex, nil
	case "rick":
		return RimeAiVoiceIdEnumRick, nil
	case "ritu":
		return RimeAiVoiceIdEnumRitu, nil
	case "rob":
		return RimeAiVoiceIdEnumRob, nil
	case "rodney":
		return RimeAiVoiceIdEnumRodney, nil
	case "rohan":
		return RimeAiVoiceIdEnumRohan, nil
	case "rosco":
		return RimeAiVoiceIdEnumRosco, nil
	case "samantha":
		return RimeAiVoiceIdEnumSamantha, nil
	case "sandy":
		return RimeAiVoiceIdEnumSandy, nil
	case "selena":
		return RimeAiVoiceIdEnumSelena, nil
	case "seth":
		return RimeAiVoiceIdEnumSeth, nil
	case "sharon":
		return RimeAiVoiceIdEnumSharon, nil
	case "stan":
		return RimeAiVoiceIdEnumStan, nil
	case "tamra":
		return RimeAiVoiceIdEnumTamra, nil
	case "tanya":
		return RimeAiVoiceIdEnumTanya, nil
	case "tibur":
		return RimeAiVoiceIdEnumTibur, nil
	case "tj":
		return RimeAiVoiceIdEnumTj, nil
	case "tyler":
		return RimeAiVoiceIdEnumTyler, nil
	case "viv":
		return RimeAiVoiceIdEnumViv, nil
	case "yadira":
		return RimeAiVoiceIdEnumYadira, nil
	}
	var t RimeAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RimeAiVoiceIdEnum) Ptr() *RimeAiVoiceIdEnum {
	return &r
}

type RimeAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RimeAiCredential) GetApiKey() string {
	if r == nil {
		return ""
	}
	return r.ApiKey
}

func (r *RimeAiCredential) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RimeAiCredential) GetOrgId() string {
	if r == nil {
		return ""
	}
	return r.OrgId
}

func (r *RimeAiCredential) GetCreatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.CreatedAt
}

func (r *RimeAiCredential) GetUpdatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.UpdatedAt
}

func (r *RimeAiCredential) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RimeAiCredential) Provider() string {
	return r.provider
}

func (r *RimeAiCredential) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RimeAiCredential) UnmarshalJSON(data []byte) error {
	type embed RimeAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RimeAiCredential(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rime-ai", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RimeAiCredential) MarshalJSON() ([]byte, error) {
	type embed RimeAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*r),
		CreatedAt: internal.NewDateTime(r.CreatedAt),
		UpdatedAt: internal.NewDateTime(r.UpdatedAt),
		Provider:  "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (r *RimeAiCredential) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RimeAiVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *RimeAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the model that will be used. Defaults to 'v1' when not specified.
	Model *RimeAiVoiceModel `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RimeAiVoice) GetVoiceId() *RimeAiVoiceId {
	if r == nil {
		return nil
	}
	return r.VoiceId
}

func (r *RimeAiVoice) GetModel() *RimeAiVoiceModel {
	if r == nil {
		return nil
	}
	return r.Model
}

func (r *RimeAiVoice) GetSpeed() *float64 {
	if r == nil {
		return nil
	}
	return r.Speed
}

func (r *RimeAiVoice) GetChunkPlan() *ChunkPlan {
	if r == nil {
		return nil
	}
	return r.ChunkPlan
}

func (r *RimeAiVoice) GetFallbackPlan() *FallbackPlan {
	if r == nil {
		return nil
	}
	return r.FallbackPlan
}

func (r *RimeAiVoice) Provider() string {
	return r.provider
}

func (r *RimeAiVoice) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RimeAiVoice) UnmarshalJSON(data []byte) error {
	type embed RimeAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RimeAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "rime-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rime-ai", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RimeAiVoice) MarshalJSON() ([]byte, error) {
	type embed RimeAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*r),
		Provider: "rime-ai",
	}
	return json.Marshal(marshaler)
}

func (r *RimeAiVoice) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the model that will be used. Defaults to 'v1' when not specified.
type RimeAiVoiceModel string

const (
	RimeAiVoiceModelV1   RimeAiVoiceModel = "v1"
	RimeAiVoiceModelMist RimeAiVoiceModel = "mist"
)

func NewRimeAiVoiceModelFromString(s string) (RimeAiVoiceModel, error) {
	switch s {
	case "v1":
		return RimeAiVoiceModelV1, nil
	case "mist":
		return RimeAiVoiceModelMist, nil
	}
	var t RimeAiVoiceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RimeAiVoiceModel) Ptr() *RimeAiVoiceModel {
	return &r
}

type RuleBasedCondition struct {
	// This condition is based on a strict rule.
	// This is the operator you want to use to compare the left side and right side.
	//
	// The operation becomes `(leftSide) operator (rightSide)`.
	Operator RuleBasedConditionOperator `json:"operator" url:"operator"`
	// This is the left side of the operation.
	//
	// You can reference any variable in the context of the current block execution (step):
	// - "{{output.your-property-name}}" for current step's output
	// - "{{input.your-property-name}}" for current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// Or, you can use a constant:
	// - "1"
	// - "text"
	// - "true"
	// - "false"
	//
	// Or, you can mix and match with string interpolation:
	// - "{{your-property-name}}-{{input.your-property-name-2}}-1"
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	LeftSide string `json:"leftSide" url:"leftSide"`
	// This is the right side of the operation.
	//
	// You can reference any variable in the context of the current block execution (step):
	// - "{{output.your-property-name}}" for current step's output
	// - "{{input.your-property-name}}" for current step's input
	// - "{{your-step-name.output.your-property-name}}" for another step's output (in the same workflow; read caveat #1)
	// - "{{your-step-name.input.your-property-name}}" for another step's input (in the same workflow; read caveat #1)
	// - "{{your-block-name.output.your-property-name}}" for another block's output (in the same workflow; read caveat #2)
	// - "{{your-block-name.input.your-property-name}}" for another block's input (in the same workflow; read caveat #2)
	// - "{{workflow.input.your-property-name}}" for the current workflow's input
	// - "{{global.your-property-name}}" for the global context
	//
	// Or, you can use a constant:
	// - "1"
	// - "text"
	// - "true"
	// - "false"
	//
	// Or, you can mix and match with string interpolation:
	// - "{{your-property-name}}-{{input.your-property-name-2}}-1"
	//
	// Caveats:
	// 1. a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.
	// 2. a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow with steps.
	RightSide string `json:"rightSide" url:"rightSide"`
	type_     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleBasedCondition) GetOperator() RuleBasedConditionOperator {
	if r == nil {
		return ""
	}
	return r.Operator
}

func (r *RuleBasedCondition) GetLeftSide() string {
	if r == nil {
		return ""
	}
	return r.LeftSide
}

func (r *RuleBasedCondition) GetRightSide() string {
	if r == nil {
		return ""
	}
	return r.RightSide
}

func (r *RuleBasedCondition) Type() string {
	return r.type_
}

func (r *RuleBasedCondition) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleBasedCondition) UnmarshalJSON(data []byte) error {
	type embed RuleBasedCondition
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RuleBasedCondition(unmarshaler.embed)
	if unmarshaler.Type != "rule-based" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "rule-based", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleBasedCondition) MarshalJSON() ([]byte, error) {
	type embed RuleBasedCondition
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "rule-based",
	}
	return json.Marshal(marshaler)
}

func (r *RuleBasedCondition) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// This is the operator you want to use to compare the left side and right side.
//
// The operation becomes `(leftSide) operator (rightSide)`.
type RuleBasedConditionOperator string

const (
	RuleBasedConditionOperatorEq  RuleBasedConditionOperator = "eq"
	RuleBasedConditionOperatorNeq RuleBasedConditionOperator = "neq"
	RuleBasedConditionOperatorGt  RuleBasedConditionOperator = "gt"
	RuleBasedConditionOperatorGte RuleBasedConditionOperator = "gte"
	RuleBasedConditionOperatorLt  RuleBasedConditionOperator = "lt"
	RuleBasedConditionOperatorLte RuleBasedConditionOperator = "lte"
)

func NewRuleBasedConditionOperatorFromString(s string) (RuleBasedConditionOperator, error) {
	switch s {
	case "eq":
		return RuleBasedConditionOperatorEq, nil
	case "neq":
		return RuleBasedConditionOperatorNeq, nil
	case "gt":
		return RuleBasedConditionOperatorGt, nil
	case "gte":
		return RuleBasedConditionOperatorGte, nil
	case "lt":
		return RuleBasedConditionOperatorLt, nil
	case "lte":
		return RuleBasedConditionOperatorLte, nil
	}
	var t RuleBasedConditionOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RuleBasedConditionOperator) Ptr() *RuleBasedConditionOperator {
	return &r
}

type RunpodCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RunpodCredential) GetApiKey() string {
	if r == nil {
		return ""
	}
	return r.ApiKey
}

func (r *RunpodCredential) GetId() string {
	if r == nil {
		return ""
	}
	return r.Id
}

func (r *RunpodCredential) GetOrgId() string {
	if r == nil {
		return ""
	}
	return r.OrgId
}

func (r *RunpodCredential) GetCreatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.CreatedAt
}

func (r *RunpodCredential) GetUpdatedAt() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.UpdatedAt
}

func (r *RunpodCredential) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RunpodCredential) Provider() string {
	return r.provider
}

func (r *RunpodCredential) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RunpodCredential) UnmarshalJSON(data []byte) error {
	type embed RunpodCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RunpodCredential(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "runpod" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "runpod", unmarshaler.Provider)
	}
	r.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "provider")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RunpodCredential) MarshalJSON() ([]byte, error) {
	type embed RunpodCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*r),
		CreatedAt: internal.NewDateTime(r.CreatedAt),
		UpdatedAt: internal.NewDateTime(r.UpdatedAt),
		Provider:  "runpod",
	}
	return json.Marshal(marshaler)
}

func (r *RunpodCredential) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type S3Credential struct {
	// Credential provider. Only allowed value is s3
	// AWS access key ID.
	AwsAccessKeyId string `json:"awsAccessKeyId" url:"awsAccessKeyId"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey string `json:"awsSecretAccessKey" url:"awsSecretAccessKey"`
	// AWS region in which the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// AWS S3 bucket name.
	S3BucketName string `json:"s3BucketName" url:"s3BucketName"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix string `json:"s3PathPrefix" url:"s3PathPrefix"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *S3Credential) GetAwsAccessKeyId() string {
	if s == nil {
		return ""
	}
	return s.AwsAccessKeyId
}

func (s *S3Credential) GetAwsSecretAccessKey() string {
	if s == nil {
		return ""
	}
	return s.AwsSecretAccessKey
}

func (s *S3Credential) GetRegion() string {
	if s == nil {
		return ""
	}
	return s.Region
}

func (s *S3Credential) GetS3BucketName() string {
	if s == nil {
		return ""
	}
	return s.S3BucketName
}

func (s *S3Credential) GetS3PathPrefix() string {
	if s == nil {
		return ""
	}
	return s.S3PathPrefix
}

func (s *S3Credential) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *S3Credential) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *S3Credential) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *S3Credential) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *S3Credential) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *S3Credential) Provider() string {
	return s.provider
}

func (s *S3Credential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *S3Credential) UnmarshalJSON(data []byte) error {
	type embed S3Credential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = S3Credential(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "s3" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "s3", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *S3Credential) MarshalJSON() ([]byte, error) {
	type embed S3Credential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Provider:  "s3",
	}
	return json.Marshal(marshaler)
}

func (s *S3Credential) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SbcConfiguration struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SbcConfiguration) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SbcConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler SbcConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SbcConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SbcConfiguration) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Server struct {
	// This is the timeout in seconds for the request to your server. Defaults to 20 seconds.
	//
	// @default 20
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`
	// API endpoint to send requests to.
	Url string `json:"url" url:"url"`
	// This is the secret you can set that Vapi will send with every request to your server. Will be sent as a header called x-vapi-secret.
	//
	// Same precedence logic as server.
	Secret *string `json:"secret,omitempty" url:"secret,omitempty"`
	// These are the custom headers to include in the request sent to your server.
	//
	// Each key-value pair represents a header name and its value.
	Headers map[string]interface{} `json:"headers,omitempty" url:"headers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Server) GetTimeoutSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.TimeoutSeconds
}

func (s *Server) GetUrl() string {
	if s == nil {
		return ""
	}
	return s.Url
}

func (s *Server) GetSecret() *string {
	if s == nil {
		return nil
	}
	return s.Secret
}

func (s *Server) GetHeaders() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Headers
}

func (s *Server) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Server) UnmarshalJSON(data []byte) error {
	type unmarshaler Server
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Server(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Server) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessage struct {
	// These are all the messages that can be sent to your server before, after and during the call. Configure the messages you'd like to receive in `assistant.serverMessages`.
	//
	// The server where the message is sent is determined by the following precedence order:
	//
	// 1. `tool.server.url` (if configured, and only for "tool-calls" message)
	// 2. `assistant.serverUrl` (if configure)
	// 3. `phoneNumber.serverUrl` (if configured)
	// 4. `org.serverUrl` (if configured)
	Message *ServerMessageMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessage) GetMessage() *ServerMessageMessage {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *ServerMessage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessage) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageAssistantRequest struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageAssistantRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "assistant-request" is sent to fetch assistant configuration for an incoming call.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageAssistantRequest) GetPhoneNumber() *ServerMessageAssistantRequestPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageAssistantRequest) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageAssistantRequest) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageAssistantRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageAssistantRequest) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageAssistantRequest) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageAssistantRequest) Type() string {
	return s.type_
}

func (s *ServerMessageAssistantRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageAssistantRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageAssistantRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageAssistantRequest(unmarshaler.embed)
	if unmarshaler.Type != "assistant-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "assistant-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageAssistantRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageAssistantRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "assistant-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageAssistantRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageAssistantRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageAssistantRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageAssistantRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageAssistantRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageAssistantRequestPhoneNumber) Accept(visitor ServerMessageAssistantRequestPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdate struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageConversationUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "conversation-update" is sent when an update is committed to the conversation history.
	// This is the most up-to-date conversation history at the time the message is sent.
	Messages []*ServerMessageConversationUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is the most up-to-date conversation history at the time the message is sent, formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageConversationUpdate) GetPhoneNumber() *ServerMessageConversationUpdatePhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageConversationUpdate) GetMessages() []*ServerMessageConversationUpdateMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *ServerMessageConversationUpdate) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if s == nil {
		return nil
	}
	return s.MessagesOpenAiFormatted
}

func (s *ServerMessageConversationUpdate) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageConversationUpdate) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageConversationUpdate) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageConversationUpdate) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageConversationUpdate) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageConversationUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageConversationUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageConversationUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageConversationUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageConversationUpdate(unmarshaler.embed)
	if unmarshaler.Type != "conversation-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "conversation-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageConversationUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageConversationUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "conversation-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageConversationUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageConversationUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (s *ServerMessageConversationUpdateMessagesItem) GetUserMessage() *UserMessage {
	if s == nil {
		return nil
	}
	return s.UserMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) GetSystemMessage() *SystemMessage {
	if s == nil {
		return nil
	}
	return s.SystemMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) GetBotMessage() *BotMessage {
	if s == nil {
		return nil
	}
	return s.BotMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallResultMessage
}

func (s *ServerMessageConversationUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.typ = "UserMessage"
		s.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.typ = "SystemMessage"
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		s.typ = "BotMessage"
		s.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		s.typ = "ToolCallMessage"
		s.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		s.typ = "ToolCallResultMessage"
		s.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageConversationUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return json.Marshal(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return json.Marshal(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return json.Marshal(s.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (s *ServerMessageConversationUpdateMessagesItem) Accept(visitor ServerMessageConversationUpdateMessagesItemVisitor) error {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return visitor.VisitBotMessage(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(s.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageConversationUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageConversationUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageConversationUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageConversationUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageConversationUpdatePhoneNumber) Accept(visitor ServerMessageConversationUpdatePhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReport struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageEndOfCallReportPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "end-of-call-report" is sent when the call ends and post-processing is complete.
	// This is the reason the call ended. This can also be found at `call.endedReason` on GET /call/:id.
	EndedReason ServerMessageEndOfCallReportEndedReason `json:"endedReason" url:"endedReason"`
	// This is the cost of the call in USD. This can also be found at `call.cost` on GET /call/:id.
	Cost *float64 `json:"cost,omitempty" url:"cost,omitempty"`
	// These are the costs of individual components of the call in USD. This can also be found at `call.costs` on GET /call/:id.
	Costs []*ServerMessageEndOfCallReportCostsItem `json:"costs,omitempty" url:"costs,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// These are the artifacts from the call. This can also be found at `call.artifact` on GET /call/:id.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the analysis of the call. This can also be found at `call.analysis` on GET /call/:id.
	Analysis *Analysis `json:"analysis,omitempty" url:"analysis,omitempty"`
	// This is the ISO 8601 date-time string of when the call started. This can also be found at `call.startedAt` on GET /call/:id.
	StartedAt *time.Time `json:"startedAt,omitempty" url:"startedAt,omitempty"`
	// This is the ISO 8601 date-time string of when the call ended. This can also be found at `call.endedAt` on GET /call/:id.
	EndedAt *time.Time `json:"endedAt,omitempty" url:"endedAt,omitempty"`
	type_   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageEndOfCallReport) GetPhoneNumber() *ServerMessageEndOfCallReportPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageEndOfCallReport) GetEndedReason() ServerMessageEndOfCallReportEndedReason {
	if s == nil {
		return ""
	}
	return s.EndedReason
}

func (s *ServerMessageEndOfCallReport) GetCost() *float64 {
	if s == nil {
		return nil
	}
	return s.Cost
}

func (s *ServerMessageEndOfCallReport) GetCosts() []*ServerMessageEndOfCallReportCostsItem {
	if s == nil {
		return nil
	}
	return s.Costs
}

func (s *ServerMessageEndOfCallReport) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageEndOfCallReport) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageEndOfCallReport) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageEndOfCallReport) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageEndOfCallReport) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageEndOfCallReport) GetAnalysis() *Analysis {
	if s == nil {
		return nil
	}
	return s.Analysis
}

func (s *ServerMessageEndOfCallReport) GetStartedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.StartedAt
}

func (s *ServerMessageEndOfCallReport) GetEndedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.EndedAt
}

func (s *ServerMessageEndOfCallReport) Type() string {
	return s.type_
}

func (s *ServerMessageEndOfCallReport) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageEndOfCallReport) UnmarshalJSON(data []byte) error {
	type embed ServerMessageEndOfCallReport
	var unmarshaler = struct {
		embed
		StartedAt *internal.DateTime `json:"startedAt,omitempty"`
		EndedAt   *internal.DateTime `json:"endedAt,omitempty"`
		Type      string             `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageEndOfCallReport(unmarshaler.embed)
	s.StartedAt = unmarshaler.StartedAt.TimePtr()
	s.EndedAt = unmarshaler.EndedAt.TimePtr()
	if unmarshaler.Type != "end-of-call-report" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "end-of-call-report", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageEndOfCallReport) MarshalJSON() ([]byte, error) {
	type embed ServerMessageEndOfCallReport
	var marshaler = struct {
		embed
		StartedAt *internal.DateTime `json:"startedAt,omitempty"`
		EndedAt   *internal.DateTime `json:"endedAt,omitempty"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*s),
		StartedAt: internal.NewOptionalDateTime(s.StartedAt),
		EndedAt:   internal.NewOptionalDateTime(s.EndedAt),
		Type:      "end-of-call-report",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageEndOfCallReport) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageEndOfCallReportCostsItem struct {
	TransportCost   *TransportCost
	TranscriberCost *TranscriberCost
	ModelCost       *ModelCost
	VoiceCost       *VoiceCost
	VapiCost        *VapiCost
	AnalysisCost    *AnalysisCost

	typ string
}

func (s *ServerMessageEndOfCallReportCostsItem) GetTransportCost() *TransportCost {
	if s == nil {
		return nil
	}
	return s.TransportCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetTranscriberCost() *TranscriberCost {
	if s == nil {
		return nil
	}
	return s.TranscriberCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetModelCost() *ModelCost {
	if s == nil {
		return nil
	}
	return s.ModelCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetVoiceCost() *VoiceCost {
	if s == nil {
		return nil
	}
	return s.VoiceCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetVapiCost() *VapiCost {
	if s == nil {
		return nil
	}
	return s.VapiCost
}

func (s *ServerMessageEndOfCallReportCostsItem) GetAnalysisCost() *AnalysisCost {
	if s == nil {
		return nil
	}
	return s.AnalysisCost
}

func (s *ServerMessageEndOfCallReportCostsItem) UnmarshalJSON(data []byte) error {
	valueTransportCost := new(TransportCost)
	if err := json.Unmarshal(data, &valueTransportCost); err == nil {
		s.typ = "TransportCost"
		s.TransportCost = valueTransportCost
		return nil
	}
	valueTranscriberCost := new(TranscriberCost)
	if err := json.Unmarshal(data, &valueTranscriberCost); err == nil {
		s.typ = "TranscriberCost"
		s.TranscriberCost = valueTranscriberCost
		return nil
	}
	valueModelCost := new(ModelCost)
	if err := json.Unmarshal(data, &valueModelCost); err == nil {
		s.typ = "ModelCost"
		s.ModelCost = valueModelCost
		return nil
	}
	valueVoiceCost := new(VoiceCost)
	if err := json.Unmarshal(data, &valueVoiceCost); err == nil {
		s.typ = "VoiceCost"
		s.VoiceCost = valueVoiceCost
		return nil
	}
	valueVapiCost := new(VapiCost)
	if err := json.Unmarshal(data, &valueVapiCost); err == nil {
		s.typ = "VapiCost"
		s.VapiCost = valueVapiCost
		return nil
	}
	valueAnalysisCost := new(AnalysisCost)
	if err := json.Unmarshal(data, &valueAnalysisCost); err == nil {
		s.typ = "AnalysisCost"
		s.AnalysisCost = valueAnalysisCost
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageEndOfCallReportCostsItem) MarshalJSON() ([]byte, error) {
	if s.typ == "TransportCost" || s.TransportCost != nil {
		return json.Marshal(s.TransportCost)
	}
	if s.typ == "TranscriberCost" || s.TranscriberCost != nil {
		return json.Marshal(s.TranscriberCost)
	}
	if s.typ == "ModelCost" || s.ModelCost != nil {
		return json.Marshal(s.ModelCost)
	}
	if s.typ == "VoiceCost" || s.VoiceCost != nil {
		return json.Marshal(s.VoiceCost)
	}
	if s.typ == "VapiCost" || s.VapiCost != nil {
		return json.Marshal(s.VapiCost)
	}
	if s.typ == "AnalysisCost" || s.AnalysisCost != nil {
		return json.Marshal(s.AnalysisCost)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReportCostsItemVisitor interface {
	VisitTransportCost(*TransportCost) error
	VisitTranscriberCost(*TranscriberCost) error
	VisitModelCost(*ModelCost) error
	VisitVoiceCost(*VoiceCost) error
	VisitVapiCost(*VapiCost) error
	VisitAnalysisCost(*AnalysisCost) error
}

func (s *ServerMessageEndOfCallReportCostsItem) Accept(visitor ServerMessageEndOfCallReportCostsItemVisitor) error {
	if s.typ == "TransportCost" || s.TransportCost != nil {
		return visitor.VisitTransportCost(s.TransportCost)
	}
	if s.typ == "TranscriberCost" || s.TranscriberCost != nil {
		return visitor.VisitTranscriberCost(s.TranscriberCost)
	}
	if s.typ == "ModelCost" || s.ModelCost != nil {
		return visitor.VisitModelCost(s.ModelCost)
	}
	if s.typ == "VoiceCost" || s.VoiceCost != nil {
		return visitor.VisitVoiceCost(s.VoiceCost)
	}
	if s.typ == "VapiCost" || s.VapiCost != nil {
		return visitor.VisitVapiCost(s.VapiCost)
	}
	if s.typ == "AnalysisCost" || s.AnalysisCost != nil {
		return visitor.VisitAnalysisCost(s.AnalysisCost)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the reason the call ended. This can also be found at `call.endedReason` on GET /call/:id.
type ServerMessageEndOfCallReportEndedReason string

const (
	ServerMessageEndOfCallReportEndedReasonAssistantNotInvalid                                                                        ServerMessageEndOfCallReportEndedReason = "assistant-not-invalid"
	ServerMessageEndOfCallReportEndedReasonAssistantNotProvided                                                                       ServerMessageEndOfCallReportEndedReason = "assistant-not-provided"
	ServerMessageEndOfCallReportEndedReasonCallStartErrorNeitherAssistantNorServerSet                                                 ServerMessageEndOfCallReportEndedReason = "call-start-error-neither-assistant-nor-server-set"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestFailed                                                                     ServerMessageEndOfCallReportEndedReason = "assistant-request-failed"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedError                                                              ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-error"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedUnspeakableError                                                   ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-unspeakable-error"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedInvalidAssistant                                                   ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-invalid-assistant"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedNoAssistant                                                        ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-no-assistant"
	ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedForwardingPhoneNumber                                              ServerMessageEndOfCallReportEndedReason = "assistant-request-returned-forwarding-phone-number"
	ServerMessageEndOfCallReportEndedReasonAssistantEndedCall                                                                         ServerMessageEndOfCallReportEndedReason = "assistant-ended-call"
	ServerMessageEndOfCallReportEndedReasonAssistantSaidEndCallPhrase                                                                 ServerMessageEndOfCallReportEndedReason = "assistant-said-end-call-phrase"
	ServerMessageEndOfCallReportEndedReasonAssistantForwardedCall                                                                     ServerMessageEndOfCallReportEndedReason = "assistant-forwarded-call"
	ServerMessageEndOfCallReportEndedReasonAssistantJoinTimedOut                                                                      ServerMessageEndOfCallReportEndedReason = "assistant-join-timed-out"
	ServerMessageEndOfCallReportEndedReasonCustomerBusy                                                                               ServerMessageEndOfCallReportEndedReason = "customer-busy"
	ServerMessageEndOfCallReportEndedReasonCustomerEndedCall                                                                          ServerMessageEndOfCallReportEndedReason = "customer-ended-call"
	ServerMessageEndOfCallReportEndedReasonCustomerDidNotAnswer                                                                       ServerMessageEndOfCallReportEndedReason = "customer-did-not-answer"
	ServerMessageEndOfCallReportEndedReasonCustomerDidNotGiveMicrophonePermission                                                     ServerMessageEndOfCallReportEndedReason = "customer-did-not-give-microphone-permission"
	ServerMessageEndOfCallReportEndedReasonAssistantSaidMessageWithEndCallEnabled                                                     ServerMessageEndOfCallReportEndedReason = "assistant-said-message-with-end-call-enabled"
	ServerMessageEndOfCallReportEndedReasonExceededMaxDuration                                                                        ServerMessageEndOfCallReportEndedReason = "exceeded-max-duration"
	ServerMessageEndOfCallReportEndedReasonManuallyCanceled                                                                           ServerMessageEndOfCallReportEndedReason = "manually-canceled"
	ServerMessageEndOfCallReportEndedReasonPhoneCallProviderClosedWebsocket                                                           ServerMessageEndOfCallReportEndedReason = "phone-call-provider-closed-websocket"
	ServerMessageEndOfCallReportEndedReasonDbError                                                                                    ServerMessageEndOfCallReportEndedReason = "db-error"
	ServerMessageEndOfCallReportEndedReasonAssistantNotFound                                                                          ServerMessageEndOfCallReportEndedReason = "assistant-not-found"
	ServerMessageEndOfCallReportEndedReasonLicenseCheckFailed                                                                         ServerMessageEndOfCallReportEndedReason = "license-check-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiVoiceFailed                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaVoiceFailed                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramVoiceFailed                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceFailed                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceFailed                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorLmntVoiceFailed                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-lmnt-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureVoiceFailed                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRimeAiVoiceFailed                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-rime-ai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorNeetsVoiceFailed                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-neets-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorSmallestAiVoiceFailed                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-smallest-ai-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramTranscriberFailed                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGladiaTranscriberFailed                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-gladia-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiTranscriberFailed                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-assembly-ai-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTalkscriberTranscriberFailed                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-talkscriber-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureSpeechTranscriberFailed                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-speech-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapiLlmFailed                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi400BadRequestValidationFailed                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi401Unauthorized                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi403ModelAccessDenied                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi429ExceededQuota                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi500ServerError                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-vapi-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineNoAvailableModel                                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-no-available-model"
	ServerMessageEndOfCallReportEndedReasonWorkerShutdown                                                                             ServerMessageEndOfCallReportEndedReason = "worker-shutdown"
	ServerMessageEndOfCallReportEndedReasonUnknownError                                                                               ServerMessageEndOfCallReportEndedReason = "unknown-error"
	ServerMessageEndOfCallReportEndedReasonVonageDisconnected                                                                         ServerMessageEndOfCallReportEndedReason = "vonage-disconnected"
	ServerMessageEndOfCallReportEndedReasonVonageFailedToConnectCall                                                                  ServerMessageEndOfCallReportEndedReason = "vonage-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived                                            ServerMessageEndOfCallReportEndedReason = "phone-call-provider-bypass-enabled-but-no-call-received"
	ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerSetupSocketError                                                   ServerMessageEndOfCallReportEndedReason = "vapifault-phone-call-worker-setup-socket-error"
	ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout                                           ServerMessageEndOfCallReportEndedReason = "vapifault-phone-call-worker-worker-setup-socket-timeout"
	ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall                                                   ServerMessageEndOfCallReportEndedReason = "vapifault-phone-call-worker-could-not-find-call"
	ServerMessageEndOfCallReportEndedReasonVapifaultTransportNeverConnected                                                           ServerMessageEndOfCallReportEndedReason = "vapifault-transport-never-connected"
	ServerMessageEndOfCallReportEndedReasonVapifaultWebCallWorkerSetupFailed                                                          ServerMessageEndOfCallReportEndedReason = "vapifault-web-call-worker-setup-failed"
	ServerMessageEndOfCallReportEndedReasonVapifaultTransportConnectedButCallNotActive                                                ServerMessageEndOfCallReportEndedReason = "vapifault-transport-connected-but-call-not-active"
	ServerMessageEndOfCallReportEndedReasonVapifaultCallStartedButConnectionToTransportMissing                                        ServerMessageEndOfCallReportEndedReason = "vapifault-call-started-but-connection-to-transport-missing"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiLlmFailed                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenaiLlmFailed                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroqLlmFailed                                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogleLlmFailed                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXaiLlmFailed                                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAiLlmFailed                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebrasLlmFailed                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeekLlmFailed                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai400BadRequestValidationFailed                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401Unauthorized                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai403ModelAccessDenied                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai429ExceededQuota                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai500ServerError                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-openai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle400BadRequestValidationFailed                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle401Unauthorized                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle403ModelAccessDenied                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle429ExceededQuota                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle500ServerError                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-google-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai400BadRequestValidationFailed                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai401Unauthorized                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai403ModelAccessDenied                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai429ExceededQuota                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorXai500ServerError                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-xai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi400BadRequestValidationFailed                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi401Unauthorized                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi403ModelAccessDenied                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi429ExceededQuota                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi500ServerError                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-inflection-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek400BadRequestValidationFailed                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek401Unauthorized                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek403ModelAccessDenied                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek429ExceededQuota                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek500ServerError                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-deep-seek-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai401Unauthorized                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai429ExceededQuota                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai500ServerError                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-azure-openai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq400BadRequestValidationFailed                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq401Unauthorized                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq403ModelAccessDenied                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq429ExceededQuota                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq500ServerError                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-groq-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras400BadRequestValidationFailed                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras401Unauthorized                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras403ModelAccessDenied                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras429ExceededQuota                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras500ServerError                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-cerebras-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic401Unauthorized                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic403ModelAccessDenied                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic429ExceededQuota                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic500ServerError                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicLlmFailed                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-anthropic-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi401Unauthorized                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi403ModelAccessDenied                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi429ExceededQuota                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi500ServerError                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAiLlmFailed                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-together-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale401Unauthorized                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale403ModelAccessDenied                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale429ExceededQuota                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale500ServerError                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscaleLlmFailed                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-anyscale-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter401Unauthorized                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter403ModelAccessDenied                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter429ExceededQuota                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter500ServerError                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouterLlmFailed                                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-openrouter-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi401Unauthorized                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi429ExceededQuota                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi500ServerError                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAiLlmFailed                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-perplexity-ai-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra401Unauthorized                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra403ModelAccessDenied                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra429ExceededQuota                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra500ServerError                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfraLlmFailed                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepinfra-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod400BadRequestValidationFailed                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod401Unauthorized                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod403ModelAccessDenied                                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod429ExceededQuota                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod500ServerError                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpodLlmFailed                                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-runpod-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-400-bad-request-validation-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm401Unauthorized                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm403ModelAccessDenied                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm429ExceededQuota                                                     ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm500ServerError                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlmLlmFailed                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-llm-llm-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomVoiceFailed                                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-voice-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaSocketHangUp                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-socket-hang-up"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaRequestedPayment                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-requested-payment"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia500ServerError                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia503ServerError                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-503-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia522ServerError                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-cartesia-522-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFound                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-found"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsQuotaExceeded                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-quota-exceeded"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedAccess                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-unauthorized-access"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-unauthorized-to-access-model"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-system-busy-and-requested-upgrade"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned                                                   ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidApiKey                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-invalid-api-key"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples                                                 ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-invalid-voice-samples"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner                                                ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-disabled-by-owner"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-account-in-probation"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-content-against-their-policy"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-missing-samples-for-voice-clone"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-voice-not-allowed-for-free-users"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabs500ServerError                                                      ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-500-server-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded                                           ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-max-character-limit-exceeded"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification ServerMessageEndOfCallReportEndedReason = "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtRequestTimedOut                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-request-timed-out"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidVoice                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-invalid-voice"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtUnexpectedError                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-unexpected-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtOutOfCredits                                                            ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-out-of-credits"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidEmotion                                                          ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-invalid-emotion"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht401Unauthorized                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-401-unauthorized"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters                                             ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-403-forbidden-out-of-characters"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-403-forbidden-api-access-not-available"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht429ExceededQuota                                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-429-exceeded-quota"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht502GatewayError                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-502-gateway-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht504GatewayError                                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-playht-504-gateway-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorTavusVideoFailed                                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-tavus-video-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomTranscriberFailed                                                       ServerMessageEndOfCallReportEndedReason = "pipeline-error-custom-transcriber-failed"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning403ModelAccessDenied                                         ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-403-model-access-denied"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning401InvalidCredentials                                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-401-invalid-credentials"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning404NotFound                                                  ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-404-not-found"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning400NoSuchModelLanguageTierCombination                        ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning500InvalidJson                                               ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-500-invalid-json"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning502NetworkError                                              ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-502-network-error"
	ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning502BadGatewayEhostunreach                                    ServerMessageEndOfCallReportEndedReason = "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach"
	ServerMessageEndOfCallReportEndedReasonSilenceTimedOut                                                                            ServerMessageEndOfCallReportEndedReason = "silence-timed-out"
	ServerMessageEndOfCallReportEndedReasonSipGatewayFailedToConnectCall                                                              ServerMessageEndOfCallReportEndedReason = "sip-gateway-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonTwilioFailedToConnectCall                                                                  ServerMessageEndOfCallReportEndedReason = "twilio-failed-to-connect-call"
	ServerMessageEndOfCallReportEndedReasonTwilioReportedCustomerMisdialed                                                            ServerMessageEndOfCallReportEndedReason = "twilio-reported-customer-misdialed"
	ServerMessageEndOfCallReportEndedReasonVonageRejected                                                                             ServerMessageEndOfCallReportEndedReason = "vonage-rejected"
	ServerMessageEndOfCallReportEndedReasonVoicemail                                                                                  ServerMessageEndOfCallReportEndedReason = "voicemail"
)

func NewServerMessageEndOfCallReportEndedReasonFromString(s string) (ServerMessageEndOfCallReportEndedReason, error) {
	switch s {
	case "assistant-not-invalid":
		return ServerMessageEndOfCallReportEndedReasonAssistantNotInvalid, nil
	case "assistant-not-provided":
		return ServerMessageEndOfCallReportEndedReasonAssistantNotProvided, nil
	case "call-start-error-neither-assistant-nor-server-set":
		return ServerMessageEndOfCallReportEndedReasonCallStartErrorNeitherAssistantNorServerSet, nil
	case "assistant-request-failed":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestFailed, nil
	case "assistant-request-returned-error":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedError, nil
	case "assistant-request-returned-unspeakable-error":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedUnspeakableError, nil
	case "assistant-request-returned-invalid-assistant":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedInvalidAssistant, nil
	case "assistant-request-returned-no-assistant":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedNoAssistant, nil
	case "assistant-request-returned-forwarding-phone-number":
		return ServerMessageEndOfCallReportEndedReasonAssistantRequestReturnedForwardingPhoneNumber, nil
	case "assistant-ended-call":
		return ServerMessageEndOfCallReportEndedReasonAssistantEndedCall, nil
	case "assistant-said-end-call-phrase":
		return ServerMessageEndOfCallReportEndedReasonAssistantSaidEndCallPhrase, nil
	case "assistant-forwarded-call":
		return ServerMessageEndOfCallReportEndedReasonAssistantForwardedCall, nil
	case "assistant-join-timed-out":
		return ServerMessageEndOfCallReportEndedReasonAssistantJoinTimedOut, nil
	case "customer-busy":
		return ServerMessageEndOfCallReportEndedReasonCustomerBusy, nil
	case "customer-ended-call":
		return ServerMessageEndOfCallReportEndedReasonCustomerEndedCall, nil
	case "customer-did-not-answer":
		return ServerMessageEndOfCallReportEndedReasonCustomerDidNotAnswer, nil
	case "customer-did-not-give-microphone-permission":
		return ServerMessageEndOfCallReportEndedReasonCustomerDidNotGiveMicrophonePermission, nil
	case "assistant-said-message-with-end-call-enabled":
		return ServerMessageEndOfCallReportEndedReasonAssistantSaidMessageWithEndCallEnabled, nil
	case "exceeded-max-duration":
		return ServerMessageEndOfCallReportEndedReasonExceededMaxDuration, nil
	case "manually-canceled":
		return ServerMessageEndOfCallReportEndedReasonManuallyCanceled, nil
	case "phone-call-provider-closed-websocket":
		return ServerMessageEndOfCallReportEndedReasonPhoneCallProviderClosedWebsocket, nil
	case "db-error":
		return ServerMessageEndOfCallReportEndedReasonDbError, nil
	case "assistant-not-found":
		return ServerMessageEndOfCallReportEndedReasonAssistantNotFound, nil
	case "license-check-failed":
		return ServerMessageEndOfCallReportEndedReasonLicenseCheckFailed, nil
	case "pipeline-error-openai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiVoiceFailed, nil
	case "pipeline-error-cartesia-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaVoiceFailed, nil
	case "pipeline-error-deepgram-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramVoiceFailed, nil
	case "pipeline-error-eleven-labs-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceFailed, nil
	case "pipeline-error-playht-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceFailed, nil
	case "pipeline-error-lmnt-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorLmntVoiceFailed, nil
	case "pipeline-error-azure-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureVoiceFailed, nil
	case "pipeline-error-rime-ai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRimeAiVoiceFailed, nil
	case "pipeline-error-neets-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorNeetsVoiceFailed, nil
	case "pipeline-error-smallest-ai-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorSmallestAiVoiceFailed, nil
	case "pipeline-error-deepgram-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramTranscriberFailed, nil
	case "pipeline-error-gladia-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGladiaTranscriberFailed, nil
	case "pipeline-error-assembly-ai-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAssemblyAiTranscriberFailed, nil
	case "pipeline-error-talkscriber-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTalkscriberTranscriberFailed, nil
	case "pipeline-error-azure-speech-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureSpeechTranscriberFailed, nil
	case "pipeline-error-vapi-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapiLlmFailed, nil
	case "pipeline-error-vapi-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi400BadRequestValidationFailed, nil
	case "pipeline-error-vapi-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi401Unauthorized, nil
	case "pipeline-error-vapi-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi403ModelAccessDenied, nil
	case "pipeline-error-vapi-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi429ExceededQuota, nil
	case "pipeline-error-vapi-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorVapi500ServerError, nil
	case "pipeline-no-available-model":
		return ServerMessageEndOfCallReportEndedReasonPipelineNoAvailableModel, nil
	case "worker-shutdown":
		return ServerMessageEndOfCallReportEndedReasonWorkerShutdown, nil
	case "unknown-error":
		return ServerMessageEndOfCallReportEndedReasonUnknownError, nil
	case "vonage-disconnected":
		return ServerMessageEndOfCallReportEndedReasonVonageDisconnected, nil
	case "vonage-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonVonageFailedToConnectCall, nil
	case "phone-call-provider-bypass-enabled-but-no-call-received":
		return ServerMessageEndOfCallReportEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived, nil
	case "vapifault-phone-call-worker-setup-socket-error":
		return ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerSetupSocketError, nil
	case "vapifault-phone-call-worker-worker-setup-socket-timeout":
		return ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout, nil
	case "vapifault-phone-call-worker-could-not-find-call":
		return ServerMessageEndOfCallReportEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall, nil
	case "vapifault-transport-never-connected":
		return ServerMessageEndOfCallReportEndedReasonVapifaultTransportNeverConnected, nil
	case "vapifault-web-call-worker-setup-failed":
		return ServerMessageEndOfCallReportEndedReasonVapifaultWebCallWorkerSetupFailed, nil
	case "vapifault-transport-connected-but-call-not-active":
		return ServerMessageEndOfCallReportEndedReasonVapifaultTransportConnectedButCallNotActive, nil
	case "vapifault-call-started-but-connection-to-transport-missing":
		return ServerMessageEndOfCallReportEndedReasonVapifaultCallStartedButConnectionToTransportMissing, nil
	case "pipeline-error-openai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenaiLlmFailed, nil
	case "pipeline-error-azure-openai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenaiLlmFailed, nil
	case "pipeline-error-groq-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroqLlmFailed, nil
	case "pipeline-error-google-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogleLlmFailed, nil
	case "pipeline-error-xai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXaiLlmFailed, nil
	case "pipeline-error-inflection-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAiLlmFailed, nil
	case "pipeline-error-cerebras-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebrasLlmFailed, nil
	case "pipeline-error-deep-seek-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeekLlmFailed, nil
	case "pipeline-error-openai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-openai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai401Unauthorized, nil
	case "pipeline-error-openai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai403ModelAccessDenied, nil
	case "pipeline-error-openai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai429ExceededQuota, nil
	case "pipeline-error-openai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenai500ServerError, nil
	case "pipeline-error-google-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle400BadRequestValidationFailed, nil
	case "pipeline-error-google-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle401Unauthorized, nil
	case "pipeline-error-google-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle403ModelAccessDenied, nil
	case "pipeline-error-google-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle429ExceededQuota, nil
	case "pipeline-error-google-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGoogle500ServerError, nil
	case "pipeline-error-xai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai400BadRequestValidationFailed, nil
	case "pipeline-error-xai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai401Unauthorized, nil
	case "pipeline-error-xai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai403ModelAccessDenied, nil
	case "pipeline-error-xai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai429ExceededQuota, nil
	case "pipeline-error-xai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorXai500ServerError, nil
	case "pipeline-error-inflection-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi400BadRequestValidationFailed, nil
	case "pipeline-error-inflection-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi401Unauthorized, nil
	case "pipeline-error-inflection-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi403ModelAccessDenied, nil
	case "pipeline-error-inflection-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi429ExceededQuota, nil
	case "pipeline-error-inflection-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorInflectionAi500ServerError, nil
	case "pipeline-error-deep-seek-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek400BadRequestValidationFailed, nil
	case "pipeline-error-deep-seek-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek401Unauthorized, nil
	case "pipeline-error-deep-seek-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek403ModelAccessDenied, nil
	case "pipeline-error-deep-seek-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek429ExceededQuota, nil
	case "pipeline-error-deep-seek-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepSeek500ServerError, nil
	case "pipeline-error-azure-openai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-azure-openai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai401Unauthorized, nil
	case "pipeline-error-azure-openai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied, nil
	case "pipeline-error-azure-openai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai429ExceededQuota, nil
	case "pipeline-error-azure-openai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAzureOpenai500ServerError, nil
	case "pipeline-error-groq-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq400BadRequestValidationFailed, nil
	case "pipeline-error-groq-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq401Unauthorized, nil
	case "pipeline-error-groq-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq403ModelAccessDenied, nil
	case "pipeline-error-groq-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq429ExceededQuota, nil
	case "pipeline-error-groq-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorGroq500ServerError, nil
	case "pipeline-error-cerebras-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras400BadRequestValidationFailed, nil
	case "pipeline-error-cerebras-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras401Unauthorized, nil
	case "pipeline-error-cerebras-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras403ModelAccessDenied, nil
	case "pipeline-error-cerebras-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras429ExceededQuota, nil
	case "pipeline-error-cerebras-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCerebras500ServerError, nil
	case "pipeline-error-anthropic-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic401Unauthorized, nil
	case "pipeline-error-anthropic-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic403ModelAccessDenied, nil
	case "pipeline-error-anthropic-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic429ExceededQuota, nil
	case "pipeline-error-anthropic-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropic500ServerError, nil
	case "pipeline-error-anthropic-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnthropicLlmFailed, nil
	case "pipeline-error-together-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed, nil
	case "pipeline-error-together-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi401Unauthorized, nil
	case "pipeline-error-together-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi403ModelAccessDenied, nil
	case "pipeline-error-together-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi429ExceededQuota, nil
	case "pipeline-error-together-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAi500ServerError, nil
	case "pipeline-error-together-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTogetherAiLlmFailed, nil
	case "pipeline-error-anyscale-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed, nil
	case "pipeline-error-anyscale-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale401Unauthorized, nil
	case "pipeline-error-anyscale-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale403ModelAccessDenied, nil
	case "pipeline-error-anyscale-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale429ExceededQuota, nil
	case "pipeline-error-anyscale-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscale500ServerError, nil
	case "pipeline-error-anyscale-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorAnyscaleLlmFailed, nil
	case "pipeline-error-openrouter-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed, nil
	case "pipeline-error-openrouter-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter401Unauthorized, nil
	case "pipeline-error-openrouter-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter403ModelAccessDenied, nil
	case "pipeline-error-openrouter-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter429ExceededQuota, nil
	case "pipeline-error-openrouter-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouter500ServerError, nil
	case "pipeline-error-openrouter-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorOpenrouterLlmFailed, nil
	case "pipeline-error-perplexity-ai-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed, nil
	case "pipeline-error-perplexity-ai-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi401Unauthorized, nil
	case "pipeline-error-perplexity-ai-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied, nil
	case "pipeline-error-perplexity-ai-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi429ExceededQuota, nil
	case "pipeline-error-perplexity-ai-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAi500ServerError, nil
	case "pipeline-error-perplexity-ai-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPerplexityAiLlmFailed, nil
	case "pipeline-error-deepinfra-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed, nil
	case "pipeline-error-deepinfra-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra401Unauthorized, nil
	case "pipeline-error-deepinfra-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra403ModelAccessDenied, nil
	case "pipeline-error-deepinfra-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra429ExceededQuota, nil
	case "pipeline-error-deepinfra-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfra500ServerError, nil
	case "pipeline-error-deepinfra-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepinfraLlmFailed, nil
	case "pipeline-error-runpod-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod400BadRequestValidationFailed, nil
	case "pipeline-error-runpod-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod401Unauthorized, nil
	case "pipeline-error-runpod-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod403ModelAccessDenied, nil
	case "pipeline-error-runpod-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod429ExceededQuota, nil
	case "pipeline-error-runpod-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpod500ServerError, nil
	case "pipeline-error-runpod-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorRunpodLlmFailed, nil
	case "pipeline-error-custom-llm-400-bad-request-validation-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed, nil
	case "pipeline-error-custom-llm-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm401Unauthorized, nil
	case "pipeline-error-custom-llm-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm403ModelAccessDenied, nil
	case "pipeline-error-custom-llm-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm429ExceededQuota, nil
	case "pipeline-error-custom-llm-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlm500ServerError, nil
	case "pipeline-error-custom-llm-llm-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomLlmLlmFailed, nil
	case "pipeline-error-custom-voice-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomVoiceFailed, nil
	case "pipeline-error-cartesia-socket-hang-up":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaSocketHangUp, nil
	case "pipeline-error-cartesia-requested-payment":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesiaRequestedPayment, nil
	case "pipeline-error-cartesia-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia500ServerError, nil
	case "pipeline-error-cartesia-503-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia503ServerError, nil
	case "pipeline-error-cartesia-522-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCartesia522ServerError, nil
	case "pipeline-error-eleven-labs-voice-not-found":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFound, nil
	case "pipeline-error-eleven-labs-quota-exceeded":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsQuotaExceeded, nil
	case "pipeline-error-eleven-labs-unauthorized-access":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedAccess, nil
	case "pipeline-error-eleven-labs-unauthorized-to-access-model":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel, nil
	case "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-system-busy-and-requested-upgrade":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned, nil
	case "pipeline-error-eleven-labs-invalid-api-key":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidApiKey, nil
	case "pipeline-error-eleven-labs-invalid-voice-samples":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples, nil
	case "pipeline-error-eleven-labs-voice-disabled-by-owner":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner, nil
	case "pipeline-error-eleven-labs-blocked-account-in-probation":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation, nil
	case "pipeline-error-eleven-labs-blocked-content-against-their-policy":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "pipeline-error-eleven-labs-missing-samples-for-voice-clone":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "pipeline-error-eleven-labs-voice-not-allowed-for-free-users":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "pipeline-error-eleven-labs-500-server-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabs500ServerError, nil
	case "pipeline-error-eleven-labs-max-character-limit-exceeded":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded, nil
	case "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification, nil
	case "pipeline-error-playht-request-timed-out":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtRequestTimedOut, nil
	case "pipeline-error-playht-invalid-voice":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidVoice, nil
	case "pipeline-error-playht-unexpected-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtUnexpectedError, nil
	case "pipeline-error-playht-out-of-credits":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtOutOfCredits, nil
	case "pipeline-error-playht-invalid-emotion":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtInvalidEmotion, nil
	case "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "pipeline-error-playht-401-unauthorized":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht401Unauthorized, nil
	case "pipeline-error-playht-403-forbidden-out-of-characters":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters, nil
	case "pipeline-error-playht-403-forbidden-api-access-not-available":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable, nil
	case "pipeline-error-playht-429-exceeded-quota":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht429ExceededQuota, nil
	case "pipeline-error-playht-502-gateway-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht502GatewayError, nil
	case "pipeline-error-playht-504-gateway-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorPlayht504GatewayError, nil
	case "pipeline-error-tavus-video-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorTavusVideoFailed, nil
	case "pipeline-error-custom-transcriber-failed":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorCustomTranscriberFailed, nil
	case "pipeline-error-deepgram-returning-403-model-access-denied":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning403ModelAccessDenied, nil
	case "pipeline-error-deepgram-returning-401-invalid-credentials":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning401InvalidCredentials, nil
	case "pipeline-error-deepgram-returning-404-not-found":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning404NotFound, nil
	case "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning400NoSuchModelLanguageTierCombination, nil
	case "pipeline-error-deepgram-returning-500-invalid-json":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning500InvalidJson, nil
	case "pipeline-error-deepgram-returning-502-network-error":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning502NetworkError, nil
	case "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach":
		return ServerMessageEndOfCallReportEndedReasonPipelineErrorDeepgramReturning502BadGatewayEhostunreach, nil
	case "silence-timed-out":
		return ServerMessageEndOfCallReportEndedReasonSilenceTimedOut, nil
	case "sip-gateway-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonSipGatewayFailedToConnectCall, nil
	case "twilio-failed-to-connect-call":
		return ServerMessageEndOfCallReportEndedReasonTwilioFailedToConnectCall, nil
	case "twilio-reported-customer-misdialed":
		return ServerMessageEndOfCallReportEndedReasonTwilioReportedCustomerMisdialed, nil
	case "vonage-rejected":
		return ServerMessageEndOfCallReportEndedReasonVonageRejected, nil
	case "voicemail":
		return ServerMessageEndOfCallReportEndedReasonVoicemail, nil
	}
	var t ServerMessageEndOfCallReportEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageEndOfCallReportEndedReason) Ptr() *ServerMessageEndOfCallReportEndedReason {
	return &s
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageEndOfCallReportPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageEndOfCallReportPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageEndOfCallReportPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageEndOfCallReportPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageEndOfCallReportPhoneNumber) Accept(visitor ServerMessageEndOfCallReportPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageHang struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageHangPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "hang" is sent when the assistant is hanging due to a delay. The delay can be caused by many factors, such as:
	// - the model is too slow to respond
	// - the voice is too slow to respond
	// - the tool call is still waiting for a response from your server
	// - etc.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageHang) GetPhoneNumber() *ServerMessageHangPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageHang) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageHang) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageHang) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageHang) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageHang) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageHang) Type() string {
	return s.type_
}

func (s *ServerMessageHang) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageHang) UnmarshalJSON(data []byte) error {
	type embed ServerMessageHang
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageHang(unmarshaler.embed)
	if unmarshaler.Type != "hang" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "hang", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageHang) MarshalJSON() ([]byte, error) {
	type embed ServerMessageHang
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "hang",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageHang) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageHangPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageHangPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageHangPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageHangPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageHangPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageHangPhoneNumber) Accept(visitor ServerMessageHangPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageKnowledgeBaseRequest struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageKnowledgeBaseRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "knowledge-base-request" is sent to request knowledge base documents. To enable, use `assistant.knowledgeBase.provider=custom-knowledge-base`.
	// These are the messages that are going to be sent to the `model` right after the `knowledge-base-request` webhook completes.
	Messages []*ServerMessageKnowledgeBaseRequestMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// This is just `messages` formatted for OpenAI.
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageKnowledgeBaseRequest) GetPhoneNumber() *ServerMessageKnowledgeBaseRequestPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageKnowledgeBaseRequest) GetMessages() []*ServerMessageKnowledgeBaseRequestMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *ServerMessageKnowledgeBaseRequest) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if s == nil {
		return nil
	}
	return s.MessagesOpenAiFormatted
}

func (s *ServerMessageKnowledgeBaseRequest) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageKnowledgeBaseRequest) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageKnowledgeBaseRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageKnowledgeBaseRequest) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageKnowledgeBaseRequest) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageKnowledgeBaseRequest) Type() string {
	return s.type_
}

func (s *ServerMessageKnowledgeBaseRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageKnowledgeBaseRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageKnowledgeBaseRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageKnowledgeBaseRequest(unmarshaler.embed)
	if unmarshaler.Type != "knowledge-base-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "knowledge-base-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageKnowledgeBaseRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageKnowledgeBaseRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "knowledge-base-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageKnowledgeBaseRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageKnowledgeBaseRequestMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetUserMessage() *UserMessage {
	if s == nil {
		return nil
	}
	return s.UserMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetSystemMessage() *SystemMessage {
	if s == nil {
		return nil
	}
	return s.SystemMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetBotMessage() *BotMessage {
	if s == nil {
		return nil
	}
	return s.BotMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallResultMessage
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.typ = "UserMessage"
		s.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.typ = "SystemMessage"
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		s.typ = "BotMessage"
		s.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		s.typ = "ToolCallMessage"
		s.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		s.typ = "ToolCallResultMessage"
		s.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageKnowledgeBaseRequestMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return json.Marshal(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return json.Marshal(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return json.Marshal(s.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageKnowledgeBaseRequestMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (s *ServerMessageKnowledgeBaseRequestMessagesItem) Accept(visitor ServerMessageKnowledgeBaseRequestMessagesItemVisitor) error {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return visitor.VisitBotMessage(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(s.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageKnowledgeBaseRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageKnowledgeBaseRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageKnowledgeBaseRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageKnowledgeBaseRequestPhoneNumber) Accept(visitor ServerMessageKnowledgeBaseRequestPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageLanguageChangeDetected struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageLanguageChangeDetectedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "language-change-detected" is sent when the transcriber is automatically switched based on the detected language.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the language the transcriber is switched to.
	Language string `json:"language" url:"language"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageLanguageChangeDetected) GetPhoneNumber() *ServerMessageLanguageChangeDetectedPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageLanguageChangeDetected) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageLanguageChangeDetected) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageLanguageChangeDetected) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageLanguageChangeDetected) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageLanguageChangeDetected) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageLanguageChangeDetected) GetLanguage() string {
	if s == nil {
		return ""
	}
	return s.Language
}

func (s *ServerMessageLanguageChangeDetected) Type() string {
	return s.type_
}

func (s *ServerMessageLanguageChangeDetected) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageLanguageChangeDetected) UnmarshalJSON(data []byte) error {
	type embed ServerMessageLanguageChangeDetected
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageLanguageChangeDetected(unmarshaler.embed)
	if unmarshaler.Type != "language-change-detected" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "language-change-detected", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageLanguageChangeDetected) MarshalJSON() ([]byte, error) {
	type embed ServerMessageLanguageChangeDetected
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "language-change-detected",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageLanguageChangeDetected) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageLanguageChangeDetectedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageLanguageChangeDetectedPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageLanguageChangeDetectedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageLanguageChangeDetectedPhoneNumber) Accept(visitor ServerMessageLanguageChangeDetectedPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// These are all the messages that can be sent to your server before, after and during the call. Configure the messages you'd like to receive in `assistant.serverMessages`.
//
// The server where the message is sent is determined by the following precedence order:
//
// 1. `tool.server.url` (if configured, and only for "tool-calls" message)
// 2. `assistant.serverUrl` (if configure)
// 3. `phoneNumber.serverUrl` (if configured)
// 4. `org.serverUrl` (if configured)
type ServerMessageMessage struct {
	ServerMessageAssistantRequest           *ServerMessageAssistantRequest
	ServerMessageConversationUpdate         *ServerMessageConversationUpdate
	ServerMessageEndOfCallReport            *ServerMessageEndOfCallReport
	ServerMessageHang                       *ServerMessageHang
	ServerMessageKnowledgeBaseRequest       *ServerMessageKnowledgeBaseRequest
	ServerMessageModelOutput                *ServerMessageModelOutput
	ServerMessagePhoneCallControl           *ServerMessagePhoneCallControl
	ServerMessageSpeechUpdate               *ServerMessageSpeechUpdate
	ServerMessageStatusUpdate               *ServerMessageStatusUpdate
	ServerMessageToolCalls                  *ServerMessageToolCalls
	ServerMessageTransferDestinationRequest *ServerMessageTransferDestinationRequest
	ServerMessageTransferUpdate             *ServerMessageTransferUpdate
	ServerMessageTranscript                 *ServerMessageTranscript
	ServerMessageUserInterrupted            *ServerMessageUserInterrupted
	ServerMessageLanguageChangeDetected     *ServerMessageLanguageChangeDetected
	ServerMessageVoiceInput                 *ServerMessageVoiceInput
	ServerMessageVoiceRequest               *ServerMessageVoiceRequest

	typ string
}

func (s *ServerMessageMessage) GetServerMessageAssistantRequest() *ServerMessageAssistantRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageAssistantRequest
}

func (s *ServerMessageMessage) GetServerMessageConversationUpdate() *ServerMessageConversationUpdate {
	if s == nil {
		return nil
	}
	return s.ServerMessageConversationUpdate
}

func (s *ServerMessageMessage) GetServerMessageEndOfCallReport() *ServerMessageEndOfCallReport {
	if s == nil {
		return nil
	}
	return s.ServerMessageEndOfCallReport
}

func (s *ServerMessageMessage) GetServerMessageHang() *ServerMessageHang {
	if s == nil {
		return nil
	}
	return s.ServerMessageHang
}

func (s *ServerMessageMessage) GetServerMessageKnowledgeBaseRequest() *ServerMessageKnowledgeBaseRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageKnowledgeBaseRequest
}

func (s *ServerMessageMessage) GetServerMessageModelOutput() *ServerMessageModelOutput {
	if s == nil {
		return nil
	}
	return s.ServerMessageModelOutput
}

func (s *ServerMessageMessage) GetServerMessagePhoneCallControl() *ServerMessagePhoneCallControl {
	if s == nil {
		return nil
	}
	return s.ServerMessagePhoneCallControl
}

func (s *ServerMessageMessage) GetServerMessageSpeechUpdate() *ServerMessageSpeechUpdate {
	if s == nil {
		return nil
	}
	return s.ServerMessageSpeechUpdate
}

func (s *ServerMessageMessage) GetServerMessageStatusUpdate() *ServerMessageStatusUpdate {
	if s == nil {
		return nil
	}
	return s.ServerMessageStatusUpdate
}

func (s *ServerMessageMessage) GetServerMessageToolCalls() *ServerMessageToolCalls {
	if s == nil {
		return nil
	}
	return s.ServerMessageToolCalls
}

func (s *ServerMessageMessage) GetServerMessageTransferDestinationRequest() *ServerMessageTransferDestinationRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageTransferDestinationRequest
}

func (s *ServerMessageMessage) GetServerMessageTransferUpdate() *ServerMessageTransferUpdate {
	if s == nil {
		return nil
	}
	return s.ServerMessageTransferUpdate
}

func (s *ServerMessageMessage) GetServerMessageTranscript() *ServerMessageTranscript {
	if s == nil {
		return nil
	}
	return s.ServerMessageTranscript
}

func (s *ServerMessageMessage) GetServerMessageUserInterrupted() *ServerMessageUserInterrupted {
	if s == nil {
		return nil
	}
	return s.ServerMessageUserInterrupted
}

func (s *ServerMessageMessage) GetServerMessageLanguageChangeDetected() *ServerMessageLanguageChangeDetected {
	if s == nil {
		return nil
	}
	return s.ServerMessageLanguageChangeDetected
}

func (s *ServerMessageMessage) GetServerMessageVoiceInput() *ServerMessageVoiceInput {
	if s == nil {
		return nil
	}
	return s.ServerMessageVoiceInput
}

func (s *ServerMessageMessage) GetServerMessageVoiceRequest() *ServerMessageVoiceRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageVoiceRequest
}

func (s *ServerMessageMessage) UnmarshalJSON(data []byte) error {
	valueServerMessageAssistantRequest := new(ServerMessageAssistantRequest)
	if err := json.Unmarshal(data, &valueServerMessageAssistantRequest); err == nil {
		s.typ = "ServerMessageAssistantRequest"
		s.ServerMessageAssistantRequest = valueServerMessageAssistantRequest
		return nil
	}
	valueServerMessageConversationUpdate := new(ServerMessageConversationUpdate)
	if err := json.Unmarshal(data, &valueServerMessageConversationUpdate); err == nil {
		s.typ = "ServerMessageConversationUpdate"
		s.ServerMessageConversationUpdate = valueServerMessageConversationUpdate
		return nil
	}
	valueServerMessageEndOfCallReport := new(ServerMessageEndOfCallReport)
	if err := json.Unmarshal(data, &valueServerMessageEndOfCallReport); err == nil {
		s.typ = "ServerMessageEndOfCallReport"
		s.ServerMessageEndOfCallReport = valueServerMessageEndOfCallReport
		return nil
	}
	valueServerMessageHang := new(ServerMessageHang)
	if err := json.Unmarshal(data, &valueServerMessageHang); err == nil {
		s.typ = "ServerMessageHang"
		s.ServerMessageHang = valueServerMessageHang
		return nil
	}
	valueServerMessageKnowledgeBaseRequest := new(ServerMessageKnowledgeBaseRequest)
	if err := json.Unmarshal(data, &valueServerMessageKnowledgeBaseRequest); err == nil {
		s.typ = "ServerMessageKnowledgeBaseRequest"
		s.ServerMessageKnowledgeBaseRequest = valueServerMessageKnowledgeBaseRequest
		return nil
	}
	valueServerMessageModelOutput := new(ServerMessageModelOutput)
	if err := json.Unmarshal(data, &valueServerMessageModelOutput); err == nil {
		s.typ = "ServerMessageModelOutput"
		s.ServerMessageModelOutput = valueServerMessageModelOutput
		return nil
	}
	valueServerMessagePhoneCallControl := new(ServerMessagePhoneCallControl)
	if err := json.Unmarshal(data, &valueServerMessagePhoneCallControl); err == nil {
		s.typ = "ServerMessagePhoneCallControl"
		s.ServerMessagePhoneCallControl = valueServerMessagePhoneCallControl
		return nil
	}
	valueServerMessageSpeechUpdate := new(ServerMessageSpeechUpdate)
	if err := json.Unmarshal(data, &valueServerMessageSpeechUpdate); err == nil {
		s.typ = "ServerMessageSpeechUpdate"
		s.ServerMessageSpeechUpdate = valueServerMessageSpeechUpdate
		return nil
	}
	valueServerMessageStatusUpdate := new(ServerMessageStatusUpdate)
	if err := json.Unmarshal(data, &valueServerMessageStatusUpdate); err == nil {
		s.typ = "ServerMessageStatusUpdate"
		s.ServerMessageStatusUpdate = valueServerMessageStatusUpdate
		return nil
	}
	valueServerMessageToolCalls := new(ServerMessageToolCalls)
	if err := json.Unmarshal(data, &valueServerMessageToolCalls); err == nil {
		s.typ = "ServerMessageToolCalls"
		s.ServerMessageToolCalls = valueServerMessageToolCalls
		return nil
	}
	valueServerMessageTransferDestinationRequest := new(ServerMessageTransferDestinationRequest)
	if err := json.Unmarshal(data, &valueServerMessageTransferDestinationRequest); err == nil {
		s.typ = "ServerMessageTransferDestinationRequest"
		s.ServerMessageTransferDestinationRequest = valueServerMessageTransferDestinationRequest
		return nil
	}
	valueServerMessageTransferUpdate := new(ServerMessageTransferUpdate)
	if err := json.Unmarshal(data, &valueServerMessageTransferUpdate); err == nil {
		s.typ = "ServerMessageTransferUpdate"
		s.ServerMessageTransferUpdate = valueServerMessageTransferUpdate
		return nil
	}
	valueServerMessageTranscript := new(ServerMessageTranscript)
	if err := json.Unmarshal(data, &valueServerMessageTranscript); err == nil {
		s.typ = "ServerMessageTranscript"
		s.ServerMessageTranscript = valueServerMessageTranscript
		return nil
	}
	valueServerMessageUserInterrupted := new(ServerMessageUserInterrupted)
	if err := json.Unmarshal(data, &valueServerMessageUserInterrupted); err == nil {
		s.typ = "ServerMessageUserInterrupted"
		s.ServerMessageUserInterrupted = valueServerMessageUserInterrupted
		return nil
	}
	valueServerMessageLanguageChangeDetected := new(ServerMessageLanguageChangeDetected)
	if err := json.Unmarshal(data, &valueServerMessageLanguageChangeDetected); err == nil {
		s.typ = "ServerMessageLanguageChangeDetected"
		s.ServerMessageLanguageChangeDetected = valueServerMessageLanguageChangeDetected
		return nil
	}
	valueServerMessageVoiceInput := new(ServerMessageVoiceInput)
	if err := json.Unmarshal(data, &valueServerMessageVoiceInput); err == nil {
		s.typ = "ServerMessageVoiceInput"
		s.ServerMessageVoiceInput = valueServerMessageVoiceInput
		return nil
	}
	valueServerMessageVoiceRequest := new(ServerMessageVoiceRequest)
	if err := json.Unmarshal(data, &valueServerMessageVoiceRequest); err == nil {
		s.typ = "ServerMessageVoiceRequest"
		s.ServerMessageVoiceRequest = valueServerMessageVoiceRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageMessage) MarshalJSON() ([]byte, error) {
	if s.typ == "ServerMessageAssistantRequest" || s.ServerMessageAssistantRequest != nil {
		return json.Marshal(s.ServerMessageAssistantRequest)
	}
	if s.typ == "ServerMessageConversationUpdate" || s.ServerMessageConversationUpdate != nil {
		return json.Marshal(s.ServerMessageConversationUpdate)
	}
	if s.typ == "ServerMessageEndOfCallReport" || s.ServerMessageEndOfCallReport != nil {
		return json.Marshal(s.ServerMessageEndOfCallReport)
	}
	if s.typ == "ServerMessageHang" || s.ServerMessageHang != nil {
		return json.Marshal(s.ServerMessageHang)
	}
	if s.typ == "ServerMessageKnowledgeBaseRequest" || s.ServerMessageKnowledgeBaseRequest != nil {
		return json.Marshal(s.ServerMessageKnowledgeBaseRequest)
	}
	if s.typ == "ServerMessageModelOutput" || s.ServerMessageModelOutput != nil {
		return json.Marshal(s.ServerMessageModelOutput)
	}
	if s.typ == "ServerMessagePhoneCallControl" || s.ServerMessagePhoneCallControl != nil {
		return json.Marshal(s.ServerMessagePhoneCallControl)
	}
	if s.typ == "ServerMessageSpeechUpdate" || s.ServerMessageSpeechUpdate != nil {
		return json.Marshal(s.ServerMessageSpeechUpdate)
	}
	if s.typ == "ServerMessageStatusUpdate" || s.ServerMessageStatusUpdate != nil {
		return json.Marshal(s.ServerMessageStatusUpdate)
	}
	if s.typ == "ServerMessageToolCalls" || s.ServerMessageToolCalls != nil {
		return json.Marshal(s.ServerMessageToolCalls)
	}
	if s.typ == "ServerMessageTransferDestinationRequest" || s.ServerMessageTransferDestinationRequest != nil {
		return json.Marshal(s.ServerMessageTransferDestinationRequest)
	}
	if s.typ == "ServerMessageTransferUpdate" || s.ServerMessageTransferUpdate != nil {
		return json.Marshal(s.ServerMessageTransferUpdate)
	}
	if s.typ == "ServerMessageTranscript" || s.ServerMessageTranscript != nil {
		return json.Marshal(s.ServerMessageTranscript)
	}
	if s.typ == "ServerMessageUserInterrupted" || s.ServerMessageUserInterrupted != nil {
		return json.Marshal(s.ServerMessageUserInterrupted)
	}
	if s.typ == "ServerMessageLanguageChangeDetected" || s.ServerMessageLanguageChangeDetected != nil {
		return json.Marshal(s.ServerMessageLanguageChangeDetected)
	}
	if s.typ == "ServerMessageVoiceInput" || s.ServerMessageVoiceInput != nil {
		return json.Marshal(s.ServerMessageVoiceInput)
	}
	if s.typ == "ServerMessageVoiceRequest" || s.ServerMessageVoiceRequest != nil {
		return json.Marshal(s.ServerMessageVoiceRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageMessageVisitor interface {
	VisitServerMessageAssistantRequest(*ServerMessageAssistantRequest) error
	VisitServerMessageConversationUpdate(*ServerMessageConversationUpdate) error
	VisitServerMessageEndOfCallReport(*ServerMessageEndOfCallReport) error
	VisitServerMessageHang(*ServerMessageHang) error
	VisitServerMessageKnowledgeBaseRequest(*ServerMessageKnowledgeBaseRequest) error
	VisitServerMessageModelOutput(*ServerMessageModelOutput) error
	VisitServerMessagePhoneCallControl(*ServerMessagePhoneCallControl) error
	VisitServerMessageSpeechUpdate(*ServerMessageSpeechUpdate) error
	VisitServerMessageStatusUpdate(*ServerMessageStatusUpdate) error
	VisitServerMessageToolCalls(*ServerMessageToolCalls) error
	VisitServerMessageTransferDestinationRequest(*ServerMessageTransferDestinationRequest) error
	VisitServerMessageTransferUpdate(*ServerMessageTransferUpdate) error
	VisitServerMessageTranscript(*ServerMessageTranscript) error
	VisitServerMessageUserInterrupted(*ServerMessageUserInterrupted) error
	VisitServerMessageLanguageChangeDetected(*ServerMessageLanguageChangeDetected) error
	VisitServerMessageVoiceInput(*ServerMessageVoiceInput) error
	VisitServerMessageVoiceRequest(*ServerMessageVoiceRequest) error
}

func (s *ServerMessageMessage) Accept(visitor ServerMessageMessageVisitor) error {
	if s.typ == "ServerMessageAssistantRequest" || s.ServerMessageAssistantRequest != nil {
		return visitor.VisitServerMessageAssistantRequest(s.ServerMessageAssistantRequest)
	}
	if s.typ == "ServerMessageConversationUpdate" || s.ServerMessageConversationUpdate != nil {
		return visitor.VisitServerMessageConversationUpdate(s.ServerMessageConversationUpdate)
	}
	if s.typ == "ServerMessageEndOfCallReport" || s.ServerMessageEndOfCallReport != nil {
		return visitor.VisitServerMessageEndOfCallReport(s.ServerMessageEndOfCallReport)
	}
	if s.typ == "ServerMessageHang" || s.ServerMessageHang != nil {
		return visitor.VisitServerMessageHang(s.ServerMessageHang)
	}
	if s.typ == "ServerMessageKnowledgeBaseRequest" || s.ServerMessageKnowledgeBaseRequest != nil {
		return visitor.VisitServerMessageKnowledgeBaseRequest(s.ServerMessageKnowledgeBaseRequest)
	}
	if s.typ == "ServerMessageModelOutput" || s.ServerMessageModelOutput != nil {
		return visitor.VisitServerMessageModelOutput(s.ServerMessageModelOutput)
	}
	if s.typ == "ServerMessagePhoneCallControl" || s.ServerMessagePhoneCallControl != nil {
		return visitor.VisitServerMessagePhoneCallControl(s.ServerMessagePhoneCallControl)
	}
	if s.typ == "ServerMessageSpeechUpdate" || s.ServerMessageSpeechUpdate != nil {
		return visitor.VisitServerMessageSpeechUpdate(s.ServerMessageSpeechUpdate)
	}
	if s.typ == "ServerMessageStatusUpdate" || s.ServerMessageStatusUpdate != nil {
		return visitor.VisitServerMessageStatusUpdate(s.ServerMessageStatusUpdate)
	}
	if s.typ == "ServerMessageToolCalls" || s.ServerMessageToolCalls != nil {
		return visitor.VisitServerMessageToolCalls(s.ServerMessageToolCalls)
	}
	if s.typ == "ServerMessageTransferDestinationRequest" || s.ServerMessageTransferDestinationRequest != nil {
		return visitor.VisitServerMessageTransferDestinationRequest(s.ServerMessageTransferDestinationRequest)
	}
	if s.typ == "ServerMessageTransferUpdate" || s.ServerMessageTransferUpdate != nil {
		return visitor.VisitServerMessageTransferUpdate(s.ServerMessageTransferUpdate)
	}
	if s.typ == "ServerMessageTranscript" || s.ServerMessageTranscript != nil {
		return visitor.VisitServerMessageTranscript(s.ServerMessageTranscript)
	}
	if s.typ == "ServerMessageUserInterrupted" || s.ServerMessageUserInterrupted != nil {
		return visitor.VisitServerMessageUserInterrupted(s.ServerMessageUserInterrupted)
	}
	if s.typ == "ServerMessageLanguageChangeDetected" || s.ServerMessageLanguageChangeDetected != nil {
		return visitor.VisitServerMessageLanguageChangeDetected(s.ServerMessageLanguageChangeDetected)
	}
	if s.typ == "ServerMessageVoiceInput" || s.ServerMessageVoiceInput != nil {
		return visitor.VisitServerMessageVoiceInput(s.ServerMessageVoiceInput)
	}
	if s.typ == "ServerMessageVoiceRequest" || s.ServerMessageVoiceRequest != nil {
		return visitor.VisitServerMessageVoiceRequest(s.ServerMessageVoiceRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageModelOutput struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageModelOutputPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "model-output" is sent as the model outputs tokens.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the output of the model. It can be a token or tool call.
	Output map[string]interface{} `json:"output,omitempty" url:"output,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageModelOutput) GetPhoneNumber() *ServerMessageModelOutputPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageModelOutput) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageModelOutput) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageModelOutput) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageModelOutput) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageModelOutput) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageModelOutput) GetOutput() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Output
}

func (s *ServerMessageModelOutput) Type() string {
	return s.type_
}

func (s *ServerMessageModelOutput) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageModelOutput) UnmarshalJSON(data []byte) error {
	type embed ServerMessageModelOutput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageModelOutput(unmarshaler.embed)
	if unmarshaler.Type != "model-output" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "model-output", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageModelOutput) MarshalJSON() ([]byte, error) {
	type embed ServerMessageModelOutput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "model-output",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageModelOutput) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageModelOutputPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageModelOutputPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageModelOutputPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageModelOutputPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageModelOutputPhoneNumber) Accept(visitor ServerMessageModelOutputPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControl struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessagePhoneCallControlPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "phone-call-control" is an advanced type of message.
	//
	// When it is requested in `assistant.serverMessages`, the hangup and forwarding responsibilities are delegated to your server. Vapi will no longer do the actual transfer and hangup.
	// This is the request to control the phone call.
	Request ServerMessagePhoneCallControlRequest `json:"request" url:"request"`
	// This is the destination to forward the call to if the request is "forward".
	Destination *ServerMessagePhoneCallControlDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessagePhoneCallControl) GetPhoneNumber() *ServerMessagePhoneCallControlPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessagePhoneCallControl) GetRequest() ServerMessagePhoneCallControlRequest {
	if s == nil {
		return ""
	}
	return s.Request
}

func (s *ServerMessagePhoneCallControl) GetDestination() *ServerMessagePhoneCallControlDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessagePhoneCallControl) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessagePhoneCallControl) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessagePhoneCallControl) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessagePhoneCallControl) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessagePhoneCallControl) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessagePhoneCallControl) Type() string {
	return s.type_
}

func (s *ServerMessagePhoneCallControl) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessagePhoneCallControl) UnmarshalJSON(data []byte) error {
	type embed ServerMessagePhoneCallControl
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessagePhoneCallControl(unmarshaler.embed)
	if unmarshaler.Type != "phone-call-control" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "phone-call-control", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessagePhoneCallControl) MarshalJSON() ([]byte, error) {
	type embed ServerMessagePhoneCallControl
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "phone-call-control",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessagePhoneCallControl) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination to forward the call to if the request is "forward".
type ServerMessagePhoneCallControlDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (s *ServerMessagePhoneCallControlDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessagePhoneCallControlDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessagePhoneCallControlDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessagePhoneCallControlDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControlDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessagePhoneCallControlDestination) Accept(visitor ServerMessagePhoneCallControlDestinationVisitor) error {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessagePhoneCallControlPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessagePhoneCallControlPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessagePhoneCallControlPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessagePhoneCallControlPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessagePhoneCallControlPhoneNumber) Accept(visitor ServerMessagePhoneCallControlPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the request to control the phone call.
type ServerMessagePhoneCallControlRequest string

const (
	ServerMessagePhoneCallControlRequestForward ServerMessagePhoneCallControlRequest = "forward"
	ServerMessagePhoneCallControlRequestHangUp  ServerMessagePhoneCallControlRequest = "hang-up"
)

func NewServerMessagePhoneCallControlRequestFromString(s string) (ServerMessagePhoneCallControlRequest, error) {
	switch s {
	case "forward":
		return ServerMessagePhoneCallControlRequestForward, nil
	case "hang-up":
		return ServerMessagePhoneCallControlRequestHangUp, nil
	}
	var t ServerMessagePhoneCallControlRequest
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessagePhoneCallControlRequest) Ptr() *ServerMessagePhoneCallControlRequest {
	return &s
}

type ServerMessageResponse struct {
	// This is the response that is expected from the server to the message.
	//
	// Note: Most messages don't expect a response. Only "assistant-request", "tool-calls" and "transfer-destination-request" do.
	MessageResponse *ServerMessageResponseMessageResponse `json:"messageResponse,omitempty" url:"messageResponse,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponse) GetMessageResponse() *ServerMessageResponseMessageResponse {
	if s == nil {
		return nil
	}
	return s.MessageResponse
}

func (s *ServerMessageResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageResponseAssistantRequest struct {
	// This is the destination to transfer the inbound call to. This will immediately transfer without using any assistants.
	//
	// If this is sent, `assistantId`, `assistant`, `squadId`, and `squad` are ignored.
	Destination *ServerMessageResponseAssistantRequestDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	//
	// If you're unsure why you're getting an invalid assistant, try logging your response and send the JSON blob to POST /assistant which will return the validation errors.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// These are the overrides for the `assistant` or `assistantId`'s settings and template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// This is the squad that will be used for the call. To use a transient squad, use `squad` instead.
	SquadId *string `json:"squadId,omitempty" url:"squadId,omitempty"`
	// This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.
	Squad *CreateSquadDto `json:"squad,omitempty" url:"squad,omitempty"`
	// This is the error if the call shouldn't be accepted. This is spoken to the customer.
	//
	// If this is sent, `assistantId`, `assistant`, `squadId`, `squad`, and `destination` are ignored.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseAssistantRequest) GetDestination() *ServerMessageResponseAssistantRequestDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessageResponseAssistantRequest) GetAssistantId() *string {
	if s == nil {
		return nil
	}
	return s.AssistantId
}

func (s *ServerMessageResponseAssistantRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageResponseAssistantRequest) GetAssistantOverrides() *AssistantOverrides {
	if s == nil {
		return nil
	}
	return s.AssistantOverrides
}

func (s *ServerMessageResponseAssistantRequest) GetSquadId() *string {
	if s == nil {
		return nil
	}
	return s.SquadId
}

func (s *ServerMessageResponseAssistantRequest) GetSquad() *CreateSquadDto {
	if s == nil {
		return nil
	}
	return s.Squad
}

func (s *ServerMessageResponseAssistantRequest) GetError() *string {
	if s == nil {
		return nil
	}
	return s.Error
}

func (s *ServerMessageResponseAssistantRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseAssistantRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseAssistantRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseAssistantRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseAssistantRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination to transfer the inbound call to. This will immediately transfer without using any assistants.
//
// If this is sent, `assistantId`, `assistant`, `squadId`, and `squad` are ignored.
type ServerMessageResponseAssistantRequestDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (s *ServerMessageResponseAssistantRequestDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessageResponseAssistantRequestDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessageResponseAssistantRequestDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseAssistantRequestDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseAssistantRequestDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageResponseAssistantRequestDestination) Accept(visitor ServerMessageResponseAssistantRequestDestinationVisitor) error {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseKnowledgeBaseRequest struct {
	// This is the list of documents that will be sent to the model alongside the `messages` to generate a response.
	Documents []*KnowledgeBaseResponseDocument `json:"documents,omitempty" url:"documents,omitempty"`
	// This can be used to skip the model output generation and speak a custom message.
	Message *CustomMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseKnowledgeBaseRequest) GetDocuments() []*KnowledgeBaseResponseDocument {
	if s == nil {
		return nil
	}
	return s.Documents
}

func (s *ServerMessageResponseKnowledgeBaseRequest) GetMessage() *CustomMessage {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *ServerMessageResponseKnowledgeBaseRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseKnowledgeBaseRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseKnowledgeBaseRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseKnowledgeBaseRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseKnowledgeBaseRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the response that is expected from the server to the message.
//
// Note: Most messages don't expect a response. Only "assistant-request", "tool-calls" and "transfer-destination-request" do.
type ServerMessageResponseMessageResponse struct {
	ServerMessageResponseAssistantRequest           *ServerMessageResponseAssistantRequest
	ServerMessageResponseKnowledgeBaseRequest       *ServerMessageResponseKnowledgeBaseRequest
	ServerMessageResponseToolCalls                  *ServerMessageResponseToolCalls
	ServerMessageResponseTransferDestinationRequest *ServerMessageResponseTransferDestinationRequest
	ServerMessageResponseVoiceRequest               *ServerMessageResponseVoiceRequest

	typ string
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseAssistantRequest() *ServerMessageResponseAssistantRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseAssistantRequest
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseKnowledgeBaseRequest() *ServerMessageResponseKnowledgeBaseRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseKnowledgeBaseRequest
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseToolCalls() *ServerMessageResponseToolCalls {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseToolCalls
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseTransferDestinationRequest() *ServerMessageResponseTransferDestinationRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseTransferDestinationRequest
}

func (s *ServerMessageResponseMessageResponse) GetServerMessageResponseVoiceRequest() *ServerMessageResponseVoiceRequest {
	if s == nil {
		return nil
	}
	return s.ServerMessageResponseVoiceRequest
}

func (s *ServerMessageResponseMessageResponse) UnmarshalJSON(data []byte) error {
	valueServerMessageResponseAssistantRequest := new(ServerMessageResponseAssistantRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseAssistantRequest); err == nil {
		s.typ = "ServerMessageResponseAssistantRequest"
		s.ServerMessageResponseAssistantRequest = valueServerMessageResponseAssistantRequest
		return nil
	}
	valueServerMessageResponseKnowledgeBaseRequest := new(ServerMessageResponseKnowledgeBaseRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseKnowledgeBaseRequest); err == nil {
		s.typ = "ServerMessageResponseKnowledgeBaseRequest"
		s.ServerMessageResponseKnowledgeBaseRequest = valueServerMessageResponseKnowledgeBaseRequest
		return nil
	}
	valueServerMessageResponseToolCalls := new(ServerMessageResponseToolCalls)
	if err := json.Unmarshal(data, &valueServerMessageResponseToolCalls); err == nil {
		s.typ = "ServerMessageResponseToolCalls"
		s.ServerMessageResponseToolCalls = valueServerMessageResponseToolCalls
		return nil
	}
	valueServerMessageResponseTransferDestinationRequest := new(ServerMessageResponseTransferDestinationRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseTransferDestinationRequest); err == nil {
		s.typ = "ServerMessageResponseTransferDestinationRequest"
		s.ServerMessageResponseTransferDestinationRequest = valueServerMessageResponseTransferDestinationRequest
		return nil
	}
	valueServerMessageResponseVoiceRequest := new(ServerMessageResponseVoiceRequest)
	if err := json.Unmarshal(data, &valueServerMessageResponseVoiceRequest); err == nil {
		s.typ = "ServerMessageResponseVoiceRequest"
		s.ServerMessageResponseVoiceRequest = valueServerMessageResponseVoiceRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseMessageResponse) MarshalJSON() ([]byte, error) {
	if s.typ == "ServerMessageResponseAssistantRequest" || s.ServerMessageResponseAssistantRequest != nil {
		return json.Marshal(s.ServerMessageResponseAssistantRequest)
	}
	if s.typ == "ServerMessageResponseKnowledgeBaseRequest" || s.ServerMessageResponseKnowledgeBaseRequest != nil {
		return json.Marshal(s.ServerMessageResponseKnowledgeBaseRequest)
	}
	if s.typ == "ServerMessageResponseToolCalls" || s.ServerMessageResponseToolCalls != nil {
		return json.Marshal(s.ServerMessageResponseToolCalls)
	}
	if s.typ == "ServerMessageResponseTransferDestinationRequest" || s.ServerMessageResponseTransferDestinationRequest != nil {
		return json.Marshal(s.ServerMessageResponseTransferDestinationRequest)
	}
	if s.typ == "ServerMessageResponseVoiceRequest" || s.ServerMessageResponseVoiceRequest != nil {
		return json.Marshal(s.ServerMessageResponseVoiceRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseMessageResponseVisitor interface {
	VisitServerMessageResponseAssistantRequest(*ServerMessageResponseAssistantRequest) error
	VisitServerMessageResponseKnowledgeBaseRequest(*ServerMessageResponseKnowledgeBaseRequest) error
	VisitServerMessageResponseToolCalls(*ServerMessageResponseToolCalls) error
	VisitServerMessageResponseTransferDestinationRequest(*ServerMessageResponseTransferDestinationRequest) error
	VisitServerMessageResponseVoiceRequest(*ServerMessageResponseVoiceRequest) error
}

func (s *ServerMessageResponseMessageResponse) Accept(visitor ServerMessageResponseMessageResponseVisitor) error {
	if s.typ == "ServerMessageResponseAssistantRequest" || s.ServerMessageResponseAssistantRequest != nil {
		return visitor.VisitServerMessageResponseAssistantRequest(s.ServerMessageResponseAssistantRequest)
	}
	if s.typ == "ServerMessageResponseKnowledgeBaseRequest" || s.ServerMessageResponseKnowledgeBaseRequest != nil {
		return visitor.VisitServerMessageResponseKnowledgeBaseRequest(s.ServerMessageResponseKnowledgeBaseRequest)
	}
	if s.typ == "ServerMessageResponseToolCalls" || s.ServerMessageResponseToolCalls != nil {
		return visitor.VisitServerMessageResponseToolCalls(s.ServerMessageResponseToolCalls)
	}
	if s.typ == "ServerMessageResponseTransferDestinationRequest" || s.ServerMessageResponseTransferDestinationRequest != nil {
		return visitor.VisitServerMessageResponseTransferDestinationRequest(s.ServerMessageResponseTransferDestinationRequest)
	}
	if s.typ == "ServerMessageResponseVoiceRequest" || s.ServerMessageResponseVoiceRequest != nil {
		return visitor.VisitServerMessageResponseVoiceRequest(s.ServerMessageResponseVoiceRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseToolCalls struct {
	// These are the results of the "tool-calls" message.
	Results []*ToolCallResult `json:"results,omitempty" url:"results,omitempty"`
	// This is the error message if the tool call was not successful.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseToolCalls) GetResults() []*ToolCallResult {
	if s == nil {
		return nil
	}
	return s.Results
}

func (s *ServerMessageResponseToolCalls) GetError() *string {
	if s == nil {
		return nil
	}
	return s.Error
}

func (s *ServerMessageResponseToolCalls) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseToolCalls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseToolCalls) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageResponseTransferDestinationRequest struct {
	// This is the destination you'd like the call to be transferred to.
	Destination *ServerMessageResponseTransferDestinationRequestDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the error message if the transfer should not be made.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseTransferDestinationRequest) GetDestination() *ServerMessageResponseTransferDestinationRequestDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessageResponseTransferDestinationRequest) GetError() *string {
	if s == nil {
		return nil
	}
	return s.Error
}

func (s *ServerMessageResponseTransferDestinationRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseTransferDestinationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseTransferDestinationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseTransferDestinationRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseTransferDestinationRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination you'd like the call to be transferred to.
type ServerMessageResponseTransferDestinationRequestDestination struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationStep      *TransferDestinationStep
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if s == nil {
		return nil
	}
	return s.TransferDestinationAssistant
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) GetTransferDestinationStep() *TransferDestinationStep {
	if s == nil {
		return nil
	}
	return s.TransferDestinationStep
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		s.typ = "TransferDestinationAssistant"
		s.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationStep := new(TransferDestinationStep)
	if err := json.Unmarshal(data, &valueTransferDestinationStep); err == nil {
		s.typ = "TransferDestinationStep"
		s.TransferDestinationStep = valueTransferDestinationStep
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageResponseTransferDestinationRequestDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationAssistant" || s.TransferDestinationAssistant != nil {
		return json.Marshal(s.TransferDestinationAssistant)
	}
	if s.typ == "TransferDestinationStep" || s.TransferDestinationStep != nil {
		return json.Marshal(s.TransferDestinationStep)
	}
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseTransferDestinationRequestDestinationVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationStep(*TransferDestinationStep) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageResponseTransferDestinationRequestDestination) Accept(visitor ServerMessageResponseTransferDestinationRequestDestinationVisitor) error {
	if s.typ == "TransferDestinationAssistant" || s.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(s.TransferDestinationAssistant)
	}
	if s.typ == "TransferDestinationStep" || s.TransferDestinationStep != nil {
		return visitor.VisitTransferDestinationStep(s.TransferDestinationStep)
	}
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageResponseVoiceRequest struct {
	// DO NOT respond to a `voice-request` webhook with this schema of { data }. This schema just exists to document what the response should look like. Follow these instructions:
	//
	// Here is what the request will look like:
	//
	// POST https://{assistant.voice.server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "messsage": {
	//	    "type": "voice-request",
	//	    "text": "Hello, world!",
	//	    "sampleRate": 24000,
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// The expected response is 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	Data string `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageResponseVoiceRequest) GetData() string {
	if s == nil {
		return ""
	}
	return s.Data
}

func (s *ServerMessageResponseVoiceRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageResponseVoiceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageResponseVoiceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageResponseVoiceRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageResponseVoiceRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServerMessageSpeechUpdate struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageSpeechUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "speech-update" is sent whenever assistant or user start or stop speaking.
	// This is the status of the speech update.
	Status ServerMessageSpeechUpdateStatus `json:"status" url:"status"`
	// This is the role which the speech update is for.
	Role ServerMessageSpeechUpdateRole `json:"role" url:"role"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageSpeechUpdate) GetPhoneNumber() *ServerMessageSpeechUpdatePhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageSpeechUpdate) GetStatus() ServerMessageSpeechUpdateStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *ServerMessageSpeechUpdate) GetRole() ServerMessageSpeechUpdateRole {
	if s == nil {
		return ""
	}
	return s.Role
}

func (s *ServerMessageSpeechUpdate) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageSpeechUpdate) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageSpeechUpdate) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageSpeechUpdate) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageSpeechUpdate) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageSpeechUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageSpeechUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageSpeechUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageSpeechUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageSpeechUpdate(unmarshaler.embed)
	if unmarshaler.Type != "speech-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "speech-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageSpeechUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageSpeechUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "speech-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageSpeechUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageSpeechUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageSpeechUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageSpeechUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageSpeechUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageSpeechUpdatePhoneNumber) Accept(visitor ServerMessageSpeechUpdatePhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the role which the speech update is for.
type ServerMessageSpeechUpdateRole string

const (
	ServerMessageSpeechUpdateRoleAssistant ServerMessageSpeechUpdateRole = "assistant"
	ServerMessageSpeechUpdateRoleUser      ServerMessageSpeechUpdateRole = "user"
)

func NewServerMessageSpeechUpdateRoleFromString(s string) (ServerMessageSpeechUpdateRole, error) {
	switch s {
	case "assistant":
		return ServerMessageSpeechUpdateRoleAssistant, nil
	case "user":
		return ServerMessageSpeechUpdateRoleUser, nil
	}
	var t ServerMessageSpeechUpdateRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageSpeechUpdateRole) Ptr() *ServerMessageSpeechUpdateRole {
	return &s
}

// This is the status of the speech update.
type ServerMessageSpeechUpdateStatus string

const (
	ServerMessageSpeechUpdateStatusStarted ServerMessageSpeechUpdateStatus = "started"
	ServerMessageSpeechUpdateStatusStopped ServerMessageSpeechUpdateStatus = "stopped"
)

func NewServerMessageSpeechUpdateStatusFromString(s string) (ServerMessageSpeechUpdateStatus, error) {
	switch s {
	case "started":
		return ServerMessageSpeechUpdateStatusStarted, nil
	case "stopped":
		return ServerMessageSpeechUpdateStatusStopped, nil
	}
	var t ServerMessageSpeechUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageSpeechUpdateStatus) Ptr() *ServerMessageSpeechUpdateStatus {
	return &s
}

type ServerMessageStatusUpdate struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageStatusUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "status-update" is sent whenever the `call.status` changes.
	// This is the status of the call.
	Status ServerMessageStatusUpdateStatus `json:"status" url:"status"`
	// This is the reason the call ended. This is only sent if the status is "ended".
	EndedReason *ServerMessageStatusUpdateEndedReason `json:"endedReason,omitempty" url:"endedReason,omitempty"`
	// These are the conversation messages of the call. This is only sent if the status is "forwarding".
	Messages []*ServerMessageStatusUpdateMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the conversation messages of the call. This is only sent if the status is "forwarding".
	MessagesOpenAiFormatted []*OpenAiMessage `json:"messagesOpenAIFormatted,omitempty" url:"messagesOpenAIFormatted,omitempty"`
	// This is the destination the call is being transferred to. This is only sent if the status is "forwarding".
	Destination *ServerMessageStatusUpdateDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the transcript of the call. This is only sent if the status is "forwarding".
	Transcript *string `json:"transcript,omitempty" url:"transcript,omitempty"`
	// This is the summary of the call. This is only sent if the status is "forwarding".
	Summary *string `json:"summary,omitempty" url:"summary,omitempty"`
	// This is the inbound phone call debugging artifacts. This is only sent if the status is "ended" and there was an error accepting the inbound phone call.
	//
	// This will include any errors related to the "assistant-request" if one was made.
	InboundPhoneCallDebuggingArtifacts map[string]interface{} `json:"inboundPhoneCallDebuggingArtifacts,omitempty" url:"inboundPhoneCallDebuggingArtifacts,omitempty"`
	type_                              string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageStatusUpdate) GetPhoneNumber() *ServerMessageStatusUpdatePhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageStatusUpdate) GetStatus() ServerMessageStatusUpdateStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *ServerMessageStatusUpdate) GetEndedReason() *ServerMessageStatusUpdateEndedReason {
	if s == nil {
		return nil
	}
	return s.EndedReason
}

func (s *ServerMessageStatusUpdate) GetMessages() []*ServerMessageStatusUpdateMessagesItem {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *ServerMessageStatusUpdate) GetMessagesOpenAiFormatted() []*OpenAiMessage {
	if s == nil {
		return nil
	}
	return s.MessagesOpenAiFormatted
}

func (s *ServerMessageStatusUpdate) GetDestination() *ServerMessageStatusUpdateDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessageStatusUpdate) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageStatusUpdate) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageStatusUpdate) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageStatusUpdate) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageStatusUpdate) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageStatusUpdate) GetTranscript() *string {
	if s == nil {
		return nil
	}
	return s.Transcript
}

func (s *ServerMessageStatusUpdate) GetSummary() *string {
	if s == nil {
		return nil
	}
	return s.Summary
}

func (s *ServerMessageStatusUpdate) GetInboundPhoneCallDebuggingArtifacts() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.InboundPhoneCallDebuggingArtifacts
}

func (s *ServerMessageStatusUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageStatusUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageStatusUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageStatusUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageStatusUpdate(unmarshaler.embed)
	if unmarshaler.Type != "status-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "status-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageStatusUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageStatusUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "status-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageStatusUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination the call is being transferred to. This is only sent if the status is "forwarding".
type ServerMessageStatusUpdateDestination struct {
	TransferDestinationNumber *TransferDestinationNumber
	TransferDestinationSip    *TransferDestinationSip

	typ string
}

func (s *ServerMessageStatusUpdateDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessageStatusUpdateDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessageStatusUpdateDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdateDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdateDestinationVisitor interface {
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageStatusUpdateDestination) Accept(visitor ServerMessageStatusUpdateDestinationVisitor) error {
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the reason the call ended. This is only sent if the status is "ended".
type ServerMessageStatusUpdateEndedReason string

const (
	ServerMessageStatusUpdateEndedReasonAssistantNotInvalid                                                                        ServerMessageStatusUpdateEndedReason = "assistant-not-invalid"
	ServerMessageStatusUpdateEndedReasonAssistantNotProvided                                                                       ServerMessageStatusUpdateEndedReason = "assistant-not-provided"
	ServerMessageStatusUpdateEndedReasonCallStartErrorNeitherAssistantNorServerSet                                                 ServerMessageStatusUpdateEndedReason = "call-start-error-neither-assistant-nor-server-set"
	ServerMessageStatusUpdateEndedReasonAssistantRequestFailed                                                                     ServerMessageStatusUpdateEndedReason = "assistant-request-failed"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedError                                                              ServerMessageStatusUpdateEndedReason = "assistant-request-returned-error"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedUnspeakableError                                                   ServerMessageStatusUpdateEndedReason = "assistant-request-returned-unspeakable-error"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedInvalidAssistant                                                   ServerMessageStatusUpdateEndedReason = "assistant-request-returned-invalid-assistant"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedNoAssistant                                                        ServerMessageStatusUpdateEndedReason = "assistant-request-returned-no-assistant"
	ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedForwardingPhoneNumber                                              ServerMessageStatusUpdateEndedReason = "assistant-request-returned-forwarding-phone-number"
	ServerMessageStatusUpdateEndedReasonAssistantEndedCall                                                                         ServerMessageStatusUpdateEndedReason = "assistant-ended-call"
	ServerMessageStatusUpdateEndedReasonAssistantSaidEndCallPhrase                                                                 ServerMessageStatusUpdateEndedReason = "assistant-said-end-call-phrase"
	ServerMessageStatusUpdateEndedReasonAssistantForwardedCall                                                                     ServerMessageStatusUpdateEndedReason = "assistant-forwarded-call"
	ServerMessageStatusUpdateEndedReasonAssistantJoinTimedOut                                                                      ServerMessageStatusUpdateEndedReason = "assistant-join-timed-out"
	ServerMessageStatusUpdateEndedReasonCustomerBusy                                                                               ServerMessageStatusUpdateEndedReason = "customer-busy"
	ServerMessageStatusUpdateEndedReasonCustomerEndedCall                                                                          ServerMessageStatusUpdateEndedReason = "customer-ended-call"
	ServerMessageStatusUpdateEndedReasonCustomerDidNotAnswer                                                                       ServerMessageStatusUpdateEndedReason = "customer-did-not-answer"
	ServerMessageStatusUpdateEndedReasonCustomerDidNotGiveMicrophonePermission                                                     ServerMessageStatusUpdateEndedReason = "customer-did-not-give-microphone-permission"
	ServerMessageStatusUpdateEndedReasonAssistantSaidMessageWithEndCallEnabled                                                     ServerMessageStatusUpdateEndedReason = "assistant-said-message-with-end-call-enabled"
	ServerMessageStatusUpdateEndedReasonExceededMaxDuration                                                                        ServerMessageStatusUpdateEndedReason = "exceeded-max-duration"
	ServerMessageStatusUpdateEndedReasonManuallyCanceled                                                                           ServerMessageStatusUpdateEndedReason = "manually-canceled"
	ServerMessageStatusUpdateEndedReasonPhoneCallProviderClosedWebsocket                                                           ServerMessageStatusUpdateEndedReason = "phone-call-provider-closed-websocket"
	ServerMessageStatusUpdateEndedReasonDbError                                                                                    ServerMessageStatusUpdateEndedReason = "db-error"
	ServerMessageStatusUpdateEndedReasonAssistantNotFound                                                                          ServerMessageStatusUpdateEndedReason = "assistant-not-found"
	ServerMessageStatusUpdateEndedReasonLicenseCheckFailed                                                                         ServerMessageStatusUpdateEndedReason = "license-check-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiVoiceFailed                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaVoiceFailed                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramVoiceFailed                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceFailed                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceFailed                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorLmntVoiceFailed                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-lmnt-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureVoiceFailed                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRimeAiVoiceFailed                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-rime-ai-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorNeetsVoiceFailed                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-neets-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorSmallestAiVoiceFailed                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-smallest-ai-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramTranscriberFailed                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGladiaTranscriberFailed                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-gladia-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiTranscriberFailed                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-assembly-ai-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTalkscriberTranscriberFailed                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-talkscriber-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureSpeechTranscriberFailed                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-speech-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapiLlmFailed                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi400BadRequestValidationFailed                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi401Unauthorized                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi403ModelAccessDenied                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi429ExceededQuota                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorVapi500ServerError                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-vapi-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineNoAvailableModel                                                                   ServerMessageStatusUpdateEndedReason = "pipeline-no-available-model"
	ServerMessageStatusUpdateEndedReasonWorkerShutdown                                                                             ServerMessageStatusUpdateEndedReason = "worker-shutdown"
	ServerMessageStatusUpdateEndedReasonUnknownError                                                                               ServerMessageStatusUpdateEndedReason = "unknown-error"
	ServerMessageStatusUpdateEndedReasonVonageDisconnected                                                                         ServerMessageStatusUpdateEndedReason = "vonage-disconnected"
	ServerMessageStatusUpdateEndedReasonVonageFailedToConnectCall                                                                  ServerMessageStatusUpdateEndedReason = "vonage-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived                                            ServerMessageStatusUpdateEndedReason = "phone-call-provider-bypass-enabled-but-no-call-received"
	ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerSetupSocketError                                                   ServerMessageStatusUpdateEndedReason = "vapifault-phone-call-worker-setup-socket-error"
	ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout                                           ServerMessageStatusUpdateEndedReason = "vapifault-phone-call-worker-worker-setup-socket-timeout"
	ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall                                                   ServerMessageStatusUpdateEndedReason = "vapifault-phone-call-worker-could-not-find-call"
	ServerMessageStatusUpdateEndedReasonVapifaultTransportNeverConnected                                                           ServerMessageStatusUpdateEndedReason = "vapifault-transport-never-connected"
	ServerMessageStatusUpdateEndedReasonVapifaultWebCallWorkerSetupFailed                                                          ServerMessageStatusUpdateEndedReason = "vapifault-web-call-worker-setup-failed"
	ServerMessageStatusUpdateEndedReasonVapifaultTransportConnectedButCallNotActive                                                ServerMessageStatusUpdateEndedReason = "vapifault-transport-connected-but-call-not-active"
	ServerMessageStatusUpdateEndedReasonVapifaultCallStartedButConnectionToTransportMissing                                        ServerMessageStatusUpdateEndedReason = "vapifault-call-started-but-connection-to-transport-missing"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiLlmFailed                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenaiLlmFailed                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroqLlmFailed                                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogleLlmFailed                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-google-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXaiLlmFailed                                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAiLlmFailed                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebrasLlmFailed                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeekLlmFailed                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai400BadRequestValidationFailed                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401Unauthorized                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai403ModelAccessDenied                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai429ExceededQuota                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai500ServerError                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-openai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle400BadRequestValidationFailed                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-google-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle401Unauthorized                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-google-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle403ModelAccessDenied                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-google-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle429ExceededQuota                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-google-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle500ServerError                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-google-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai400BadRequestValidationFailed                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai401Unauthorized                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai403ModelAccessDenied                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai429ExceededQuota                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorXai500ServerError                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-xai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi400BadRequestValidationFailed                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi401Unauthorized                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi403ModelAccessDenied                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi429ExceededQuota                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi500ServerError                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-inflection-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek400BadRequestValidationFailed                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek401Unauthorized                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek403ModelAccessDenied                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek429ExceededQuota                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek500ServerError                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-deep-seek-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai401Unauthorized                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai429ExceededQuota                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai500ServerError                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-azure-openai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq400BadRequestValidationFailed                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq401Unauthorized                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq403ModelAccessDenied                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq429ExceededQuota                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorGroq500ServerError                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-groq-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras400BadRequestValidationFailed                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras401Unauthorized                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras403ModelAccessDenied                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras429ExceededQuota                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras500ServerError                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-cerebras-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic401Unauthorized                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic403ModelAccessDenied                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic429ExceededQuota                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic500ServerError                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicLlmFailed                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-anthropic-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi401Unauthorized                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi403ModelAccessDenied                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi429ExceededQuota                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi500ServerError                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAiLlmFailed                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-together-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale401Unauthorized                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale403ModelAccessDenied                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale429ExceededQuota                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale500ServerError                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscaleLlmFailed                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-anyscale-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter401Unauthorized                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter403ModelAccessDenied                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter429ExceededQuota                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter500ServerError                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouterLlmFailed                                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-openrouter-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi401Unauthorized                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi429ExceededQuota                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi500ServerError                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAiLlmFailed                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-perplexity-ai-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra401Unauthorized                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra403ModelAccessDenied                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra429ExceededQuota                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra500ServerError                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfraLlmFailed                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-deepinfra-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod400BadRequestValidationFailed                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod401Unauthorized                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod403ModelAccessDenied                                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod429ExceededQuota                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod500ServerError                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorRunpodLlmFailed                                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-runpod-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-400-bad-request-validation-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm401Unauthorized                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm403ModelAccessDenied                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm429ExceededQuota                                                     ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm500ServerError                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlmLlmFailed                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-llm-llm-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomVoiceFailed                                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-voice-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaSocketHangUp                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-socket-hang-up"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaRequestedPayment                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-requested-payment"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia500ServerError                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia503ServerError                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-503-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia522ServerError                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-cartesia-522-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFound                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-found"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsQuotaExceeded                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-quota-exceeded"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedAccess                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-unauthorized-access"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-unauthorized-to-access-model"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus                                ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade                        ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade                    ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-system-busy-and-requested-upgrade"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned                                                   ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidApiKey                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-invalid-api-key"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples                                                 ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-invalid-voice-samples"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner                                                ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-disabled-by-owner"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-account-in-probation"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-content-against-their-policy"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-missing-samples-for-voice-clone"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-voice-not-allowed-for-free-users"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabs500ServerError                                                      ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-500-server-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded                                           ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-max-character-limit-exceeded"
	ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification ServerMessageStatusUpdateEndedReason = "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtRequestTimedOut                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-request-timed-out"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidVoice                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-invalid-voice"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtUnexpectedError                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-unexpected-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtOutOfCredits                                                            ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-out-of-credits"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidEmotion                                                          ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-invalid-emotion"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht401Unauthorized                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-401-unauthorized"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters                                             ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-403-forbidden-out-of-characters"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-403-forbidden-api-access-not-available"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht429ExceededQuota                                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-429-exceeded-quota"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht502GatewayError                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-502-gateway-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht504GatewayError                                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-playht-504-gateway-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorTavusVideoFailed                                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-tavus-video-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorCustomTranscriberFailed                                                       ServerMessageStatusUpdateEndedReason = "pipeline-error-custom-transcriber-failed"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning403ModelAccessDenied                                         ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-403-model-access-denied"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning401InvalidCredentials                                        ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-401-invalid-credentials"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning404NotFound                                                  ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-404-not-found"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning400NoSuchModelLanguageTierCombination                        ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning500InvalidJson                                               ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-500-invalid-json"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning502NetworkError                                              ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-502-network-error"
	ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning502BadGatewayEhostunreach                                    ServerMessageStatusUpdateEndedReason = "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach"
	ServerMessageStatusUpdateEndedReasonSilenceTimedOut                                                                            ServerMessageStatusUpdateEndedReason = "silence-timed-out"
	ServerMessageStatusUpdateEndedReasonSipGatewayFailedToConnectCall                                                              ServerMessageStatusUpdateEndedReason = "sip-gateway-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonTwilioFailedToConnectCall                                                                  ServerMessageStatusUpdateEndedReason = "twilio-failed-to-connect-call"
	ServerMessageStatusUpdateEndedReasonTwilioReportedCustomerMisdialed                                                            ServerMessageStatusUpdateEndedReason = "twilio-reported-customer-misdialed"
	ServerMessageStatusUpdateEndedReasonVonageRejected                                                                             ServerMessageStatusUpdateEndedReason = "vonage-rejected"
	ServerMessageStatusUpdateEndedReasonVoicemail                                                                                  ServerMessageStatusUpdateEndedReason = "voicemail"
)

func NewServerMessageStatusUpdateEndedReasonFromString(s string) (ServerMessageStatusUpdateEndedReason, error) {
	switch s {
	case "assistant-not-invalid":
		return ServerMessageStatusUpdateEndedReasonAssistantNotInvalid, nil
	case "assistant-not-provided":
		return ServerMessageStatusUpdateEndedReasonAssistantNotProvided, nil
	case "call-start-error-neither-assistant-nor-server-set":
		return ServerMessageStatusUpdateEndedReasonCallStartErrorNeitherAssistantNorServerSet, nil
	case "assistant-request-failed":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestFailed, nil
	case "assistant-request-returned-error":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedError, nil
	case "assistant-request-returned-unspeakable-error":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedUnspeakableError, nil
	case "assistant-request-returned-invalid-assistant":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedInvalidAssistant, nil
	case "assistant-request-returned-no-assistant":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedNoAssistant, nil
	case "assistant-request-returned-forwarding-phone-number":
		return ServerMessageStatusUpdateEndedReasonAssistantRequestReturnedForwardingPhoneNumber, nil
	case "assistant-ended-call":
		return ServerMessageStatusUpdateEndedReasonAssistantEndedCall, nil
	case "assistant-said-end-call-phrase":
		return ServerMessageStatusUpdateEndedReasonAssistantSaidEndCallPhrase, nil
	case "assistant-forwarded-call":
		return ServerMessageStatusUpdateEndedReasonAssistantForwardedCall, nil
	case "assistant-join-timed-out":
		return ServerMessageStatusUpdateEndedReasonAssistantJoinTimedOut, nil
	case "customer-busy":
		return ServerMessageStatusUpdateEndedReasonCustomerBusy, nil
	case "customer-ended-call":
		return ServerMessageStatusUpdateEndedReasonCustomerEndedCall, nil
	case "customer-did-not-answer":
		return ServerMessageStatusUpdateEndedReasonCustomerDidNotAnswer, nil
	case "customer-did-not-give-microphone-permission":
		return ServerMessageStatusUpdateEndedReasonCustomerDidNotGiveMicrophonePermission, nil
	case "assistant-said-message-with-end-call-enabled":
		return ServerMessageStatusUpdateEndedReasonAssistantSaidMessageWithEndCallEnabled, nil
	case "exceeded-max-duration":
		return ServerMessageStatusUpdateEndedReasonExceededMaxDuration, nil
	case "manually-canceled":
		return ServerMessageStatusUpdateEndedReasonManuallyCanceled, nil
	case "phone-call-provider-closed-websocket":
		return ServerMessageStatusUpdateEndedReasonPhoneCallProviderClosedWebsocket, nil
	case "db-error":
		return ServerMessageStatusUpdateEndedReasonDbError, nil
	case "assistant-not-found":
		return ServerMessageStatusUpdateEndedReasonAssistantNotFound, nil
	case "license-check-failed":
		return ServerMessageStatusUpdateEndedReasonLicenseCheckFailed, nil
	case "pipeline-error-openai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiVoiceFailed, nil
	case "pipeline-error-cartesia-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaVoiceFailed, nil
	case "pipeline-error-deepgram-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramVoiceFailed, nil
	case "pipeline-error-eleven-labs-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceFailed, nil
	case "pipeline-error-playht-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceFailed, nil
	case "pipeline-error-lmnt-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorLmntVoiceFailed, nil
	case "pipeline-error-azure-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureVoiceFailed, nil
	case "pipeline-error-rime-ai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRimeAiVoiceFailed, nil
	case "pipeline-error-neets-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorNeetsVoiceFailed, nil
	case "pipeline-error-smallest-ai-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorSmallestAiVoiceFailed, nil
	case "pipeline-error-deepgram-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramTranscriberFailed, nil
	case "pipeline-error-gladia-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGladiaTranscriberFailed, nil
	case "pipeline-error-assembly-ai-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAssemblyAiTranscriberFailed, nil
	case "pipeline-error-talkscriber-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTalkscriberTranscriberFailed, nil
	case "pipeline-error-azure-speech-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureSpeechTranscriberFailed, nil
	case "pipeline-error-vapi-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapiLlmFailed, nil
	case "pipeline-error-vapi-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi400BadRequestValidationFailed, nil
	case "pipeline-error-vapi-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi401Unauthorized, nil
	case "pipeline-error-vapi-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi403ModelAccessDenied, nil
	case "pipeline-error-vapi-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi429ExceededQuota, nil
	case "pipeline-error-vapi-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorVapi500ServerError, nil
	case "pipeline-no-available-model":
		return ServerMessageStatusUpdateEndedReasonPipelineNoAvailableModel, nil
	case "worker-shutdown":
		return ServerMessageStatusUpdateEndedReasonWorkerShutdown, nil
	case "unknown-error":
		return ServerMessageStatusUpdateEndedReasonUnknownError, nil
	case "vonage-disconnected":
		return ServerMessageStatusUpdateEndedReasonVonageDisconnected, nil
	case "vonage-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonVonageFailedToConnectCall, nil
	case "phone-call-provider-bypass-enabled-but-no-call-received":
		return ServerMessageStatusUpdateEndedReasonPhoneCallProviderBypassEnabledButNoCallReceived, nil
	case "vapifault-phone-call-worker-setup-socket-error":
		return ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerSetupSocketError, nil
	case "vapifault-phone-call-worker-worker-setup-socket-timeout":
		return ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerWorkerSetupSocketTimeout, nil
	case "vapifault-phone-call-worker-could-not-find-call":
		return ServerMessageStatusUpdateEndedReasonVapifaultPhoneCallWorkerCouldNotFindCall, nil
	case "vapifault-transport-never-connected":
		return ServerMessageStatusUpdateEndedReasonVapifaultTransportNeverConnected, nil
	case "vapifault-web-call-worker-setup-failed":
		return ServerMessageStatusUpdateEndedReasonVapifaultWebCallWorkerSetupFailed, nil
	case "vapifault-transport-connected-but-call-not-active":
		return ServerMessageStatusUpdateEndedReasonVapifaultTransportConnectedButCallNotActive, nil
	case "vapifault-call-started-but-connection-to-transport-missing":
		return ServerMessageStatusUpdateEndedReasonVapifaultCallStartedButConnectionToTransportMissing, nil
	case "pipeline-error-openai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenaiLlmFailed, nil
	case "pipeline-error-azure-openai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenaiLlmFailed, nil
	case "pipeline-error-groq-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroqLlmFailed, nil
	case "pipeline-error-google-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogleLlmFailed, nil
	case "pipeline-error-xai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXaiLlmFailed, nil
	case "pipeline-error-inflection-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAiLlmFailed, nil
	case "pipeline-error-cerebras-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebrasLlmFailed, nil
	case "pipeline-error-deep-seek-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeekLlmFailed, nil
	case "pipeline-error-openai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-openai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai401Unauthorized, nil
	case "pipeline-error-openai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai403ModelAccessDenied, nil
	case "pipeline-error-openai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai429ExceededQuota, nil
	case "pipeline-error-openai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenai500ServerError, nil
	case "pipeline-error-google-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle400BadRequestValidationFailed, nil
	case "pipeline-error-google-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle401Unauthorized, nil
	case "pipeline-error-google-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle403ModelAccessDenied, nil
	case "pipeline-error-google-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle429ExceededQuota, nil
	case "pipeline-error-google-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGoogle500ServerError, nil
	case "pipeline-error-xai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai400BadRequestValidationFailed, nil
	case "pipeline-error-xai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai401Unauthorized, nil
	case "pipeline-error-xai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai403ModelAccessDenied, nil
	case "pipeline-error-xai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai429ExceededQuota, nil
	case "pipeline-error-xai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorXai500ServerError, nil
	case "pipeline-error-inflection-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi400BadRequestValidationFailed, nil
	case "pipeline-error-inflection-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi401Unauthorized, nil
	case "pipeline-error-inflection-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi403ModelAccessDenied, nil
	case "pipeline-error-inflection-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi429ExceededQuota, nil
	case "pipeline-error-inflection-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorInflectionAi500ServerError, nil
	case "pipeline-error-deep-seek-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek400BadRequestValidationFailed, nil
	case "pipeline-error-deep-seek-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek401Unauthorized, nil
	case "pipeline-error-deep-seek-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek403ModelAccessDenied, nil
	case "pipeline-error-deep-seek-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek429ExceededQuota, nil
	case "pipeline-error-deep-seek-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepSeek500ServerError, nil
	case "pipeline-error-azure-openai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai400BadRequestValidationFailed, nil
	case "pipeline-error-azure-openai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai401Unauthorized, nil
	case "pipeline-error-azure-openai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai403ModelAccessDenied, nil
	case "pipeline-error-azure-openai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai429ExceededQuota, nil
	case "pipeline-error-azure-openai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAzureOpenai500ServerError, nil
	case "pipeline-error-groq-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq400BadRequestValidationFailed, nil
	case "pipeline-error-groq-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq401Unauthorized, nil
	case "pipeline-error-groq-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq403ModelAccessDenied, nil
	case "pipeline-error-groq-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq429ExceededQuota, nil
	case "pipeline-error-groq-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorGroq500ServerError, nil
	case "pipeline-error-cerebras-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras400BadRequestValidationFailed, nil
	case "pipeline-error-cerebras-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras401Unauthorized, nil
	case "pipeline-error-cerebras-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras403ModelAccessDenied, nil
	case "pipeline-error-cerebras-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras429ExceededQuota, nil
	case "pipeline-error-cerebras-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCerebras500ServerError, nil
	case "pipeline-error-anthropic-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic400BadRequestValidationFailed, nil
	case "pipeline-error-anthropic-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic401Unauthorized, nil
	case "pipeline-error-anthropic-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic403ModelAccessDenied, nil
	case "pipeline-error-anthropic-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic429ExceededQuota, nil
	case "pipeline-error-anthropic-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropic500ServerError, nil
	case "pipeline-error-anthropic-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnthropicLlmFailed, nil
	case "pipeline-error-together-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi400BadRequestValidationFailed, nil
	case "pipeline-error-together-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi401Unauthorized, nil
	case "pipeline-error-together-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi403ModelAccessDenied, nil
	case "pipeline-error-together-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi429ExceededQuota, nil
	case "pipeline-error-together-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAi500ServerError, nil
	case "pipeline-error-together-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTogetherAiLlmFailed, nil
	case "pipeline-error-anyscale-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale400BadRequestValidationFailed, nil
	case "pipeline-error-anyscale-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale401Unauthorized, nil
	case "pipeline-error-anyscale-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale403ModelAccessDenied, nil
	case "pipeline-error-anyscale-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale429ExceededQuota, nil
	case "pipeline-error-anyscale-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscale500ServerError, nil
	case "pipeline-error-anyscale-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorAnyscaleLlmFailed, nil
	case "pipeline-error-openrouter-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter400BadRequestValidationFailed, nil
	case "pipeline-error-openrouter-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter401Unauthorized, nil
	case "pipeline-error-openrouter-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter403ModelAccessDenied, nil
	case "pipeline-error-openrouter-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter429ExceededQuota, nil
	case "pipeline-error-openrouter-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouter500ServerError, nil
	case "pipeline-error-openrouter-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorOpenrouterLlmFailed, nil
	case "pipeline-error-perplexity-ai-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi400BadRequestValidationFailed, nil
	case "pipeline-error-perplexity-ai-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi401Unauthorized, nil
	case "pipeline-error-perplexity-ai-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi403ModelAccessDenied, nil
	case "pipeline-error-perplexity-ai-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi429ExceededQuota, nil
	case "pipeline-error-perplexity-ai-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAi500ServerError, nil
	case "pipeline-error-perplexity-ai-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPerplexityAiLlmFailed, nil
	case "pipeline-error-deepinfra-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra400BadRequestValidationFailed, nil
	case "pipeline-error-deepinfra-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra401Unauthorized, nil
	case "pipeline-error-deepinfra-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra403ModelAccessDenied, nil
	case "pipeline-error-deepinfra-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra429ExceededQuota, nil
	case "pipeline-error-deepinfra-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfra500ServerError, nil
	case "pipeline-error-deepinfra-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepinfraLlmFailed, nil
	case "pipeline-error-runpod-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod400BadRequestValidationFailed, nil
	case "pipeline-error-runpod-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod401Unauthorized, nil
	case "pipeline-error-runpod-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod403ModelAccessDenied, nil
	case "pipeline-error-runpod-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod429ExceededQuota, nil
	case "pipeline-error-runpod-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpod500ServerError, nil
	case "pipeline-error-runpod-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorRunpodLlmFailed, nil
	case "pipeline-error-custom-llm-400-bad-request-validation-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm400BadRequestValidationFailed, nil
	case "pipeline-error-custom-llm-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm401Unauthorized, nil
	case "pipeline-error-custom-llm-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm403ModelAccessDenied, nil
	case "pipeline-error-custom-llm-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm429ExceededQuota, nil
	case "pipeline-error-custom-llm-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlm500ServerError, nil
	case "pipeline-error-custom-llm-llm-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomLlmLlmFailed, nil
	case "pipeline-error-custom-voice-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomVoiceFailed, nil
	case "pipeline-error-cartesia-socket-hang-up":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaSocketHangUp, nil
	case "pipeline-error-cartesia-requested-payment":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesiaRequestedPayment, nil
	case "pipeline-error-cartesia-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia500ServerError, nil
	case "pipeline-error-cartesia-503-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia503ServerError, nil
	case "pipeline-error-cartesia-522-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCartesia522ServerError, nil
	case "pipeline-error-eleven-labs-voice-not-found":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFound, nil
	case "pipeline-error-eleven-labs-quota-exceeded":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsQuotaExceeded, nil
	case "pipeline-error-eleven-labs-unauthorized-access":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedAccess, nil
	case "pipeline-error-eleven-labs-unauthorized-to-access-model":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsUnauthorizedToAccessModel, nil
	case "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsProfessionalVoicesOnlyForCreatorPlus, nil
	case "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedFreePlanAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedConcurrentRequestsAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedUsingInstantVoiceCloneAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-system-busy-and-requested-upgrade":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsSystemBusyAndRequestedUpgrade, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTuned, nil
	case "pipeline-error-eleven-labs-invalid-api-key":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidApiKey, nil
	case "pipeline-error-eleven-labs-invalid-voice-samples":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsInvalidVoiceSamples, nil
	case "pipeline-error-eleven-labs-voice-disabled-by-owner":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceDisabledByOwner, nil
	case "pipeline-error-eleven-labs-blocked-account-in-probation":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedAccountInProbation, nil
	case "pipeline-error-eleven-labs-blocked-content-against-their-policy":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedContentAgainstTheirPolicy, nil
	case "pipeline-error-eleven-labs-missing-samples-for-voice-clone":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMissingSamplesForVoiceClone, nil
	case "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotFineTunedAndCannotBeUsed, nil
	case "pipeline-error-eleven-labs-voice-not-allowed-for-free-users":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsVoiceNotAllowedForFreeUsers, nil
	case "pipeline-error-eleven-labs-500-server-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabs500ServerError, nil
	case "pipeline-error-eleven-labs-max-character-limit-exceeded":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsMaxCharacterLimitExceeded, nil
	case "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorElevenLabsBlockedVoicePotentiallyAgainstTermsOfServiceAndAwaitingVerification, nil
	case "pipeline-error-playht-request-timed-out":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtRequestTimedOut, nil
	case "pipeline-error-playht-invalid-voice":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidVoice, nil
	case "pipeline-error-playht-unexpected-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtUnexpectedError, nil
	case "pipeline-error-playht-out-of-credits":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtOutOfCredits, nil
	case "pipeline-error-playht-invalid-emotion":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtInvalidEmotion, nil
	case "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayhtVoiceMustBeAValidVoiceManifestUri, nil
	case "pipeline-error-playht-401-unauthorized":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht401Unauthorized, nil
	case "pipeline-error-playht-403-forbidden-out-of-characters":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenOutOfCharacters, nil
	case "pipeline-error-playht-403-forbidden-api-access-not-available":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht403ForbiddenApiAccessNotAvailable, nil
	case "pipeline-error-playht-429-exceeded-quota":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht429ExceededQuota, nil
	case "pipeline-error-playht-502-gateway-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht502GatewayError, nil
	case "pipeline-error-playht-504-gateway-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorPlayht504GatewayError, nil
	case "pipeline-error-tavus-video-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorTavusVideoFailed, nil
	case "pipeline-error-custom-transcriber-failed":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorCustomTranscriberFailed, nil
	case "pipeline-error-deepgram-returning-403-model-access-denied":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning403ModelAccessDenied, nil
	case "pipeline-error-deepgram-returning-401-invalid-credentials":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning401InvalidCredentials, nil
	case "pipeline-error-deepgram-returning-404-not-found":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning404NotFound, nil
	case "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning400NoSuchModelLanguageTierCombination, nil
	case "pipeline-error-deepgram-returning-500-invalid-json":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning500InvalidJson, nil
	case "pipeline-error-deepgram-returning-502-network-error":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning502NetworkError, nil
	case "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach":
		return ServerMessageStatusUpdateEndedReasonPipelineErrorDeepgramReturning502BadGatewayEhostunreach, nil
	case "silence-timed-out":
		return ServerMessageStatusUpdateEndedReasonSilenceTimedOut, nil
	case "sip-gateway-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonSipGatewayFailedToConnectCall, nil
	case "twilio-failed-to-connect-call":
		return ServerMessageStatusUpdateEndedReasonTwilioFailedToConnectCall, nil
	case "twilio-reported-customer-misdialed":
		return ServerMessageStatusUpdateEndedReasonTwilioReportedCustomerMisdialed, nil
	case "vonage-rejected":
		return ServerMessageStatusUpdateEndedReasonVonageRejected, nil
	case "voicemail":
		return ServerMessageStatusUpdateEndedReasonVoicemail, nil
	}
	var t ServerMessageStatusUpdateEndedReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageStatusUpdateEndedReason) Ptr() *ServerMessageStatusUpdateEndedReason {
	return &s
}

type ServerMessageStatusUpdateMessagesItem struct {
	UserMessage           *UserMessage
	SystemMessage         *SystemMessage
	BotMessage            *BotMessage
	ToolCallMessage       *ToolCallMessage
	ToolCallResultMessage *ToolCallResultMessage

	typ string
}

func (s *ServerMessageStatusUpdateMessagesItem) GetUserMessage() *UserMessage {
	if s == nil {
		return nil
	}
	return s.UserMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) GetSystemMessage() *SystemMessage {
	if s == nil {
		return nil
	}
	return s.SystemMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) GetBotMessage() *BotMessage {
	if s == nil {
		return nil
	}
	return s.BotMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) GetToolCallMessage() *ToolCallMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) GetToolCallResultMessage() *ToolCallResultMessage {
	if s == nil {
		return nil
	}
	return s.ToolCallResultMessage
}

func (s *ServerMessageStatusUpdateMessagesItem) UnmarshalJSON(data []byte) error {
	valueUserMessage := new(UserMessage)
	if err := json.Unmarshal(data, &valueUserMessage); err == nil {
		s.typ = "UserMessage"
		s.UserMessage = valueUserMessage
		return nil
	}
	valueSystemMessage := new(SystemMessage)
	if err := json.Unmarshal(data, &valueSystemMessage); err == nil {
		s.typ = "SystemMessage"
		s.SystemMessage = valueSystemMessage
		return nil
	}
	valueBotMessage := new(BotMessage)
	if err := json.Unmarshal(data, &valueBotMessage); err == nil {
		s.typ = "BotMessage"
		s.BotMessage = valueBotMessage
		return nil
	}
	valueToolCallMessage := new(ToolCallMessage)
	if err := json.Unmarshal(data, &valueToolCallMessage); err == nil {
		s.typ = "ToolCallMessage"
		s.ToolCallMessage = valueToolCallMessage
		return nil
	}
	valueToolCallResultMessage := new(ToolCallResultMessage)
	if err := json.Unmarshal(data, &valueToolCallResultMessage); err == nil {
		s.typ = "ToolCallResultMessage"
		s.ToolCallResultMessage = valueToolCallResultMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdateMessagesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return json.Marshal(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return json.Marshal(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return json.Marshal(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return json.Marshal(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return json.Marshal(s.ToolCallResultMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdateMessagesItemVisitor interface {
	VisitUserMessage(*UserMessage) error
	VisitSystemMessage(*SystemMessage) error
	VisitBotMessage(*BotMessage) error
	VisitToolCallMessage(*ToolCallMessage) error
	VisitToolCallResultMessage(*ToolCallResultMessage) error
}

func (s *ServerMessageStatusUpdateMessagesItem) Accept(visitor ServerMessageStatusUpdateMessagesItemVisitor) error {
	if s.typ == "UserMessage" || s.UserMessage != nil {
		return visitor.VisitUserMessage(s.UserMessage)
	}
	if s.typ == "SystemMessage" || s.SystemMessage != nil {
		return visitor.VisitSystemMessage(s.SystemMessage)
	}
	if s.typ == "BotMessage" || s.BotMessage != nil {
		return visitor.VisitBotMessage(s.BotMessage)
	}
	if s.typ == "ToolCallMessage" || s.ToolCallMessage != nil {
		return visitor.VisitToolCallMessage(s.ToolCallMessage)
	}
	if s.typ == "ToolCallResultMessage" || s.ToolCallResultMessage != nil {
		return visitor.VisitToolCallResultMessage(s.ToolCallResultMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageStatusUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageStatusUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageStatusUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageStatusUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageStatusUpdatePhoneNumber) Accept(visitor ServerMessageStatusUpdatePhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the status of the call.
type ServerMessageStatusUpdateStatus string

const (
	ServerMessageStatusUpdateStatusQueued     ServerMessageStatusUpdateStatus = "queued"
	ServerMessageStatusUpdateStatusRinging    ServerMessageStatusUpdateStatus = "ringing"
	ServerMessageStatusUpdateStatusInProgress ServerMessageStatusUpdateStatus = "in-progress"
	ServerMessageStatusUpdateStatusForwarding ServerMessageStatusUpdateStatus = "forwarding"
	ServerMessageStatusUpdateStatusEnded      ServerMessageStatusUpdateStatus = "ended"
)

func NewServerMessageStatusUpdateStatusFromString(s string) (ServerMessageStatusUpdateStatus, error) {
	switch s {
	case "queued":
		return ServerMessageStatusUpdateStatusQueued, nil
	case "ringing":
		return ServerMessageStatusUpdateStatusRinging, nil
	case "in-progress":
		return ServerMessageStatusUpdateStatusInProgress, nil
	case "forwarding":
		return ServerMessageStatusUpdateStatusForwarding, nil
	case "ended":
		return ServerMessageStatusUpdateStatusEnded, nil
	}
	var t ServerMessageStatusUpdateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageStatusUpdateStatus) Ptr() *ServerMessageStatusUpdateStatus {
	return &s
}

type ServerMessageToolCalls struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageToolCallsPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "tool-calls" is sent to call a tool.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// This is the list of tools calls that the model is requesting along with the original tool configuration.
	ToolWithToolCallList []*ServerMessageToolCallsToolWithToolCallListItem `json:"toolWithToolCallList,omitempty" url:"toolWithToolCallList,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the list of tool calls that the model is requesting.
	ToolCallList []*ToolCall `json:"toolCallList,omitempty" url:"toolCallList,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageToolCalls) GetPhoneNumber() *ServerMessageToolCallsPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageToolCalls) GetToolWithToolCallList() []*ServerMessageToolCallsToolWithToolCallListItem {
	if s == nil {
		return nil
	}
	return s.ToolWithToolCallList
}

func (s *ServerMessageToolCalls) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageToolCalls) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageToolCalls) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageToolCalls) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageToolCalls) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageToolCalls) GetToolCallList() []*ToolCall {
	if s == nil {
		return nil
	}
	return s.ToolCallList
}

func (s *ServerMessageToolCalls) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerMessageToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerMessageToolCalls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageToolCalls) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageToolCallsPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageToolCallsPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageToolCallsPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageToolCallsPhoneNumber) Accept(visitor ServerMessageToolCallsPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsToolWithToolCallListItem struct {
	FunctionToolWithToolCall *FunctionToolWithToolCall
	GhlToolWithToolCall      *GhlToolWithToolCall
	MakeToolWithToolCall     *MakeToolWithToolCall
	Unknown                  interface{}
	Unknown                  interface{}
	Unknown                  interface{}

	typ string
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetFunctionToolWithToolCall() *FunctionToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.FunctionToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetGhlToolWithToolCall() *GhlToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.GhlToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetMakeToolWithToolCall() *MakeToolWithToolCall {
	if s == nil {
		return nil
	}
	return s.MakeToolWithToolCall
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetUnknown() interface{} {
	if s == nil {
		return nil
	}
	return s.Unknown
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetUnknown() interface{} {
	if s == nil {
		return nil
	}
	return s.Unknown
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) GetUnknown() interface{} {
	if s == nil {
		return nil
	}
	return s.Unknown
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) UnmarshalJSON(data []byte) error {
	valueFunctionToolWithToolCall := new(FunctionToolWithToolCall)
	if err := json.Unmarshal(data, &valueFunctionToolWithToolCall); err == nil {
		s.typ = "FunctionToolWithToolCall"
		s.FunctionToolWithToolCall = valueFunctionToolWithToolCall
		return nil
	}
	valueGhlToolWithToolCall := new(GhlToolWithToolCall)
	if err := json.Unmarshal(data, &valueGhlToolWithToolCall); err == nil {
		s.typ = "GhlToolWithToolCall"
		s.GhlToolWithToolCall = valueGhlToolWithToolCall
		return nil
	}
	valueMakeToolWithToolCall := new(MakeToolWithToolCall)
	if err := json.Unmarshal(data, &valueMakeToolWithToolCall); err == nil {
		s.typ = "MakeToolWithToolCall"
		s.MakeToolWithToolCall = valueMakeToolWithToolCall
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typ = "Unknown"
		s.Unknown = valueUnknown
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typ = "Unknown"
		s.Unknown = valueUnknown
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typ = "Unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageToolCallsToolWithToolCallListItem) MarshalJSON() ([]byte, error) {
	if s.typ == "FunctionToolWithToolCall" || s.FunctionToolWithToolCall != nil {
		return json.Marshal(s.FunctionToolWithToolCall)
	}
	if s.typ == "GhlToolWithToolCall" || s.GhlToolWithToolCall != nil {
		return json.Marshal(s.GhlToolWithToolCall)
	}
	if s.typ == "MakeToolWithToolCall" || s.MakeToolWithToolCall != nil {
		return json.Marshal(s.MakeToolWithToolCall)
	}
	if s.typ == "Unknown" || s.Unknown != nil {
		return json.Marshal(s.Unknown)
	}
	if s.typ == "Unknown" || s.Unknown != nil {
		return json.Marshal(s.Unknown)
	}
	if s.typ == "Unknown" || s.Unknown != nil {
		return json.Marshal(s.Unknown)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageToolCallsToolWithToolCallListItemVisitor interface {
	VisitFunctionToolWithToolCall(*FunctionToolWithToolCall) error
	VisitGhlToolWithToolCall(*GhlToolWithToolCall) error
	VisitMakeToolWithToolCall(*MakeToolWithToolCall) error
	VisitUnknown(interface{}) error
	VisitUnknown(interface{}) error
	VisitUnknown(interface{}) error
}

func (s *ServerMessageToolCallsToolWithToolCallListItem) Accept(visitor ServerMessageToolCallsToolWithToolCallListItemVisitor) error {
	if s.typ == "FunctionToolWithToolCall" || s.FunctionToolWithToolCall != nil {
		return visitor.VisitFunctionToolWithToolCall(s.FunctionToolWithToolCall)
	}
	if s.typ == "GhlToolWithToolCall" || s.GhlToolWithToolCall != nil {
		return visitor.VisitGhlToolWithToolCall(s.GhlToolWithToolCall)
	}
	if s.typ == "MakeToolWithToolCall" || s.MakeToolWithToolCall != nil {
		return visitor.VisitMakeToolWithToolCall(s.MakeToolWithToolCall)
	}
	if s.typ == "Unknown" || s.Unknown != nil {
		return visitor.VisitUnknown(s.Unknown)
	}
	if s.typ == "Unknown" || s.Unknown != nil {
		return visitor.VisitUnknown(s.Unknown)
	}
	if s.typ == "Unknown" || s.Unknown != nil {
		return visitor.VisitUnknown(s.Unknown)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTranscript struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageTranscriptPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transcript" is sent as transcriber outputs partial or final transcript.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the role for which the transcript is for.
	Role ServerMessageTranscriptRole `json:"role" url:"role"`
	// This is the type of the transcript.
	TranscriptType ServerMessageTranscriptTranscriptType `json:"transcriptType" url:"transcriptType"`
	// This is the transcript content.
	Transcript string `json:"transcript" url:"transcript"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageTranscript) GetPhoneNumber() *ServerMessageTranscriptPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageTranscript) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageTranscript) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageTranscript) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageTranscript) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageTranscript) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageTranscript) GetRole() ServerMessageTranscriptRole {
	if s == nil {
		return ""
	}
	return s.Role
}

func (s *ServerMessageTranscript) GetTranscriptType() ServerMessageTranscriptTranscriptType {
	if s == nil {
		return ""
	}
	return s.TranscriptType
}

func (s *ServerMessageTranscript) GetTranscript() string {
	if s == nil {
		return ""
	}
	return s.Transcript
}

func (s *ServerMessageTranscript) Type() string {
	return s.type_
}

func (s *ServerMessageTranscript) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTranscript) UnmarshalJSON(data []byte) error {
	type embed ServerMessageTranscript
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageTranscript(unmarshaler.embed)
	if unmarshaler.Type != "transcript" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "transcript", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTranscript) MarshalJSON() ([]byte, error) {
	type embed ServerMessageTranscript
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "transcript",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageTranscript) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageTranscriptPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageTranscriptPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTranscriptPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTranscriptPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageTranscriptPhoneNumber) Accept(visitor ServerMessageTranscriptPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the role for which the transcript is for.
type ServerMessageTranscriptRole string

const (
	ServerMessageTranscriptRoleAssistant ServerMessageTranscriptRole = "assistant"
	ServerMessageTranscriptRoleUser      ServerMessageTranscriptRole = "user"
)

func NewServerMessageTranscriptRoleFromString(s string) (ServerMessageTranscriptRole, error) {
	switch s {
	case "assistant":
		return ServerMessageTranscriptRoleAssistant, nil
	case "user":
		return ServerMessageTranscriptRoleUser, nil
	}
	var t ServerMessageTranscriptRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageTranscriptRole) Ptr() *ServerMessageTranscriptRole {
	return &s
}

// This is the type of the transcript.
type ServerMessageTranscriptTranscriptType string

const (
	ServerMessageTranscriptTranscriptTypePartial ServerMessageTranscriptTranscriptType = "partial"
	ServerMessageTranscriptTranscriptTypeFinal   ServerMessageTranscriptTranscriptType = "final"
)

func NewServerMessageTranscriptTranscriptTypeFromString(s string) (ServerMessageTranscriptTranscriptType, error) {
	switch s {
	case "partial":
		return ServerMessageTranscriptTranscriptTypePartial, nil
	case "final":
		return ServerMessageTranscriptTranscriptTypeFinal, nil
	}
	var t ServerMessageTranscriptTranscriptType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServerMessageTranscriptTranscriptType) Ptr() *ServerMessageTranscriptTranscriptType {
	return &s
}

type ServerMessageTransferDestinationRequest struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageTransferDestinationRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transfer-destination-request" is sent when the model is requesting transfer but destination is unknown.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageTransferDestinationRequest) GetPhoneNumber() *ServerMessageTransferDestinationRequestPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageTransferDestinationRequest) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageTransferDestinationRequest) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageTransferDestinationRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageTransferDestinationRequest) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageTransferDestinationRequest) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageTransferDestinationRequest) Type() string {
	return s.type_
}

func (s *ServerMessageTransferDestinationRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTransferDestinationRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageTransferDestinationRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageTransferDestinationRequest(unmarshaler.embed)
	if unmarshaler.Type != "transfer-destination-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "transfer-destination-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTransferDestinationRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageTransferDestinationRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "transfer-destination-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageTransferDestinationRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageTransferDestinationRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferDestinationRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferDestinationRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageTransferDestinationRequestPhoneNumber) Accept(visitor ServerMessageTransferDestinationRequestPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdate struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageTransferUpdatePhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "transfer-update" is sent whenever a transfer happens.
	// This is the destination of the transfer.
	Destination *ServerMessageTransferUpdateDestination `json:"destination,omitempty" url:"destination,omitempty"`
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the assistant that the call is being transferred to. This is only sent if `destination.type` is "assistant".
	ToAssistant *CreateAssistantDto `json:"toAssistant,omitempty" url:"toAssistant,omitempty"`
	// This is the assistant that the call is being transferred from. This is only sent if `destination.type` is "assistant".
	FromAssistant *CreateAssistantDto `json:"fromAssistant,omitempty" url:"fromAssistant,omitempty"`
	// This is the step that the conversation moved to.
	ToStepRecord map[string]interface{} `json:"toStepRecord,omitempty" url:"toStepRecord,omitempty"`
	// This is the step that the conversation moved from. =
	FromStepRecord map[string]interface{} `json:"fromStepRecord,omitempty" url:"fromStepRecord,omitempty"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageTransferUpdate) GetPhoneNumber() *ServerMessageTransferUpdatePhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageTransferUpdate) GetDestination() *ServerMessageTransferUpdateDestination {
	if s == nil {
		return nil
	}
	return s.Destination
}

func (s *ServerMessageTransferUpdate) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageTransferUpdate) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageTransferUpdate) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageTransferUpdate) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageTransferUpdate) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageTransferUpdate) GetToAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.ToAssistant
}

func (s *ServerMessageTransferUpdate) GetFromAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.FromAssistant
}

func (s *ServerMessageTransferUpdate) GetToStepRecord() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.ToStepRecord
}

func (s *ServerMessageTransferUpdate) GetFromStepRecord() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.FromStepRecord
}

func (s *ServerMessageTransferUpdate) Type() string {
	return s.type_
}

func (s *ServerMessageTransferUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageTransferUpdate) UnmarshalJSON(data []byte) error {
	type embed ServerMessageTransferUpdate
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageTransferUpdate(unmarshaler.embed)
	if unmarshaler.Type != "transfer-update" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "transfer-update", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageTransferUpdate) MarshalJSON() ([]byte, error) {
	type embed ServerMessageTransferUpdate
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "transfer-update",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageTransferUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the destination of the transfer.
type ServerMessageTransferUpdateDestination struct {
	TransferDestinationAssistant *TransferDestinationAssistant
	TransferDestinationStep      *TransferDestinationStep
	TransferDestinationNumber    *TransferDestinationNumber
	TransferDestinationSip       *TransferDestinationSip

	typ string
}

func (s *ServerMessageTransferUpdateDestination) GetTransferDestinationAssistant() *TransferDestinationAssistant {
	if s == nil {
		return nil
	}
	return s.TransferDestinationAssistant
}

func (s *ServerMessageTransferUpdateDestination) GetTransferDestinationStep() *TransferDestinationStep {
	if s == nil {
		return nil
	}
	return s.TransferDestinationStep
}

func (s *ServerMessageTransferUpdateDestination) GetTransferDestinationNumber() *TransferDestinationNumber {
	if s == nil {
		return nil
	}
	return s.TransferDestinationNumber
}

func (s *ServerMessageTransferUpdateDestination) GetTransferDestinationSip() *TransferDestinationSip {
	if s == nil {
		return nil
	}
	return s.TransferDestinationSip
}

func (s *ServerMessageTransferUpdateDestination) UnmarshalJSON(data []byte) error {
	valueTransferDestinationAssistant := new(TransferDestinationAssistant)
	if err := json.Unmarshal(data, &valueTransferDestinationAssistant); err == nil {
		s.typ = "TransferDestinationAssistant"
		s.TransferDestinationAssistant = valueTransferDestinationAssistant
		return nil
	}
	valueTransferDestinationStep := new(TransferDestinationStep)
	if err := json.Unmarshal(data, &valueTransferDestinationStep); err == nil {
		s.typ = "TransferDestinationStep"
		s.TransferDestinationStep = valueTransferDestinationStep
		return nil
	}
	valueTransferDestinationNumber := new(TransferDestinationNumber)
	if err := json.Unmarshal(data, &valueTransferDestinationNumber); err == nil {
		s.typ = "TransferDestinationNumber"
		s.TransferDestinationNumber = valueTransferDestinationNumber
		return nil
	}
	valueTransferDestinationSip := new(TransferDestinationSip)
	if err := json.Unmarshal(data, &valueTransferDestinationSip); err == nil {
		s.typ = "TransferDestinationSip"
		s.TransferDestinationSip = valueTransferDestinationSip
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferUpdateDestination) MarshalJSON() ([]byte, error) {
	if s.typ == "TransferDestinationAssistant" || s.TransferDestinationAssistant != nil {
		return json.Marshal(s.TransferDestinationAssistant)
	}
	if s.typ == "TransferDestinationStep" || s.TransferDestinationStep != nil {
		return json.Marshal(s.TransferDestinationStep)
	}
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return json.Marshal(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return json.Marshal(s.TransferDestinationSip)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdateDestinationVisitor interface {
	VisitTransferDestinationAssistant(*TransferDestinationAssistant) error
	VisitTransferDestinationStep(*TransferDestinationStep) error
	VisitTransferDestinationNumber(*TransferDestinationNumber) error
	VisitTransferDestinationSip(*TransferDestinationSip) error
}

func (s *ServerMessageTransferUpdateDestination) Accept(visitor ServerMessageTransferUpdateDestinationVisitor) error {
	if s.typ == "TransferDestinationAssistant" || s.TransferDestinationAssistant != nil {
		return visitor.VisitTransferDestinationAssistant(s.TransferDestinationAssistant)
	}
	if s.typ == "TransferDestinationStep" || s.TransferDestinationStep != nil {
		return visitor.VisitTransferDestinationStep(s.TransferDestinationStep)
	}
	if s.typ == "TransferDestinationNumber" || s.TransferDestinationNumber != nil {
		return visitor.VisitTransferDestinationNumber(s.TransferDestinationNumber)
	}
	if s.typ == "TransferDestinationSip" || s.TransferDestinationSip != nil {
		return visitor.VisitTransferDestinationSip(s.TransferDestinationSip)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageTransferUpdatePhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageTransferUpdatePhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageTransferUpdatePhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageTransferUpdatePhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageTransferUpdatePhoneNumber) Accept(visitor ServerMessageTransferUpdatePhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageUserInterrupted struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageUserInterruptedPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "user-interrupted" is sent when the user interrupts the assistant.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call  *Call `json:"call,omitempty" url:"call,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageUserInterrupted) GetPhoneNumber() *ServerMessageUserInterruptedPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageUserInterrupted) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageUserInterrupted) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageUserInterrupted) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageUserInterrupted) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageUserInterrupted) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageUserInterrupted) Type() string {
	return s.type_
}

func (s *ServerMessageUserInterrupted) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageUserInterrupted) UnmarshalJSON(data []byte) error {
	type embed ServerMessageUserInterrupted
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageUserInterrupted(unmarshaler.embed)
	if unmarshaler.Type != "user-interrupted" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "user-interrupted", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageUserInterrupted) MarshalJSON() ([]byte, error) {
	type embed ServerMessageUserInterrupted
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "user-interrupted",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageUserInterrupted) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageUserInterruptedPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageUserInterruptedPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageUserInterruptedPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageUserInterruptedPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageUserInterruptedPhoneNumber) Accept(visitor ServerMessageUserInterruptedPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceInput struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageVoiceInputPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "voice-input" is sent when a generation is requested from voice provider.
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the voice input content
	Input string `json:"input" url:"input"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageVoiceInput) GetPhoneNumber() *ServerMessageVoiceInputPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageVoiceInput) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageVoiceInput) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageVoiceInput) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageVoiceInput) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageVoiceInput) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageVoiceInput) GetInput() string {
	if s == nil {
		return ""
	}
	return s.Input
}

func (s *ServerMessageVoiceInput) Type() string {
	return s.type_
}

func (s *ServerMessageVoiceInput) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageVoiceInput) UnmarshalJSON(data []byte) error {
	type embed ServerMessageVoiceInput
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageVoiceInput(unmarshaler.embed)
	if unmarshaler.Type != "voice-input" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "voice-input", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageVoiceInput) MarshalJSON() ([]byte, error) {
	type embed ServerMessageVoiceInput
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "voice-input",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageVoiceInput) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageVoiceInputPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageVoiceInputPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageVoiceInputPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceInputPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageVoiceInputPhoneNumber) Accept(visitor ServerMessageVoiceInputPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceRequest struct {
	// This is the phone number associated with the call.
	//
	// This matches one of the following:
	// - `call.phoneNumber`,
	// - `call.phoneNumberId`.
	PhoneNumber *ServerMessageVoiceRequestPhoneNumber `json:"phoneNumber,omitempty" url:"phoneNumber,omitempty"`
	// This is the type of the message. "voice-request" is sent when using `assistant.voice={ "type": "custom-voice" }`.
	//
	// Here is what the request will look like:
	//
	// POST https://{assistant.voice.server.url}
	// Content-Type: application/json
	//
	//	{
	//	  "messsage": {
	//	    "type": "voice-request",
	//	    "text": "Hello, world!",
	//	    "sampleRate": 24000,
	//	    ...other metadata about the call...
	//	  }
	//	}
	//
	// The expected response is 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:
	// ```
	//
	//	response.on('data', (chunk: Buffer) => {
	//	  outputStream.write(chunk);
	//	});
	//
	// ```
	// This is the ISO-8601 formatted timestamp of when the message was sent.
	Timestamp *string `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// This is a live version of the `call.artifact`.
	//
	// This matches what is stored on `call.artifact` after the call.
	Artifact *Artifact `json:"artifact,omitempty" url:"artifact,omitempty"`
	// This is the assistant that is currently active. This is provided for convenience.
	//
	// This matches one of the following:
	// - `call.assistant`,
	// - `call.assistantId`,
	// - `call.squad[n].assistant`,
	// - `call.squad[n].assistantId`,
	// - `call.squadId->[n].assistant`,
	// - `call.squadId->[n].assistantId`.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This is the customer associated with the call.
	//
	// This matches one of the following:
	// - `call.customer`,
	// - `call.customerId`.
	Customer *CreateCustomerDto `json:"customer,omitempty" url:"customer,omitempty"`
	// This is the call object.
	//
	// This matches what was returned in POST /call.
	//
	// Note: This might get stale during the call. To get the latest call object, especially after the call is ended, use GET /call/:id.
	Call *Call `json:"call,omitempty" url:"call,omitempty"`
	// This is the text to be synthesized.
	Text string `json:"text" url:"text"`
	// This is the sample rate to be synthesized.
	SampleRate float64 `json:"sampleRate" url:"sampleRate"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerMessageVoiceRequest) GetPhoneNumber() *ServerMessageVoiceRequestPhoneNumber {
	if s == nil {
		return nil
	}
	return s.PhoneNumber
}

func (s *ServerMessageVoiceRequest) GetTimestamp() *string {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *ServerMessageVoiceRequest) GetArtifact() *Artifact {
	if s == nil {
		return nil
	}
	return s.Artifact
}

func (s *ServerMessageVoiceRequest) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *ServerMessageVoiceRequest) GetCustomer() *CreateCustomerDto {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *ServerMessageVoiceRequest) GetCall() *Call {
	if s == nil {
		return nil
	}
	return s.Call
}

func (s *ServerMessageVoiceRequest) GetText() string {
	if s == nil {
		return ""
	}
	return s.Text
}

func (s *ServerMessageVoiceRequest) GetSampleRate() float64 {
	if s == nil {
		return 0
	}
	return s.SampleRate
}

func (s *ServerMessageVoiceRequest) Type() string {
	return s.type_
}

func (s *ServerMessageVoiceRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerMessageVoiceRequest) UnmarshalJSON(data []byte) error {
	type embed ServerMessageVoiceRequest
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ServerMessageVoiceRequest(unmarshaler.embed)
	if unmarshaler.Type != "voice-request" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "voice-request", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerMessageVoiceRequest) MarshalJSON() ([]byte, error) {
	type embed ServerMessageVoiceRequest
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "voice-request",
	}
	return json.Marshal(marshaler)
}

func (s *ServerMessageVoiceRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the phone number associated with the call.
//
// This matches one of the following:
// - `call.phoneNumber`,
// - `call.phoneNumberId`.
type ServerMessageVoiceRequestPhoneNumber struct {
	CreateByoPhoneNumberDto    *CreateByoPhoneNumberDto
	CreateTwilioPhoneNumberDto *CreateTwilioPhoneNumberDto
	CreateVonagePhoneNumberDto *CreateVonagePhoneNumberDto
	CreateVapiPhoneNumberDto   *CreateVapiPhoneNumberDto

	typ string
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateByoPhoneNumberDto() *CreateByoPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateByoPhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateTwilioPhoneNumberDto() *CreateTwilioPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateTwilioPhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateVonagePhoneNumberDto() *CreateVonagePhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVonagePhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) GetCreateVapiPhoneNumberDto() *CreateVapiPhoneNumberDto {
	if s == nil {
		return nil
	}
	return s.CreateVapiPhoneNumberDto
}

func (s *ServerMessageVoiceRequestPhoneNumber) UnmarshalJSON(data []byte) error {
	valueCreateByoPhoneNumberDto := new(CreateByoPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateByoPhoneNumberDto); err == nil {
		s.typ = "CreateByoPhoneNumberDto"
		s.CreateByoPhoneNumberDto = valueCreateByoPhoneNumberDto
		return nil
	}
	valueCreateTwilioPhoneNumberDto := new(CreateTwilioPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateTwilioPhoneNumberDto); err == nil {
		s.typ = "CreateTwilioPhoneNumberDto"
		s.CreateTwilioPhoneNumberDto = valueCreateTwilioPhoneNumberDto
		return nil
	}
	valueCreateVonagePhoneNumberDto := new(CreateVonagePhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVonagePhoneNumberDto); err == nil {
		s.typ = "CreateVonagePhoneNumberDto"
		s.CreateVonagePhoneNumberDto = valueCreateVonagePhoneNumberDto
		return nil
	}
	valueCreateVapiPhoneNumberDto := new(CreateVapiPhoneNumberDto)
	if err := json.Unmarshal(data, &valueCreateVapiPhoneNumberDto); err == nil {
		s.typ = "CreateVapiPhoneNumberDto"
		s.CreateVapiPhoneNumberDto = valueCreateVapiPhoneNumberDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerMessageVoiceRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return json.Marshal(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return json.Marshal(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return json.Marshal(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return json.Marshal(s.CreateVapiPhoneNumberDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ServerMessageVoiceRequestPhoneNumberVisitor interface {
	VisitCreateByoPhoneNumberDto(*CreateByoPhoneNumberDto) error
	VisitCreateTwilioPhoneNumberDto(*CreateTwilioPhoneNumberDto) error
	VisitCreateVonagePhoneNumberDto(*CreateVonagePhoneNumberDto) error
	VisitCreateVapiPhoneNumberDto(*CreateVapiPhoneNumberDto) error
}

func (s *ServerMessageVoiceRequestPhoneNumber) Accept(visitor ServerMessageVoiceRequestPhoneNumberVisitor) error {
	if s.typ == "CreateByoPhoneNumberDto" || s.CreateByoPhoneNumberDto != nil {
		return visitor.VisitCreateByoPhoneNumberDto(s.CreateByoPhoneNumberDto)
	}
	if s.typ == "CreateTwilioPhoneNumberDto" || s.CreateTwilioPhoneNumberDto != nil {
		return visitor.VisitCreateTwilioPhoneNumberDto(s.CreateTwilioPhoneNumberDto)
	}
	if s.typ == "CreateVonagePhoneNumberDto" || s.CreateVonagePhoneNumberDto != nil {
		return visitor.VisitCreateVonagePhoneNumberDto(s.CreateVonagePhoneNumberDto)
	}
	if s.typ == "CreateVapiPhoneNumberDto" || s.CreateVapiPhoneNumberDto != nil {
		return visitor.VisitCreateVapiPhoneNumberDto(s.CreateVapiPhoneNumberDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SipTrunkGateway struct {
	// This is the address of the gateway. It can be an IPv4 address like 1.1.1.1 or a fully qualified domain name like my-sip-trunk.pstn.twilio.com.
	Ip string `json:"ip" url:"ip"`
	// This is the port number of the gateway. Default is 5060.
	//
	// @default 5060
	Port *float64 `json:"port,omitempty" url:"port,omitempty"`
	// This is the netmask of the gateway. Defaults to 32.
	//
	// @default 32
	Netmask *float64 `json:"netmask,omitempty" url:"netmask,omitempty"`
	// This is whether inbound calls are allowed from this gateway. Default is true.
	//
	// @default true
	InboundEnabled *bool `json:"inboundEnabled,omitempty" url:"inboundEnabled,omitempty"`
	// This is whether outbound calls should be sent to this gateway. Default is true.
	//
	// Note, if netmask is less than 32, it doesn't affect the outbound IPs that are tried. 1 attempt is made to `ip:port`.
	//
	// @default true
	OutboundEnabled *bool `json:"outboundEnabled,omitempty" url:"outboundEnabled,omitempty"`
	// This is the protocol to use for SIP signaling outbound calls. Default is udp.
	//
	// @default udp
	OutboundProtocol *SipTrunkGatewayOutboundProtocol `json:"outboundProtocol,omitempty" url:"outboundProtocol,omitempty"`
	// This is whether to send options ping to the gateway. This can be used to check if the gateway is reachable. Default is false.
	//
	// This is useful for high availability setups where you want to check if the gateway is reachable before routing calls to it. Note, if no gateway for a trunk is reachable, outbound calls will be rejected.
	//
	// @default false
	OptionsPingEnabled *bool `json:"optionsPingEnabled,omitempty" url:"optionsPingEnabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SipTrunkGateway) GetIp() string {
	if s == nil {
		return ""
	}
	return s.Ip
}

func (s *SipTrunkGateway) GetPort() *float64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SipTrunkGateway) GetNetmask() *float64 {
	if s == nil {
		return nil
	}
	return s.Netmask
}

func (s *SipTrunkGateway) GetInboundEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.InboundEnabled
}

func (s *SipTrunkGateway) GetOutboundEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.OutboundEnabled
}

func (s *SipTrunkGateway) GetOutboundProtocol() *SipTrunkGatewayOutboundProtocol {
	if s == nil {
		return nil
	}
	return s.OutboundProtocol
}

func (s *SipTrunkGateway) GetOptionsPingEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.OptionsPingEnabled
}

func (s *SipTrunkGateway) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkGateway) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkGateway
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkGateway(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkGateway) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the protocol to use for SIP signaling outbound calls. Default is udp.
//
// @default udp
type SipTrunkGatewayOutboundProtocol string

const (
	SipTrunkGatewayOutboundProtocolTlsSrtp SipTrunkGatewayOutboundProtocol = "tls/srtp"
	SipTrunkGatewayOutboundProtocolTcp     SipTrunkGatewayOutboundProtocol = "tcp"
	SipTrunkGatewayOutboundProtocolTls     SipTrunkGatewayOutboundProtocol = "tls"
	SipTrunkGatewayOutboundProtocolUdp     SipTrunkGatewayOutboundProtocol = "udp"
)

func NewSipTrunkGatewayOutboundProtocolFromString(s string) (SipTrunkGatewayOutboundProtocol, error) {
	switch s {
	case "tls/srtp":
		return SipTrunkGatewayOutboundProtocolTlsSrtp, nil
	case "tcp":
		return SipTrunkGatewayOutboundProtocolTcp, nil
	case "tls":
		return SipTrunkGatewayOutboundProtocolTls, nil
	case "udp":
		return SipTrunkGatewayOutboundProtocolUdp, nil
	}
	var t SipTrunkGatewayOutboundProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SipTrunkGatewayOutboundProtocol) Ptr() *SipTrunkGatewayOutboundProtocol {
	return &s
}

type SipTrunkOutboundAuthenticationPlan struct {
	// This is not returned in the API.
	AuthPassword *string `json:"authPassword,omitempty" url:"authPassword,omitempty"`
	AuthUsername *string `json:"authUsername,omitempty" url:"authUsername,omitempty"`
	// This can be used to configure if SIP register is required by the SIP trunk. If not provided, no SIP registration will be attempted.
	SipRegisterPlan *SipTrunkOutboundSipRegisterPlan `json:"sipRegisterPlan,omitempty" url:"sipRegisterPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SipTrunkOutboundAuthenticationPlan) GetAuthPassword() *string {
	if s == nil {
		return nil
	}
	return s.AuthPassword
}

func (s *SipTrunkOutboundAuthenticationPlan) GetAuthUsername() *string {
	if s == nil {
		return nil
	}
	return s.AuthUsername
}

func (s *SipTrunkOutboundAuthenticationPlan) GetSipRegisterPlan() *SipTrunkOutboundSipRegisterPlan {
	if s == nil {
		return nil
	}
	return s.SipRegisterPlan
}

func (s *SipTrunkOutboundAuthenticationPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkOutboundAuthenticationPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkOutboundAuthenticationPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkOutboundAuthenticationPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkOutboundAuthenticationPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SipTrunkOutboundSipRegisterPlan struct {
	Domain   *string `json:"domain,omitempty" url:"domain,omitempty"`
	Username *string `json:"username,omitempty" url:"username,omitempty"`
	Realm    *string `json:"realm,omitempty" url:"realm,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SipTrunkOutboundSipRegisterPlan) GetDomain() *string {
	if s == nil {
		return nil
	}
	return s.Domain
}

func (s *SipTrunkOutboundSipRegisterPlan) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SipTrunkOutboundSipRegisterPlan) GetRealm() *string {
	if s == nil {
		return nil
	}
	return s.Realm
}

func (s *SipTrunkOutboundSipRegisterPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SipTrunkOutboundSipRegisterPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SipTrunkOutboundSipRegisterPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SipTrunkOutboundSipRegisterPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SipTrunkOutboundSipRegisterPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the provider-specific ID that will be used.
type SmallestAiVoiceId struct {
	SmallestAiVoiceIdEnum SmallestAiVoiceIdEnum
	String                string

	typ string
}

func (s *SmallestAiVoiceId) GetSmallestAiVoiceIdEnum() SmallestAiVoiceIdEnum {
	if s == nil {
		return ""
	}
	return s.SmallestAiVoiceIdEnum
}

func (s *SmallestAiVoiceId) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SmallestAiVoiceId) UnmarshalJSON(data []byte) error {
	var valueSmallestAiVoiceIdEnum SmallestAiVoiceIdEnum
	if err := json.Unmarshal(data, &valueSmallestAiVoiceIdEnum); err == nil {
		s.typ = "SmallestAiVoiceIdEnum"
		s.SmallestAiVoiceIdEnum = valueSmallestAiVoiceIdEnum
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SmallestAiVoiceId) MarshalJSON() ([]byte, error) {
	if s.typ == "SmallestAiVoiceIdEnum" || s.SmallestAiVoiceIdEnum != "" {
		return json.Marshal(s.SmallestAiVoiceIdEnum)
	}
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SmallestAiVoiceIdVisitor interface {
	VisitSmallestAiVoiceIdEnum(SmallestAiVoiceIdEnum) error
	VisitString(string) error
}

func (s *SmallestAiVoiceId) Accept(visitor SmallestAiVoiceIdVisitor) error {
	if s.typ == "SmallestAiVoiceIdEnum" || s.SmallestAiVoiceIdEnum != "" {
		return visitor.VisitSmallestAiVoiceIdEnum(s.SmallestAiVoiceIdEnum)
	}
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SmallestAiVoiceIdEnum string

const (
	SmallestAiVoiceIdEnumEmily    SmallestAiVoiceIdEnum = "emily"
	SmallestAiVoiceIdEnumJasmine  SmallestAiVoiceIdEnum = "jasmine"
	SmallestAiVoiceIdEnumArman    SmallestAiVoiceIdEnum = "arman"
	SmallestAiVoiceIdEnumJames    SmallestAiVoiceIdEnum = "james"
	SmallestAiVoiceIdEnumMithali  SmallestAiVoiceIdEnum = "mithali"
	SmallestAiVoiceIdEnumAravind  SmallestAiVoiceIdEnum = "aravind"
	SmallestAiVoiceIdEnumRaj      SmallestAiVoiceIdEnum = "raj"
	SmallestAiVoiceIdEnumDiya     SmallestAiVoiceIdEnum = "diya"
	SmallestAiVoiceIdEnumRaman    SmallestAiVoiceIdEnum = "raman"
	SmallestAiVoiceIdEnumAnanya   SmallestAiVoiceIdEnum = "ananya"
	SmallestAiVoiceIdEnumIsha     SmallestAiVoiceIdEnum = "isha"
	SmallestAiVoiceIdEnumWilliam  SmallestAiVoiceIdEnum = "william"
	SmallestAiVoiceIdEnumAarav    SmallestAiVoiceIdEnum = "aarav"
	SmallestAiVoiceIdEnumMonika   SmallestAiVoiceIdEnum = "monika"
	SmallestAiVoiceIdEnumNiharika SmallestAiVoiceIdEnum = "niharika"
	SmallestAiVoiceIdEnumDeepika  SmallestAiVoiceIdEnum = "deepika"
	SmallestAiVoiceIdEnumRaghav   SmallestAiVoiceIdEnum = "raghav"
	SmallestAiVoiceIdEnumKajal    SmallestAiVoiceIdEnum = "kajal"
	SmallestAiVoiceIdEnumRadhika  SmallestAiVoiceIdEnum = "radhika"
	SmallestAiVoiceIdEnumMansi    SmallestAiVoiceIdEnum = "mansi"
	SmallestAiVoiceIdEnumNisha    SmallestAiVoiceIdEnum = "nisha"
	SmallestAiVoiceIdEnumSaurabh  SmallestAiVoiceIdEnum = "saurabh"
	SmallestAiVoiceIdEnumPooja    SmallestAiVoiceIdEnum = "pooja"
	SmallestAiVoiceIdEnumSaina    SmallestAiVoiceIdEnum = "saina"
	SmallestAiVoiceIdEnumSanya    SmallestAiVoiceIdEnum = "sanya"
)

func NewSmallestAiVoiceIdEnumFromString(s string) (SmallestAiVoiceIdEnum, error) {
	switch s {
	case "emily":
		return SmallestAiVoiceIdEnumEmily, nil
	case "jasmine":
		return SmallestAiVoiceIdEnumJasmine, nil
	case "arman":
		return SmallestAiVoiceIdEnumArman, nil
	case "james":
		return SmallestAiVoiceIdEnumJames, nil
	case "mithali":
		return SmallestAiVoiceIdEnumMithali, nil
	case "aravind":
		return SmallestAiVoiceIdEnumAravind, nil
	case "raj":
		return SmallestAiVoiceIdEnumRaj, nil
	case "diya":
		return SmallestAiVoiceIdEnumDiya, nil
	case "raman":
		return SmallestAiVoiceIdEnumRaman, nil
	case "ananya":
		return SmallestAiVoiceIdEnumAnanya, nil
	case "isha":
		return SmallestAiVoiceIdEnumIsha, nil
	case "william":
		return SmallestAiVoiceIdEnumWilliam, nil
	case "aarav":
		return SmallestAiVoiceIdEnumAarav, nil
	case "monika":
		return SmallestAiVoiceIdEnumMonika, nil
	case "niharika":
		return SmallestAiVoiceIdEnumNiharika, nil
	case "deepika":
		return SmallestAiVoiceIdEnumDeepika, nil
	case "raghav":
		return SmallestAiVoiceIdEnumRaghav, nil
	case "kajal":
		return SmallestAiVoiceIdEnumKajal, nil
	case "radhika":
		return SmallestAiVoiceIdEnumRadhika, nil
	case "mansi":
		return SmallestAiVoiceIdEnumMansi, nil
	case "nisha":
		return SmallestAiVoiceIdEnumNisha, nil
	case "saurabh":
		return SmallestAiVoiceIdEnumSaurabh, nil
	case "pooja":
		return SmallestAiVoiceIdEnumPooja, nil
	case "saina":
		return SmallestAiVoiceIdEnumSaina, nil
	case "sanya":
		return SmallestAiVoiceIdEnumSanya, nil
	}
	var t SmallestAiVoiceIdEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SmallestAiVoiceIdEnum) Ptr() *SmallestAiVoiceIdEnum {
	return &s
}

type SmallestAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SmallestAiCredential) GetApiKey() string {
	if s == nil {
		return ""
	}
	return s.ApiKey
}

func (s *SmallestAiCredential) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SmallestAiCredential) GetOrgId() string {
	if s == nil {
		return ""
	}
	return s.OrgId
}

func (s *SmallestAiCredential) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *SmallestAiCredential) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *SmallestAiCredential) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SmallestAiCredential) Provider() string {
	return s.provider
}

func (s *SmallestAiCredential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SmallestAiCredential) UnmarshalJSON(data []byte) error {
	type embed SmallestAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SmallestAiCredential(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "smallest-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "smallest-ai", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SmallestAiCredential) MarshalJSON() ([]byte, error) {
	type embed SmallestAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
		Provider:  "smallest-ai",
	}
	return json.Marshal(marshaler)
}

func (s *SmallestAiCredential) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SmallestAiVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *SmallestAiVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// Smallest AI voice model to use. Defaults to 'lightning' when not specified.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// This is the speed multiplier that will be used.
	Speed *float64 `json:"speed,omitempty" url:"speed,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SmallestAiVoice) GetVoiceId() *SmallestAiVoiceId {
	if s == nil {
		return nil
	}
	return s.VoiceId
}

func (s *SmallestAiVoice) GetSpeed() *float64 {
	if s == nil {
		return nil
	}
	return s.Speed
}

func (s *SmallestAiVoice) GetChunkPlan() *ChunkPlan {
	if s == nil {
		return nil
	}
	return s.ChunkPlan
}

func (s *SmallestAiVoice) GetFallbackPlan() *FallbackPlan {
	if s == nil {
		return nil
	}
	return s.FallbackPlan
}

func (s *SmallestAiVoice) Provider() string {
	return s.provider
}

func (s *SmallestAiVoice) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SmallestAiVoice) UnmarshalJSON(data []byte) error {
	type embed SmallestAiVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SmallestAiVoice(unmarshaler.embed)
	if unmarshaler.Provider != "smallest-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "smallest-ai", unmarshaler.Provider)
	}
	s.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "provider")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SmallestAiVoice) MarshalJSON() ([]byte, error) {
	type embed SmallestAiVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*s),
		Provider: "smallest-ai",
	}
	return json.Marshal(marshaler)
}

func (s *SmallestAiVoice) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SquadMemberDto struct {
	// This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead.
	AssistantId *string `json:"assistantId,omitempty" url:"assistantId,omitempty"`
	// This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.
	Assistant *CreateAssistantDto `json:"assistant,omitempty" url:"assistant,omitempty"`
	// This can be used to override the assistant's settings and provide values for it's template variables.
	AssistantOverrides *AssistantOverrides `json:"assistantOverrides,omitempty" url:"assistantOverrides,omitempty"`
	// These are the others assistants that this assistant can transfer to.
	//
	// If the assistant already has transfer call tool, these destinations are just appended to existing ones.
	AssistantDestinations []*TransferDestinationAssistant `json:"assistantDestinations,omitempty" url:"assistantDestinations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SquadMemberDto) GetAssistantId() *string {
	if s == nil {
		return nil
	}
	return s.AssistantId
}

func (s *SquadMemberDto) GetAssistant() *CreateAssistantDto {
	if s == nil {
		return nil
	}
	return s.Assistant
}

func (s *SquadMemberDto) GetAssistantOverrides() *AssistantOverrides {
	if s == nil {
		return nil
	}
	return s.AssistantOverrides
}

func (s *SquadMemberDto) GetAssistantDestinations() []*TransferDestinationAssistant {
	if s == nil {
		return nil
	}
	return s.AssistantDestinations
}

func (s *SquadMemberDto) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SquadMemberDto) UnmarshalJSON(data []byte) error {
	type unmarshaler SquadMemberDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SquadMemberDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SquadMemberDto) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartSpeakingPlan struct {
	// This is how long assistant waits before speaking. Defaults to 0.4.
	//
	// This is the minimum it will wait but if there is latency is the pipeline, this minimum will be exceeded. This is intended as a stopgap in case the pipeline is moving too fast.
	//
	// Example:
	// - If model generates tokens and voice generates bytes within 100ms, the pipeline still waits 300ms before outputting speech.
	//
	// Usage:
	// - If the customer is taking long pauses, set this to a higher value.
	// - If the assistant is accidentally jumping in too much, set this to a higher value.
	//
	// @default 0.4
	WaitSeconds *float64 `json:"waitSeconds,omitempty" url:"waitSeconds,omitempty"`
	// This determines if a customer speech is considered done (endpointing) using a Vapi custom-trained model on customer's speech. This is good for middle-of-thought detection.
	//
	// Once an endpoint is triggered, the request is sent to `assistant.model`.
	//
	// Usage:
	// - If your conversations are long-form and you want assistant to wait smartly even if customer pauses for a bit to think, you can use this instead.
	//
	// This overrides `transcriptionEndpointingPlan`.
	//
	// @default false
	SmartEndpointingEnabled *bool `json:"smartEndpointingEnabled,omitempty" url:"smartEndpointingEnabled,omitempty"`
	// These are the custom endpointing rules to set an endpointing timeout based on a regex on the customer's speech or the assistant's last message.
	//
	// Usage:
	// - If you have yes/no questions like "are you interested in a loan?", you can set a shorter timeout.
	// - If you have questions where the customer may pause to look up information like "what's my account number?", you can set a longer timeout.
	// - If you want to wait longer while customer is enumerating a list of numbers, you can set a longer timeout.
	//
	// These override `transcriptionEndpointingPlan` and `smartEndpointingEnabled` when a rule is matched.
	//
	// The rules are evaluated in order and the first one that matches will be used.
	//
	// @default []
	CustomEndpointingRules []*StartSpeakingPlanCustomEndpointingRulesItem `json:"customEndpointingRules,omitempty" url:"customEndpointingRules,omitempty"`
	// This determines how a customer speech is considered done (endpointing) using the transcription of customer's speech.
	//
	// Once an endpoint is triggered, the request is sent to `assistant.model`.
	TranscriptionEndpointingPlan *TranscriptionEndpointingPlan `json:"transcriptionEndpointingPlan,omitempty" url:"transcriptionEndpointingPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StartSpeakingPlan) GetWaitSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.WaitSeconds
}

func (s *StartSpeakingPlan) GetSmartEndpointingEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.SmartEndpointingEnabled
}

func (s *StartSpeakingPlan) GetCustomEndpointingRules() []*StartSpeakingPlanCustomEndpointingRulesItem {
	if s == nil {
		return nil
	}
	return s.CustomEndpointingRules
}

func (s *StartSpeakingPlan) GetTranscriptionEndpointingPlan() *TranscriptionEndpointingPlan {
	if s == nil {
		return nil
	}
	return s.TranscriptionEndpointingPlan
}

func (s *StartSpeakingPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StartSpeakingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StartSpeakingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StartSpeakingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StartSpeakingPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartSpeakingPlanCustomEndpointingRulesItem struct {
	AssistantCustomEndpointingRule *AssistantCustomEndpointingRule
	CustomerCustomEndpointingRule  *CustomerCustomEndpointingRule
	BothCustomEndpointingRule      *BothCustomEndpointingRule

	typ string
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) GetAssistantCustomEndpointingRule() *AssistantCustomEndpointingRule {
	if s == nil {
		return nil
	}
	return s.AssistantCustomEndpointingRule
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) GetCustomerCustomEndpointingRule() *CustomerCustomEndpointingRule {
	if s == nil {
		return nil
	}
	return s.CustomerCustomEndpointingRule
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) GetBothCustomEndpointingRule() *BothCustomEndpointingRule {
	if s == nil {
		return nil
	}
	return s.BothCustomEndpointingRule
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) UnmarshalJSON(data []byte) error {
	valueAssistantCustomEndpointingRule := new(AssistantCustomEndpointingRule)
	if err := json.Unmarshal(data, &valueAssistantCustomEndpointingRule); err == nil {
		s.typ = "AssistantCustomEndpointingRule"
		s.AssistantCustomEndpointingRule = valueAssistantCustomEndpointingRule
		return nil
	}
	valueCustomerCustomEndpointingRule := new(CustomerCustomEndpointingRule)
	if err := json.Unmarshal(data, &valueCustomerCustomEndpointingRule); err == nil {
		s.typ = "CustomerCustomEndpointingRule"
		s.CustomerCustomEndpointingRule = valueCustomerCustomEndpointingRule
		return nil
	}
	valueBothCustomEndpointingRule := new(BothCustomEndpointingRule)
	if err := json.Unmarshal(data, &valueBothCustomEndpointingRule); err == nil {
		s.typ = "BothCustomEndpointingRule"
		s.BothCustomEndpointingRule = valueBothCustomEndpointingRule
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StartSpeakingPlanCustomEndpointingRulesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "AssistantCustomEndpointingRule" || s.AssistantCustomEndpointingRule != nil {
		return json.Marshal(s.AssistantCustomEndpointingRule)
	}
	if s.typ == "CustomerCustomEndpointingRule" || s.CustomerCustomEndpointingRule != nil {
		return json.Marshal(s.CustomerCustomEndpointingRule)
	}
	if s.typ == "BothCustomEndpointingRule" || s.BothCustomEndpointingRule != nil {
		return json.Marshal(s.BothCustomEndpointingRule)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StartSpeakingPlanCustomEndpointingRulesItemVisitor interface {
	VisitAssistantCustomEndpointingRule(*AssistantCustomEndpointingRule) error
	VisitCustomerCustomEndpointingRule(*CustomerCustomEndpointingRule) error
	VisitBothCustomEndpointingRule(*BothCustomEndpointingRule) error
}

func (s *StartSpeakingPlanCustomEndpointingRulesItem) Accept(visitor StartSpeakingPlanCustomEndpointingRulesItemVisitor) error {
	if s.typ == "AssistantCustomEndpointingRule" || s.AssistantCustomEndpointingRule != nil {
		return visitor.VisitAssistantCustomEndpointingRule(s.AssistantCustomEndpointingRule)
	}
	if s.typ == "CustomerCustomEndpointingRule" || s.CustomerCustomEndpointingRule != nil {
		return visitor.VisitCustomerCustomEndpointingRule(s.CustomerCustomEndpointingRule)
	}
	if s.typ == "BothCustomEndpointingRule" || s.BothCustomEndpointingRule != nil {
		return visitor.VisitBothCustomEndpointingRule(s.BothCustomEndpointingRule)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StepDestination struct {
	// This is an optional array of conditions that must be met for this destination to be triggered. If empty, this is the default destination that the step transfers to.
	Conditions []*StepDestinationConditionsItem `json:"conditions,omitempty" url:"conditions,omitempty"`
	StepName   string                           `json:"stepName" url:"stepName"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StepDestination) GetConditions() []*StepDestinationConditionsItem {
	if s == nil {
		return nil
	}
	return s.Conditions
}

func (s *StepDestination) GetStepName() string {
	if s == nil {
		return ""
	}
	return s.StepName
}

func (s *StepDestination) Type() string {
	return s.type_
}

func (s *StepDestination) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StepDestination) UnmarshalJSON(data []byte) error {
	type embed StepDestination
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = StepDestination(unmarshaler.embed)
	if unmarshaler.Type != "step" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "step", unmarshaler.Type)
	}
	s.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "type")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StepDestination) MarshalJSON() ([]byte, error) {
	type embed StepDestination
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "step",
	}
	return json.Marshal(marshaler)
}

func (s *StepDestination) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StepDestinationConditionsItem struct {
	ModelBasedCondition *ModelBasedCondition
	RuleBasedCondition  *RuleBasedCondition

	typ string
}

func (s *StepDestinationConditionsItem) GetModelBasedCondition() *ModelBasedCondition {
	if s == nil {
		return nil
	}
	return s.ModelBasedCondition
}

func (s *StepDestinationConditionsItem) GetRuleBasedCondition() *RuleBasedCondition {
	if s == nil {
		return nil
	}
	return s.RuleBasedCondition
}

func (s *StepDestinationConditionsItem) UnmarshalJSON(data []byte) error {
	valueModelBasedCondition := new(ModelBasedCondition)
	if err := json.Unmarshal(data, &valueModelBasedCondition); err == nil {
		s.typ = "ModelBasedCondition"
		s.ModelBasedCondition = valueModelBasedCondition
		return nil
	}
	valueRuleBasedCondition := new(RuleBasedCondition)
	if err := json.Unmarshal(data, &valueRuleBasedCondition); err == nil {
		s.typ = "RuleBasedCondition"
		s.RuleBasedCondition = valueRuleBasedCondition
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StepDestinationConditionsItem) MarshalJSON() ([]byte, error) {
	if s.typ == "ModelBasedCondition" || s.ModelBasedCondition != nil {
		return json.Marshal(s.ModelBasedCondition)
	}
	if s.typ == "RuleBasedCondition" || s.RuleBasedCondition != nil {
		return json.Marshal(s.RuleBasedCondition)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StepDestinationConditionsItemVisitor interface {
	VisitModelBasedCondition(*ModelBasedCondition) error
	VisitRuleBasedCondition(*RuleBasedCondition) error
}

func (s *StepDestinationConditionsItem) Accept(visitor StepDestinationConditionsItemVisitor) error {
	if s.typ == "ModelBasedCondition" || s.ModelBasedCondition != nil {
		return visitor.VisitModelBasedCondition(s.ModelBasedCondition)
	}
	if s.typ == "RuleBasedCondition" || s.RuleBasedCondition != nil {
		return visitor.VisitRuleBasedCondition(s.RuleBasedCondition)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StopSpeakingPlan struct {
	// This is the number of words that the customer has to say before the assistant will stop talking.
	//
	// Words like "stop", "actually", "no", etc. will always interrupt immediately regardless of this value.
	//
	// Words like "okay", "yeah", "right" will never interrupt.
	//
	// When set to 0, `voiceSeconds` is used in addition to the transcriptions to determine the customer has started speaking.
	//
	// Defaults to 0.
	//
	// @default 0
	NumWords *float64 `json:"numWords,omitempty" url:"numWords,omitempty"`
	// This is the seconds customer has to speak before the assistant stops talking. This uses the VAD (Voice Activity Detection) spike to determine if the customer has started speaking.
	//
	// Considerations:
	// - A lower value might be more responsive but could potentially pick up non-speech sounds.
	// - A higher value reduces false positives but might slightly delay the detection of speech onset.
	//
	// This is only used if `numWords` is set to 0.
	//
	// # Defaults to 0.2
	//
	// @default 0.2
	VoiceSeconds *float64 `json:"voiceSeconds,omitempty" url:"voiceSeconds,omitempty"`
	// This is the seconds to wait before the assistant will start talking again after being interrupted.
	//
	// Defaults to 1.
	//
	// @default 1
	BackoffSeconds *float64 `json:"backoffSeconds,omitempty" url:"backoffSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StopSpeakingPlan) GetNumWords() *float64 {
	if s == nil {
		return nil
	}
	return s.NumWords
}

func (s *StopSpeakingPlan) GetVoiceSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.VoiceSeconds
}

func (s *StopSpeakingPlan) GetBackoffSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.BackoffSeconds
}

func (s *StopSpeakingPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StopSpeakingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StopSpeakingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StopSpeakingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StopSpeakingPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StructuredDataPlan struct {
	// These are the messages used to generate the structured data.
	//
	// @default: ```
	// [
	//
	//	{
	//	  "role": "system",
	//	  "content": "You are an expert data extractor. You will be given a transcript of a call. Extract structured data per the JSON Schema. DO NOT return anything except the structured data.\n\nJson Schema:\\n{{schema}}\n\nOnly respond with the JSON."
	//	},
	//	{
	//	  "role": "user",
	//	  "content": "Here is the transcript:\n\n{{transcript}}\n\n"
	//	}
	//
	// ]```
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	// - {{transcript}}: the transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: the system prompt of the call from `assistant.model.messages[type=system].content`- {{schema}}: the schema of the structured data from `structuredDataPlan.schema`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether structured data is generated and stored in `call.analysis.structuredData`. Defaults to false.
	//
	// Usage:
	// - If you want to extract structured data, set this to true and provide a `schema`.
	//
	// @default false
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the schema of the structured data. The output is stored in `call.analysis.structuredData`.
	//
	// Complete guide on JSON Schema can be found [here](https://ajv.js.org/json-schema.html#json-data-type).
	Schema *JsonSchema `json:"schema,omitempty" url:"schema,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.structuredData` will be empty.
	//
	// Usage:
	// - To guarantee the structured data is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StructuredDataPlan) GetMessages() []map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *StructuredDataPlan) GetEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.Enabled
}

func (s *StructuredDataPlan) GetSchema() *JsonSchema {
	if s == nil {
		return nil
	}
	return s.Schema
}

func (s *StructuredDataPlan) GetTimeoutSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.TimeoutSeconds
}

func (s *StructuredDataPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StructuredDataPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler StructuredDataPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StructuredDataPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StructuredDataPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Subscription struct {
	// This is the unique identifier for the subscription.
	Id string `json:"id" url:"id"`
	// This is the timestamp when the subscription was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the timestamp when the subscription was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the type / tier of the subscription.
	Type SubscriptionType `json:"type" url:"type"`
	// This is the status of the subscription. Past due subscriptions are subscriptions
	// with past due payments.
	Status SubscriptionStatus `json:"status" url:"status"`
	// This is the number of credits the subscription currently has.
	//
	// Note: This is a string to avoid floating point precision issues.
	Credits string `json:"credits" url:"credits"`
	// This is the total concurrency limit for the subscription.
	ConcurrencyLimit float64 `json:"concurrencyLimit" url:"concurrencyLimit"`
	// This is the default concurrency limit for the subscription.
	ConcurrencyLimitIncluded float64 `json:"concurrencyLimitIncluded" url:"concurrencyLimitIncluded"`
	// This is the purchased add-on concurrency limit for the subscription.
	ConcurrencyLimitPurchased float64 `json:"concurrencyLimitPurchased" url:"concurrencyLimitPurchased"`
	// This is the ID of the monthly job that charges for subscription add ons and phone numbers.
	MonthlyChargeScheduleId *float64 `json:"monthlyChargeScheduleId,omitempty" url:"monthlyChargeScheduleId,omitempty"`
	// This is the ID of the monthly job that checks whether the credit balance of the subscription
	// is sufficient for the monthly charge.
	MonthlyCreditCheckScheduleId *float64 `json:"monthlyCreditCheckScheduleId,omitempty" url:"monthlyCreditCheckScheduleId,omitempty"`
	// This is the Stripe customer ID.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty" url:"stripeCustomerId,omitempty"`
	// This is the Stripe payment ID.
	StripePaymentMethodId *string `json:"stripePaymentMethodId,omitempty" url:"stripePaymentMethodId,omitempty"`
	// If this flag is true, then the user has purchased slack support.
	SlackSupportEnabled *bool `json:"slackSupportEnabled,omitempty" url:"slackSupportEnabled,omitempty"`
	// If this subscription has a slack support subscription, the slack channel's ID will be stored here.
	SlackChannelId *string `json:"slackChannelId,omitempty" url:"slackChannelId,omitempty"`
	// This is the HIPAA enabled flag for the subscription. It determines whether orgs under this
	// subscription have the option to enable HIPAA compliance.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the ID for the Common Paper agreement outlining the HIPAA contract.
	HipaaCommonPaperAgreementId *string `json:"hipaaCommonPaperAgreementId,omitempty" url:"hipaaCommonPaperAgreementId,omitempty"`
	// This is the Stripe fingerprint of the payment method (card). It allows us
	// to detect users who try to abuse our system through multiple sign-ups.
	StripePaymentMethodFingerprint *string `json:"stripePaymentMethodFingerprint,omitempty" url:"stripePaymentMethodFingerprint,omitempty"`
	// This is the customer's email on Stripe.
	StripeCustomerEmail *string `json:"stripeCustomerEmail,omitempty" url:"stripeCustomerEmail,omitempty"`
	// This is the email of the referrer for the subscription.
	ReferredByEmail *string `json:"referredByEmail,omitempty" url:"referredByEmail,omitempty"`
	// This is the auto reload plan configured for the subscription.
	AutoReloadPlan *AutoReloadPlan `json:"autoReloadPlan,omitempty" url:"autoReloadPlan,omitempty"`
	// The number of minutes included in the subscription. Enterprise only.
	MinutesIncluded *float64 `json:"minutesIncluded,omitempty" url:"minutesIncluded,omitempty"`
	// The number of minutes used in the subscription. Enterprise only.
	MinutesUsed *float64 `json:"minutesUsed,omitempty" url:"minutesUsed,omitempty"`
	// The per minute charge on minutes that exceed the included minutes. Enterprise only.
	MinutesOverageCost *float64 `json:"minutesOverageCost,omitempty" url:"minutesOverageCost,omitempty"`
	// The list of providers included in the subscription. Enterprise only.
	ProvidersIncluded []string `json:"providersIncluded,omitempty" url:"providersIncluded,omitempty"`
	// The maximum number of outbound calls this subscription may make in a day. Resets every night.
	OutboundCallsDailyLimit *float64 `json:"outboundCallsDailyLimit,omitempty" url:"outboundCallsDailyLimit,omitempty"`
	// The current number of outbound calls the subscription has made in the current day.
	OutboundCallsCounter *float64 `json:"outboundCallsCounter,omitempty" url:"outboundCallsCounter,omitempty"`
	// This is the timestamp at which the outbound calls counter is scheduled to reset at.
	OutboundCallsCounterNextResetAt *time.Time `json:"outboundCallsCounterNextResetAt,omitempty" url:"outboundCallsCounterNextResetAt,omitempty"`
	// This is the IDs of the coupons applicable to this subscription.
	CouponIds []string `json:"couponIds,omitempty" url:"couponIds,omitempty"`
	// This is the number of credits left obtained from a coupon.
	CouponUsageLeft *string `json:"couponUsageLeft,omitempty" url:"couponUsageLeft,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Subscription) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *Subscription) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *Subscription) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *Subscription) GetType() SubscriptionType {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *Subscription) GetStatus() SubscriptionStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *Subscription) GetCredits() string {
	if s == nil {
		return ""
	}
	return s.Credits
}

func (s *Subscription) GetConcurrencyLimit() float64 {
	if s == nil {
		return 0
	}
	return s.ConcurrencyLimit
}

func (s *Subscription) GetConcurrencyLimitIncluded() float64 {
	if s == nil {
		return 0
	}
	return s.ConcurrencyLimitIncluded
}

func (s *Subscription) GetConcurrencyLimitPurchased() float64 {
	if s == nil {
		return 0
	}
	return s.ConcurrencyLimitPurchased
}

func (s *Subscription) GetMonthlyChargeScheduleId() *float64 {
	if s == nil {
		return nil
	}
	return s.MonthlyChargeScheduleId
}

func (s *Subscription) GetMonthlyCreditCheckScheduleId() *float64 {
	if s == nil {
		return nil
	}
	return s.MonthlyCreditCheckScheduleId
}

func (s *Subscription) GetStripeCustomerId() *string {
	if s == nil {
		return nil
	}
	return s.StripeCustomerId
}

func (s *Subscription) GetStripePaymentMethodId() *string {
	if s == nil {
		return nil
	}
	return s.StripePaymentMethodId
}

func (s *Subscription) GetSlackSupportEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.SlackSupportEnabled
}

func (s *Subscription) GetSlackChannelId() *string {
	if s == nil {
		return nil
	}
	return s.SlackChannelId
}

func (s *Subscription) GetHipaaEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.HipaaEnabled
}

func (s *Subscription) GetHipaaCommonPaperAgreementId() *string {
	if s == nil {
		return nil
	}
	return s.HipaaCommonPaperAgreementId
}

func (s *Subscription) GetStripePaymentMethodFingerprint() *string {
	if s == nil {
		return nil
	}
	return s.StripePaymentMethodFingerprint
}

func (s *Subscription) GetStripeCustomerEmail() *string {
	if s == nil {
		return nil
	}
	return s.StripeCustomerEmail
}

func (s *Subscription) GetReferredByEmail() *string {
	if s == nil {
		return nil
	}
	return s.ReferredByEmail
}

func (s *Subscription) GetAutoReloadPlan() *AutoReloadPlan {
	if s == nil {
		return nil
	}
	return s.AutoReloadPlan
}

func (s *Subscription) GetMinutesIncluded() *float64 {
	if s == nil {
		return nil
	}
	return s.MinutesIncluded
}

func (s *Subscription) GetMinutesUsed() *float64 {
	if s == nil {
		return nil
	}
	return s.MinutesUsed
}

func (s *Subscription) GetMinutesOverageCost() *float64 {
	if s == nil {
		return nil
	}
	return s.MinutesOverageCost
}

func (s *Subscription) GetProvidersIncluded() []string {
	if s == nil {
		return nil
	}
	return s.ProvidersIncluded
}

func (s *Subscription) GetOutboundCallsDailyLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.OutboundCallsDailyLimit
}

func (s *Subscription) GetOutboundCallsCounter() *float64 {
	if s == nil {
		return nil
	}
	return s.OutboundCallsCounter
}

func (s *Subscription) GetOutboundCallsCounterNextResetAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.OutboundCallsCounterNextResetAt
}

func (s *Subscription) GetCouponIds() []string {
	if s == nil {
		return nil
	}
	return s.CouponIds
}

func (s *Subscription) GetCouponUsageLeft() *string {
	if s == nil {
		return nil
	}
	return s.CouponUsageLeft
}

func (s *Subscription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Subscription) UnmarshalJSON(data []byte) error {
	type embed Subscription
	var unmarshaler = struct {
		embed
		CreatedAt                       *internal.DateTime `json:"createdAt"`
		UpdatedAt                       *internal.DateTime `json:"updatedAt"`
		OutboundCallsCounterNextResetAt *internal.DateTime `json:"outboundCallsCounterNextResetAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Subscription(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	s.OutboundCallsCounterNextResetAt = unmarshaler.OutboundCallsCounterNextResetAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Subscription) MarshalJSON() ([]byte, error) {
	type embed Subscription
	var marshaler = struct {
		embed
		CreatedAt                       *internal.DateTime `json:"createdAt"`
		UpdatedAt                       *internal.DateTime `json:"updatedAt"`
		OutboundCallsCounterNextResetAt *internal.DateTime `json:"outboundCallsCounterNextResetAt,omitempty"`
	}{
		embed:                           embed(*s),
		CreatedAt:                       internal.NewDateTime(s.CreatedAt),
		UpdatedAt:                       internal.NewDateTime(s.UpdatedAt),
		OutboundCallsCounterNextResetAt: internal.NewOptionalDateTime(s.OutboundCallsCounterNextResetAt),
	}
	return json.Marshal(marshaler)
}

func (s *Subscription) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This is the status of the subscription. Past due subscriptions are subscriptions
// with past due payments.
type SubscriptionStatus string

const (
	SubscriptionStatusActive SubscriptionStatus = "active"
	SubscriptionStatusFrozen SubscriptionStatus = "frozen"
)

func NewSubscriptionStatusFromString(s string) (SubscriptionStatus, error) {
	switch s {
	case "active":
		return SubscriptionStatusActive, nil
	case "frozen":
		return SubscriptionStatusFrozen, nil
	}
	var t SubscriptionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionStatus) Ptr() *SubscriptionStatus {
	return &s
}

// This is the type / tier of the subscription.
type SubscriptionType string

const (
	SubscriptionTypeTrial      SubscriptionType = "trial"
	SubscriptionTypePayAsYouGo SubscriptionType = "pay-as-you-go"
	SubscriptionTypeEnterprise SubscriptionType = "enterprise"
)

func NewSubscriptionTypeFromString(s string) (SubscriptionType, error) {
	switch s {
	case "trial":
		return SubscriptionTypeTrial, nil
	case "pay-as-you-go":
		return SubscriptionTypePayAsYouGo, nil
	case "enterprise":
		return SubscriptionTypeEnterprise, nil
	}
	var t SubscriptionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionType) Ptr() *SubscriptionType {
	return &s
}

type SuccessEvaluationPlan struct {
	// This enforces the rubric of the evaluation. The output is stored in `call.analysis.successEvaluation`.
	//
	// Options include:
	// - 'NumericScale': A scale of 1 to 10.
	// - 'DescriptiveScale': A scale of Excellent, Good, Fair, Poor.
	// - 'Checklist': A checklist of criteria and their status.
	// - 'Matrix': A grid that evaluates multiple criteria across different performance levels.
	// - 'PercentageScale': A scale of 0% to 100%.
	// - 'LikertScale': A scale of Strongly Agree, Agree, Neutral, Disagree, Strongly Disagree.
	// - 'AutomaticRubric': Automatically break down evaluation into several criteria, each with its own score.
	// - 'PassFail': A simple 'true' if call passed, 'false' if not.
	//
	// Default is 'PassFail'.
	Rubric *SuccessEvaluationPlanRubric `json:"rubric,omitempty" url:"rubric,omitempty"`
	// These are the messages used to generate the success evaluation.
	//
	// @default: ```
	// [
	//
	//	{
	//	  "role": "system",
	//	  "content": "You are an expert call evaluator. You will be given a transcript of a call and the system prompt of the AI participant. Determine if the call was successful based on the objectives inferred from the system prompt. DO NOT return anything except the result.\n\nRubric:\\n{{rubric}}\n\nOnly respond with the result."
	//	},
	//	{
	//	  "role": "user",
	//	  "content": "Here is the transcript:\n\n{{transcript}}\n\n"
	//	},
	//	{
	//	  "role": "user",
	//	  "content": "Here was the system prompt of the call:\n\n{{systemPrompt}}\n\n"
	//	}
	//
	// ]```
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	// - {{transcript}}: the transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: the system prompt of the call from `assistant.model.messages[type=system].content`- {{rubric}}: the rubric of the success evaluation from `successEvaluationPlan.rubric`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether a success evaluation is generated and stored in `call.analysis.successEvaluation`. Defaults to true.
	//
	// Usage:
	// - If you want to disable the success evaluation, set this to false.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.successEvaluation` will be empty.
	//
	// Usage:
	// - To guarantee the success evaluation is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuccessEvaluationPlan) GetRubric() *SuccessEvaluationPlanRubric {
	if s == nil {
		return nil
	}
	return s.Rubric
}

func (s *SuccessEvaluationPlan) GetMessages() []map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *SuccessEvaluationPlan) GetEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.Enabled
}

func (s *SuccessEvaluationPlan) GetTimeoutSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.TimeoutSeconds
}

func (s *SuccessEvaluationPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessEvaluationPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessEvaluationPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessEvaluationPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessEvaluationPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// This enforces the rubric of the evaluation. The output is stored in `call.analysis.successEvaluation`.
//
// Options include:
// - 'NumericScale': A scale of 1 to 10.
// - 'DescriptiveScale': A scale of Excellent, Good, Fair, Poor.
// - 'Checklist': A checklist of criteria and their status.
// - 'Matrix': A grid that evaluates multiple criteria across different performance levels.
// - 'PercentageScale': A scale of 0% to 100%.
// - 'LikertScale': A scale of Strongly Agree, Agree, Neutral, Disagree, Strongly Disagree.
// - 'AutomaticRubric': Automatically break down evaluation into several criteria, each with its own score.
// - 'PassFail': A simple 'true' if call passed, 'false' if not.
//
// Default is 'PassFail'.
type SuccessEvaluationPlanRubric string

const (
	SuccessEvaluationPlanRubricNumericScale     SuccessEvaluationPlanRubric = "NumericScale"
	SuccessEvaluationPlanRubricDescriptiveScale SuccessEvaluationPlanRubric = "DescriptiveScale"
	SuccessEvaluationPlanRubricChecklist        SuccessEvaluationPlanRubric = "Checklist"
	SuccessEvaluationPlanRubricMatrix           SuccessEvaluationPlanRubric = "Matrix"
	SuccessEvaluationPlanRubricPercentageScale  SuccessEvaluationPlanRubric = "PercentageScale"
	SuccessEvaluationPlanRubricLikertScale      SuccessEvaluationPlanRubric = "LikertScale"
	SuccessEvaluationPlanRubricAutomaticRubric  SuccessEvaluationPlanRubric = "AutomaticRubric"
	SuccessEvaluationPlanRubricPassFail         SuccessEvaluationPlanRubric = "PassFail"
)

func NewSuccessEvaluationPlanRubricFromString(s string) (SuccessEvaluationPlanRubric, error) {
	switch s {
	case "NumericScale":
		return SuccessEvaluationPlanRubricNumericScale, nil
	case "DescriptiveScale":
		return SuccessEvaluationPlanRubricDescriptiveScale, nil
	case "Checklist":
		return SuccessEvaluationPlanRubricChecklist, nil
	case "Matrix":
		return SuccessEvaluationPlanRubricMatrix, nil
	case "PercentageScale":
		return SuccessEvaluationPlanRubricPercentageScale, nil
	case "LikertScale":
		return SuccessEvaluationPlanRubricLikertScale, nil
	case "AutomaticRubric":
		return SuccessEvaluationPlanRubricAutomaticRubric, nil
	case "PassFail":
		return SuccessEvaluationPlanRubricPassFail, nil
	}
	var t SuccessEvaluationPlanRubric
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SuccessEvaluationPlanRubric) Ptr() *SuccessEvaluationPlanRubric {
	return &s
}

type SummaryPlan struct {
	// These are the messages used to generate the summary.
	//
	// @default: ```
	// [
	//
	//	{
	//	  "role": "system",
	//	  "content": "You are an expert note-taker. You will be given a transcript of a call. Summarize the call in 2-3 sentences. DO NOT return anything except the summary."
	//	},
	//	{
	//	  "role": "user",
	//	  "content": "Here is the transcript:\n\n{{transcript}}\n\n"
	//	}
	//
	// ]```
	//
	// You can customize by providing any messages you want.
	//
	// Here are the template variables available:
	// - {{transcript}}: The transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: The system prompt of the call from `assistant.model.messages[type=system].content`
	Messages []map[string]interface{} `json:"messages,omitempty" url:"messages,omitempty"`
	// This determines whether a summary is generated and stored in `call.analysis.summary`. Defaults to true.
	//
	// Usage:
	// - If you want to disable the summary, set this to false.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is how long the request is tried before giving up. When request times out, `call.analysis.summary` will be empty.
	//
	// Usage:
	// - To guarantee the summary is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.
	//
	// @default 5 seconds
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" url:"timeoutSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SummaryPlan) GetMessages() []map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Messages
}

func (s *SummaryPlan) GetEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.Enabled
}

func (s *SummaryPlan) GetTimeoutSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.TimeoutSeconds
}

func (s *SummaryPlan) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SummaryPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler SummaryPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummaryPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummaryPlan) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncVoiceLibraryDto struct {
	// List of providers you want to sync.
	Providers []SyncVoiceLibraryDtoProvidersItem `json:"providers,omitempty" url:"providers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncVoiceLibraryDto) GetProviders() []SyncVoiceLibraryDtoProvidersItem {
	if s == nil {
		return nil
	}
	return s.Providers
}

func (s *SyncVoiceLibraryDto) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncVoiceLibraryDto) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncVoiceLibraryDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncVoiceLibraryDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncVoiceLibraryDto) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncVoiceLibraryDtoProvidersItem string

const (
	SyncVoiceLibraryDtoProvidersItemElevenLabs  SyncVoiceLibraryDtoProvidersItem = "11labs"
	SyncVoiceLibraryDtoProvidersItemAzure       SyncVoiceLibraryDtoProvidersItem = "azure"
	SyncVoiceLibraryDtoProvidersItemCartesia    SyncVoiceLibraryDtoProvidersItem = "cartesia"
	SyncVoiceLibraryDtoProvidersItemCustomVoice SyncVoiceLibraryDtoProvidersItem = "custom-voice"
	SyncVoiceLibraryDtoProvidersItemDeepgram    SyncVoiceLibraryDtoProvidersItem = "deepgram"
	SyncVoiceLibraryDtoProvidersItemLmnt        SyncVoiceLibraryDtoProvidersItem = "lmnt"
	SyncVoiceLibraryDtoProvidersItemNeets       SyncVoiceLibraryDtoProvidersItem = "neets"
	SyncVoiceLibraryDtoProvidersItemOpenai      SyncVoiceLibraryDtoProvidersItem = "openai"
	SyncVoiceLibraryDtoProvidersItemPlayht      SyncVoiceLibraryDtoProvidersItem = "playht"
	SyncVoiceLibraryDtoProvidersItemRimeAi      SyncVoiceLibraryDtoProvidersItem = "rime-ai"
	SyncVoiceLibraryDtoProvidersItemSmallestAi  SyncVoiceLibraryDtoProvidersItem = "smallest-ai"
	SyncVoiceLibraryDtoProvidersItemTavus       SyncVoiceLibraryDtoProvidersItem = "tavus"
)

func NewSyncVoiceLibraryDtoProvidersItemFromString(s string) (SyncVoiceLibraryDtoProvidersItem, error) {
	switch s {
	case "11labs":
		return SyncVoiceLibraryDtoProvidersItemElevenLabs, nil
	case "azure":
		return SyncVoiceLibraryDtoProvidersItemAzure, nil
	case "cartesia":
		return SyncVoiceLibraryDtoProvidersItemCartesia, nil
	case "custom-voice":
		return SyncVoiceLibraryDtoProvidersItemCustomVoice, nil
	case "deepgram":
		return SyncVoiceLibraryDtoProvidersItemDeepgram, nil
	case "lmnt":
		return SyncVoiceLibraryDtoProvidersItemLmnt, nil
	case "neets":
		return SyncVoiceLibraryDtoProvidersItemNeets, nil
	case "openai":
		return SyncVoiceLibraryDtoProvidersItemOpenai, nil
	case "playht":
		return SyncVoiceLibraryDtoProvidersItemPlayht, nil
	case "rime-ai":
		return SyncVoiceLibraryDtoProvidersItemRimeAi, nil
	case "smallest-ai":
		return SyncVoiceLibraryDtoProvidersItemSmallestAi, nil
	case "tavus":
		return SyncVoiceLibraryDtoProvidersItemTavus, nil
	}
	var t SyncVoiceLibraryDtoProvidersItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SyncVoiceLibraryDtoProvidersItem) Ptr() *SyncVoiceLibraryDtoProvidersItem {
	return &s
}

type TalkscriberTranscriber struct {
	// This is the transcription provider that will be used.
	// This is the model that will be used for the transcription.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py
	Language *TalkscriberTranscriberLanguage `json:"language,omitempty" url:"language,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TalkscriberTranscriber) GetLanguage() *TalkscriberTranscriberLanguage {
	if t == nil {
		return nil
	}
	return t.Language
}

func (t *TalkscriberTranscriber) Provider() string {
	return t.provider
}

func (t *TalkscriberTranscriber) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TalkscriberTranscriber) UnmarshalJSON(data []byte) error {
	type embed TalkscriberTranscriber
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TalkscriberTranscriber(unmarshaler.embed)
	if unmarshaler.Provider != "talkscriber" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "talkscriber", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TalkscriberTranscriber) MarshalJSON() ([]byte, error) {
	type embed TalkscriberTranscriber
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "talkscriber",
	}
	return json.Marshal(marshaler)
}

func (t *TalkscriberTranscriber) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py
type TalkscriberTranscriberLanguage string

const (
	TalkscriberTranscriberLanguageEn  TalkscriberTranscriberLanguage = "en"
	TalkscriberTranscriberLanguageZh  TalkscriberTranscriberLanguage = "zh"
	TalkscriberTranscriberLanguageDe  TalkscriberTranscriberLanguage = "de"
	TalkscriberTranscriberLanguageEs  TalkscriberTranscriberLanguage = "es"
	TalkscriberTranscriberLanguageRu  TalkscriberTranscriberLanguage = "ru"
	TalkscriberTranscriberLanguageKo  TalkscriberTranscriberLanguage = "ko"
	TalkscriberTranscriberLanguageFr  TalkscriberTranscriberLanguage = "fr"
	TalkscriberTranscriberLanguageJa  TalkscriberTranscriberLanguage = "ja"
	TalkscriberTranscriberLanguagePt  TalkscriberTranscriberLanguage = "pt"
	TalkscriberTranscriberLanguageTr  TalkscriberTranscriberLanguage = "tr"
	TalkscriberTranscriberLanguagePl  TalkscriberTranscriberLanguage = "pl"
	TalkscriberTranscriberLanguageCa  TalkscriberTranscriberLanguage = "ca"
	TalkscriberTranscriberLanguageNl  TalkscriberTranscriberLanguage = "nl"
	TalkscriberTranscriberLanguageAr  TalkscriberTranscriberLanguage = "ar"
	TalkscriberTranscriberLanguageSv  TalkscriberTranscriberLanguage = "sv"
	TalkscriberTranscriberLanguageIt  TalkscriberTranscriberLanguage = "it"
	TalkscriberTranscriberLanguageId  TalkscriberTranscriberLanguage = "id"
	TalkscriberTranscriberLanguageHi  TalkscriberTranscriberLanguage = "hi"
	TalkscriberTranscriberLanguageFi  TalkscriberTranscriberLanguage = "fi"
	TalkscriberTranscriberLanguageVi  TalkscriberTranscriberLanguage = "vi"
	TalkscriberTranscriberLanguageHe  TalkscriberTranscriberLanguage = "he"
	TalkscriberTranscriberLanguageUk  TalkscriberTranscriberLanguage = "uk"
	TalkscriberTranscriberLanguageEl  TalkscriberTranscriberLanguage = "el"
	TalkscriberTranscriberLanguageMs  TalkscriberTranscriberLanguage = "ms"
	TalkscriberTranscriberLanguageCs  TalkscriberTranscriberLanguage = "cs"
	TalkscriberTranscriberLanguageRo  TalkscriberTranscriberLanguage = "ro"
	TalkscriberTranscriberLanguageDa  TalkscriberTranscriberLanguage = "da"
	TalkscriberTranscriberLanguageHu  TalkscriberTranscriberLanguage = "hu"
	TalkscriberTranscriberLanguageTa  TalkscriberTranscriberLanguage = "ta"
	TalkscriberTranscriberLanguageNo  TalkscriberTranscriberLanguage = "no"
	TalkscriberTranscriberLanguageTh  TalkscriberTranscriberLanguage = "th"
	TalkscriberTranscriberLanguageUr  TalkscriberTranscriberLanguage = "ur"
	TalkscriberTranscriberLanguageHr  TalkscriberTranscriberLanguage = "hr"
	TalkscriberTranscriberLanguageBg  TalkscriberTranscriberLanguage = "bg"
	TalkscriberTranscriberLanguageLt  TalkscriberTranscriberLanguage = "lt"
	TalkscriberTranscriberLanguageLa  TalkscriberTranscriberLanguage = "la"
	TalkscriberTranscriberLanguageMi  TalkscriberTranscriberLanguage = "mi"
	TalkscriberTranscriberLanguageMl  TalkscriberTranscriberLanguage = "ml"
	TalkscriberTranscriberLanguageCy  TalkscriberTranscriberLanguage = "cy"
	TalkscriberTranscriberLanguageSk  TalkscriberTranscriberLanguage = "sk"
	TalkscriberTranscriberLanguageTe  TalkscriberTranscriberLanguage = "te"
	TalkscriberTranscriberLanguageFa  TalkscriberTranscriberLanguage = "fa"
	TalkscriberTranscriberLanguageLv  TalkscriberTranscriberLanguage = "lv"
	TalkscriberTranscriberLanguageBn  TalkscriberTranscriberLanguage = "bn"
	TalkscriberTranscriberLanguageSr  TalkscriberTranscriberLanguage = "sr"
	TalkscriberTranscriberLanguageAz  TalkscriberTranscriberLanguage = "az"
	TalkscriberTranscriberLanguageSl  TalkscriberTranscriberLanguage = "sl"
	TalkscriberTranscriberLanguageKn  TalkscriberTranscriberLanguage = "kn"
	TalkscriberTranscriberLanguageEt  TalkscriberTranscriberLanguage = "et"
	TalkscriberTranscriberLanguageMk  TalkscriberTranscriberLanguage = "mk"
	TalkscriberTranscriberLanguageBr  TalkscriberTranscriberLanguage = "br"
	TalkscriberTranscriberLanguageEu  TalkscriberTranscriberLanguage = "eu"
	TalkscriberTranscriberLanguageIs  TalkscriberTranscriberLanguage = "is"
	TalkscriberTranscriberLanguageHy  TalkscriberTranscriberLanguage = "hy"
	TalkscriberTranscriberLanguageNe  TalkscriberTranscriberLanguage = "ne"
	TalkscriberTranscriberLanguageMn  TalkscriberTranscriberLanguage = "mn"
	TalkscriberTranscriberLanguageBs  TalkscriberTranscriberLanguage = "bs"
	TalkscriberTranscriberLanguageKk  TalkscriberTranscriberLanguage = "kk"
	TalkscriberTranscriberLanguageSq  TalkscriberTranscriberLanguage = "sq"
	TalkscriberTranscriberLanguageSw  TalkscriberTranscriberLanguage = "sw"
	TalkscriberTranscriberLanguageGl  TalkscriberTranscriberLanguage = "gl"
	TalkscriberTranscriberLanguageMr  TalkscriberTranscriberLanguage = "mr"
	TalkscriberTranscriberLanguagePa  TalkscriberTranscriberLanguage = "pa"
	TalkscriberTranscriberLanguageSi  TalkscriberTranscriberLanguage = "si"
	TalkscriberTranscriberLanguageKm  TalkscriberTranscriberLanguage = "km"
	TalkscriberTranscriberLanguageSn  TalkscriberTranscriberLanguage = "sn"
	TalkscriberTranscriberLanguageYo  TalkscriberTranscriberLanguage = "yo"
	TalkscriberTranscriberLanguageSo  TalkscriberTranscriberLanguage = "so"
	TalkscriberTranscriberLanguageAf  TalkscriberTranscriberLanguage = "af"
	TalkscriberTranscriberLanguageOc  TalkscriberTranscriberLanguage = "oc"
	TalkscriberTranscriberLanguageKa  TalkscriberTranscriberLanguage = "ka"
	TalkscriberTranscriberLanguageBe  TalkscriberTranscriberLanguage = "be"
	TalkscriberTranscriberLanguageTg  TalkscriberTranscriberLanguage = "tg"
	TalkscriberTranscriberLanguageSd  TalkscriberTranscriberLanguage = "sd"
	TalkscriberTranscriberLanguageGu  TalkscriberTranscriberLanguage = "gu"
	TalkscriberTranscriberLanguageAm  TalkscriberTranscriberLanguage = "am"
	TalkscriberTranscriberLanguageYi  TalkscriberTranscriberLanguage = "yi"
	TalkscriberTranscriberLanguageLo  TalkscriberTranscriberLanguage = "lo"
	TalkscriberTranscriberLanguageUz  TalkscriberTranscriberLanguage = "uz"
	TalkscriberTranscriberLanguageFo  TalkscriberTranscriberLanguage = "fo"
	TalkscriberTranscriberLanguageHt  TalkscriberTranscriberLanguage = "ht"
	TalkscriberTranscriberLanguagePs  TalkscriberTranscriberLanguage = "ps"
	TalkscriberTranscriberLanguageTk  TalkscriberTranscriberLanguage = "tk"
	TalkscriberTranscriberLanguageNn  TalkscriberTranscriberLanguage = "nn"
	TalkscriberTranscriberLanguageMt  TalkscriberTranscriberLanguage = "mt"
	TalkscriberTranscriberLanguageSa  TalkscriberTranscriberLanguage = "sa"
	TalkscriberTranscriberLanguageLb  TalkscriberTranscriberLanguage = "lb"
	TalkscriberTranscriberLanguageMy  TalkscriberTranscriberLanguage = "my"
	TalkscriberTranscriberLanguageBo  TalkscriberTranscriberLanguage = "bo"
	TalkscriberTranscriberLanguageTl  TalkscriberTranscriberLanguage = "tl"
	TalkscriberTranscriberLanguageMg  TalkscriberTranscriberLanguage = "mg"
	TalkscriberTranscriberLanguageAs  TalkscriberTranscriberLanguage = "as"
	TalkscriberTranscriberLanguageTt  TalkscriberTranscriberLanguage = "tt"
	TalkscriberTranscriberLanguageHaw TalkscriberTranscriberLanguage = "haw"
	TalkscriberTranscriberLanguageLn  TalkscriberTranscriberLanguage = "ln"
	TalkscriberTranscriberLanguageHa  TalkscriberTranscriberLanguage = "ha"
	TalkscriberTranscriberLanguageBa  TalkscriberTranscriberLanguage = "ba"
	TalkscriberTranscriberLanguageJw  TalkscriberTranscriberLanguage = "jw"
	TalkscriberTranscriberLanguageSu  TalkscriberTranscriberLanguage = "su"
	TalkscriberTranscriberLanguageYue TalkscriberTranscriberLanguage = "yue"
)

func NewTalkscriberTranscriberLanguageFromString(s string) (TalkscriberTranscriberLanguage, error) {
	switch s {
	case "en":
		return TalkscriberTranscriberLanguageEn, nil
	case "zh":
		return TalkscriberTranscriberLanguageZh, nil
	case "de":
		return TalkscriberTranscriberLanguageDe, nil
	case "es":
		return TalkscriberTranscriberLanguageEs, nil
	case "ru":
		return TalkscriberTranscriberLanguageRu, nil
	case "ko":
		return TalkscriberTranscriberLanguageKo, nil
	case "fr":
		return TalkscriberTranscriberLanguageFr, nil
	case "ja":
		return TalkscriberTranscriberLanguageJa, nil
	case "pt":
		return TalkscriberTranscriberLanguagePt, nil
	case "tr":
		return TalkscriberTranscriberLanguageTr, nil
	case "pl":
		return TalkscriberTranscriberLanguagePl, nil
	case "ca":
		return TalkscriberTranscriberLanguageCa, nil
	case "nl":
		return TalkscriberTranscriberLanguageNl, nil
	case "ar":
		return TalkscriberTranscriberLanguageAr, nil
	case "sv":
		return TalkscriberTranscriberLanguageSv, nil
	case "it":
		return TalkscriberTranscriberLanguageIt, nil
	case "id":
		return TalkscriberTranscriberLanguageId, nil
	case "hi":
		return TalkscriberTranscriberLanguageHi, nil
	case "fi":
		return TalkscriberTranscriberLanguageFi, nil
	case "vi":
		return TalkscriberTranscriberLanguageVi, nil
	case "he":
		return TalkscriberTranscriberLanguageHe, nil
	case "uk":
		return TalkscriberTranscriberLanguageUk, nil
	case "el":
		return TalkscriberTranscriberLanguageEl, nil
	case "ms":
		return TalkscriberTranscriberLanguageMs, nil
	case "cs":
		return TalkscriberTranscriberLanguageCs, nil
	case "ro":
		return TalkscriberTranscriberLanguageRo, nil
	case "da":
		return TalkscriberTranscriberLanguageDa, nil
	case "hu":
		return TalkscriberTranscriberLanguageHu, nil
	case "ta":
		return TalkscriberTranscriberLanguageTa, nil
	case "no":
		return TalkscriberTranscriberLanguageNo, nil
	case "th":
		return TalkscriberTranscriberLanguageTh, nil
	case "ur":
		return TalkscriberTranscriberLanguageUr, nil
	case "hr":
		return TalkscriberTranscriberLanguageHr, nil
	case "bg":
		return TalkscriberTranscriberLanguageBg, nil
	case "lt":
		return TalkscriberTranscriberLanguageLt, nil
	case "la":
		return TalkscriberTranscriberLanguageLa, nil
	case "mi":
		return TalkscriberTranscriberLanguageMi, nil
	case "ml":
		return TalkscriberTranscriberLanguageMl, nil
	case "cy":
		return TalkscriberTranscriberLanguageCy, nil
	case "sk":
		return TalkscriberTranscriberLanguageSk, nil
	case "te":
		return TalkscriberTranscriberLanguageTe, nil
	case "fa":
		return TalkscriberTranscriberLanguageFa, nil
	case "lv":
		return TalkscriberTranscriberLanguageLv, nil
	case "bn":
		return TalkscriberTranscriberLanguageBn, nil
	case "sr":
		return TalkscriberTranscriberLanguageSr, nil
	case "az":
		return TalkscriberTranscriberLanguageAz, nil
	case "sl":
		return TalkscriberTranscriberLanguageSl, nil
	case "kn":
		return TalkscriberTranscriberLanguageKn, nil
	case "et":
		return TalkscriberTranscriberLanguageEt, nil
	case "mk":
		return TalkscriberTranscriberLanguageMk, nil
	case "br":
		return TalkscriberTranscriberLanguageBr, nil
	case "eu":
		return TalkscriberTranscriberLanguageEu, nil
	case "is":
		return TalkscriberTranscriberLanguageIs, nil
	case "hy":
		return TalkscriberTranscriberLanguageHy, nil
	case "ne":
		return TalkscriberTranscriberLanguageNe, nil
	case "mn":
		return TalkscriberTranscriberLanguageMn, nil
	case "bs":
		return TalkscriberTranscriberLanguageBs, nil
	case "kk":
		return TalkscriberTranscriberLanguageKk, nil
	case "sq":
		return TalkscriberTranscriberLanguageSq, nil
	case "sw":
		return TalkscriberTranscriberLanguageSw, nil
	case "gl":
		return TalkscriberTranscriberLanguageGl, nil
	case "mr":
		return TalkscriberTranscriberLanguageMr, nil
	case "pa":
		return TalkscriberTranscriberLanguagePa, nil
	case "si":
		return TalkscriberTranscriberLanguageSi, nil
	case "km":
		return TalkscriberTranscriberLanguageKm, nil
	case "sn":
		return TalkscriberTranscriberLanguageSn, nil
	case "yo":
		return TalkscriberTranscriberLanguageYo, nil
	case "so":
		return TalkscriberTranscriberLanguageSo, nil
	case "af":
		return TalkscriberTranscriberLanguageAf, nil
	case "oc":
		return TalkscriberTranscriberLanguageOc, nil
	case "ka":
		return TalkscriberTranscriberLanguageKa, nil
	case "be":
		return TalkscriberTranscriberLanguageBe, nil
	case "tg":
		return TalkscriberTranscriberLanguageTg, nil
	case "sd":
		return TalkscriberTranscriberLanguageSd, nil
	case "gu":
		return TalkscriberTranscriberLanguageGu, nil
	case "am":
		return TalkscriberTranscriberLanguageAm, nil
	case "yi":
		return TalkscriberTranscriberLanguageYi, nil
	case "lo":
		return TalkscriberTranscriberLanguageLo, nil
	case "uz":
		return TalkscriberTranscriberLanguageUz, nil
	case "fo":
		return TalkscriberTranscriberLanguageFo, nil
	case "ht":
		return TalkscriberTranscriberLanguageHt, nil
	case "ps":
		return TalkscriberTranscriberLanguagePs, nil
	case "tk":
		return TalkscriberTranscriberLanguageTk, nil
	case "nn":
		return TalkscriberTranscriberLanguageNn, nil
	case "mt":
		return TalkscriberTranscriberLanguageMt, nil
	case "sa":
		return TalkscriberTranscriberLanguageSa, nil
	case "lb":
		return TalkscriberTranscriberLanguageLb, nil
	case "my":
		return TalkscriberTranscriberLanguageMy, nil
	case "bo":
		return TalkscriberTranscriberLanguageBo, nil
	case "tl":
		return TalkscriberTranscriberLanguageTl, nil
	case "mg":
		return TalkscriberTranscriberLanguageMg, nil
	case "as":
		return TalkscriberTranscriberLanguageAs, nil
	case "tt":
		return TalkscriberTranscriberLanguageTt, nil
	case "haw":
		return TalkscriberTranscriberLanguageHaw, nil
	case "ln":
		return TalkscriberTranscriberLanguageLn, nil
	case "ha":
		return TalkscriberTranscriberLanguageHa, nil
	case "ba":
		return TalkscriberTranscriberLanguageBa, nil
	case "jw":
		return TalkscriberTranscriberLanguageJw, nil
	case "su":
		return TalkscriberTranscriberLanguageSu, nil
	case "yue":
		return TalkscriberTranscriberLanguageYue, nil
	}
	var t TalkscriberTranscriberLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TalkscriberTranscriberLanguage) Ptr() *TalkscriberTranscriberLanguage {
	return &t
}

type TavusConversationProperties struct {
	// The maximum duration of the call in seconds. The default `maxCallDuration` is 3600 seconds (1 hour).
	// Once the time limit specified by this parameter has been reached, the conversation will automatically shut down.
	MaxCallDuration *float64 `json:"maxCallDuration,omitempty" url:"maxCallDuration,omitempty"`
	// The duration in seconds after which the call will be automatically shut down once the last participant leaves.
	ParticipantLeftTimeout *float64 `json:"participantLeftTimeout,omitempty" url:"participantLeftTimeout,omitempty"`
	// Starting from conversation creation, the duration in seconds after which the call will be automatically shut down if no participant joins the call.
	// Default is 300 seconds (5 minutes).
	ParticipantAbsentTimeout *float64 `json:"participantAbsentTimeout,omitempty" url:"participantAbsentTimeout,omitempty"`
	// If true, the user will be able to record the conversation.
	EnableRecording *bool `json:"enableRecording,omitempty" url:"enableRecording,omitempty"`
	// If true, the user will be able to transcribe the conversation.
	// You can find more instructions on displaying transcriptions if you are using your custom DailyJS components here.
	// You need to have an event listener on Daily that listens for `app-messages`.
	EnableTranscription *bool `json:"enableTranscription,omitempty" url:"enableTranscription,omitempty"`
	// If true, the background will be replaced with a greenscreen (RGB values: `[0, 255, 155]`).
	// You can use WebGL on the frontend to make the greenscreen transparent or change its color.
	ApplyGreenscreen *bool `json:"applyGreenscreen,omitempty" url:"applyGreenscreen,omitempty"`
	// The language of the conversation. Please provide the **full language name**, not the two-letter code.
	// If you are using your own TTS voice, please ensure it supports the language you provide.
	// If you are using a stock replica or default persona, please note that only ElevenLabs and Cartesia supported languages are available.
	// You can find a full list of supported languages for Cartesia here, for ElevenLabs here, and for PlayHT here.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The name of the S3 bucket where the recording will be stored.
	RecordingS3BucketName *string `json:"recordingS3BucketName,omitempty" url:"recordingS3BucketName,omitempty"`
	// The region of the S3 bucket where the recording will be stored.
	RecordingS3BucketRegion *string `json:"recordingS3BucketRegion,omitempty" url:"recordingS3BucketRegion,omitempty"`
	// The ARN of the role that will be assumed to access the S3 bucket.
	AwsAssumeRoleArn *string `json:"awsAssumeRoleArn,omitempty" url:"awsAssumeRoleArn,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TavusConversationProperties) GetMaxCallDuration() *float64 {
	if t == nil {
		return nil
	}
	return t.MaxCallDuration
}

func (t *TavusConversationProperties) GetParticipantLeftTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.ParticipantLeftTimeout
}

func (t *TavusConversationProperties) GetParticipantAbsentTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.ParticipantAbsentTimeout
}

func (t *TavusConversationProperties) GetEnableRecording() *bool {
	if t == nil {
		return nil
	}
	return t.EnableRecording
}

func (t *TavusConversationProperties) GetEnableTranscription() *bool {
	if t == nil {
		return nil
	}
	return t.EnableTranscription
}

func (t *TavusConversationProperties) GetApplyGreenscreen() *bool {
	if t == nil {
		return nil
	}
	return t.ApplyGreenscreen
}

func (t *TavusConversationProperties) GetLanguage() *string {
	if t == nil {
		return nil
	}
	return t.Language
}

func (t *TavusConversationProperties) GetRecordingS3BucketName() *string {
	if t == nil {
		return nil
	}
	return t.RecordingS3BucketName
}

func (t *TavusConversationProperties) GetRecordingS3BucketRegion() *string {
	if t == nil {
		return nil
	}
	return t.RecordingS3BucketRegion
}

func (t *TavusConversationProperties) GetAwsAssumeRoleArn() *string {
	if t == nil {
		return nil
	}
	return t.AwsAssumeRoleArn
}

func (t *TavusConversationProperties) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TavusConversationProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler TavusConversationProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TavusConversationProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TavusConversationProperties) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TavusCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TavusCredential) GetApiKey() string {
	if t == nil {
		return ""
	}
	return t.ApiKey
}

func (t *TavusCredential) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TavusCredential) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TavusCredential) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TavusCredential) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TavusCredential) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TavusCredential) Provider() string {
	return t.provider
}

func (t *TavusCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TavusCredential) UnmarshalJSON(data []byte) error {
	type embed TavusCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TavusCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "tavus" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tavus", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TavusCredential) MarshalJSON() ([]byte, error) {
	type embed TavusCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Provider:  "tavus",
	}
	return json.Marshal(marshaler)
}

func (t *TavusCredential) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TavusVoice struct {
	// This is the voice provider that will be used.
	// This is the provider-specific ID that will be used.
	VoiceId *TavusVoiceVoiceId `json:"voiceId,omitempty" url:"voiceId,omitempty"`
	// This is the plan for chunking the model output before it is sent to the voice provider.
	ChunkPlan *ChunkPlan `json:"chunkPlan,omitempty" url:"chunkPlan,omitempty"`
	// This is the unique identifier for the persona that the replica will use in the conversation.
	PersonaId *string `json:"personaId,omitempty" url:"personaId,omitempty"`
	// This is the url that will receive webhooks with updates regarding the conversation state.
	CallbackUrl *string `json:"callbackUrl,omitempty" url:"callbackUrl,omitempty"`
	// This is the name for the conversation.
	ConversationName *string `json:"conversationName,omitempty" url:"conversationName,omitempty"`
	// This is the context that will be appended to any context provided in the persona, if one is provided.
	ConversationalContext *string `json:"conversationalContext,omitempty" url:"conversationalContext,omitempty"`
	// This is the custom greeting that the replica will give once a participant joines the conversation.
	CustomGreeting *string `json:"customGreeting,omitempty" url:"customGreeting,omitempty"`
	// These are optional properties used to customize the conversation.
	Properties *TavusConversationProperties `json:"properties,omitempty" url:"properties,omitempty"`
	// This is the plan for voice provider fallbacks in the event that the primary voice provider fails.
	FallbackPlan *FallbackPlan `json:"fallbackPlan,omitempty" url:"fallbackPlan,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TavusVoice) GetVoiceId() *TavusVoiceVoiceId {
	if t == nil {
		return nil
	}
	return t.VoiceId
}

func (t *TavusVoice) GetChunkPlan() *ChunkPlan {
	if t == nil {
		return nil
	}
	return t.ChunkPlan
}

func (t *TavusVoice) GetPersonaId() *string {
	if t == nil {
		return nil
	}
	return t.PersonaId
}

func (t *TavusVoice) GetCallbackUrl() *string {
	if t == nil {
		return nil
	}
	return t.CallbackUrl
}

func (t *TavusVoice) GetConversationName() *string {
	if t == nil {
		return nil
	}
	return t.ConversationName
}

func (t *TavusVoice) GetConversationalContext() *string {
	if t == nil {
		return nil
	}
	return t.ConversationalContext
}

func (t *TavusVoice) GetCustomGreeting() *string {
	if t == nil {
		return nil
	}
	return t.CustomGreeting
}

func (t *TavusVoice) GetProperties() *TavusConversationProperties {
	if t == nil {
		return nil
	}
	return t.Properties
}

func (t *TavusVoice) GetFallbackPlan() *FallbackPlan {
	if t == nil {
		return nil
	}
	return t.FallbackPlan
}

func (t *TavusVoice) Provider() string {
	return t.provider
}

func (t *TavusVoice) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TavusVoice) UnmarshalJSON(data []byte) error {
	type embed TavusVoice
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TavusVoice(unmarshaler.embed)
	if unmarshaler.Provider != "tavus" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tavus", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TavusVoice) MarshalJSON() ([]byte, error) {
	type embed TavusVoice
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "tavus",
	}
	return json.Marshal(marshaler)
}

func (t *TavusVoice) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the provider-specific ID that will be used.
type TavusVoiceVoiceId struct {
	r52da2535aStringLiteral string
	String                  string

	typ string
}

func NewTavusVoiceVoiceIdWithR52da2535aStringLiteral() *TavusVoiceVoiceId {
	return &TavusVoiceVoiceId{typ: "r52da2535aStringLiteral", r52da2535aStringLiteral: "r52da2535a"}
}

func (t *TavusVoiceVoiceId) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TavusVoiceVoiceId) R52da2535aStringLiteral() string {
	return t.r52da2535aStringLiteral
}

func (t *TavusVoiceVoiceId) UnmarshalJSON(data []byte) error {
	var valueR52da2535aStringLiteral string
	if err := json.Unmarshal(data, &valueR52da2535aStringLiteral); err == nil {
		t.typ = "r52da2535aStringLiteral"
		t.r52da2535aStringLiteral = valueR52da2535aStringLiteral
		if t.r52da2535aStringLiteral != "r52da2535a" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "r52da2535a", valueR52da2535aStringLiteral)
		}
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TavusVoiceVoiceId) MarshalJSON() ([]byte, error) {
	if t.typ == "r52da2535aStringLiteral" || t.r52da2535aStringLiteral != "" {
		return json.Marshal("r52da2535a")
	}
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TavusVoiceVoiceIdVisitor interface {
	VisitR52da2535aStringLiteral(string) error
	VisitString(string) error
}

func (t *TavusVoiceVoiceId) Accept(visitor TavusVoiceVoiceIdVisitor) error {
	if t.typ == "r52da2535aStringLiteral" || t.r52da2535aStringLiteral != "" {
		return visitor.VisitR52da2535aStringLiteral(t.r52da2535aStringLiteral)
	}
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type Template struct {
	Details         *TemplateDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *TemplateProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata    `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *TemplateVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string           `json:"name,omitempty" url:"name,omitempty"`
	Provider *TemplateProvider `json:"provider,omitempty" url:"provider,omitempty"`
	// The unique identifier for the template.
	Id string `json:"id" url:"id"`
	// The unique identifier for the organization that this template belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// The ISO 8601 date-time string of when the template was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The ISO 8601 date-time string of when the template was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	type_     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Template) GetDetails() *TemplateDetails {
	if t == nil {
		return nil
	}
	return t.Details
}

func (t *Template) GetProviderDetails() *TemplateProviderDetails {
	if t == nil {
		return nil
	}
	return t.ProviderDetails
}

func (t *Template) GetMetadata() *ToolTemplateMetadata {
	if t == nil {
		return nil
	}
	return t.Metadata
}

func (t *Template) GetVisibility() *TemplateVisibility {
	if t == nil {
		return nil
	}
	return t.Visibility
}

func (t *Template) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *Template) GetProvider() *TemplateProvider {
	if t == nil {
		return nil
	}
	return t.Provider
}

func (t *Template) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *Template) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *Template) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *Template) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *Template) Type() string {
	return t.type_
}

func (t *Template) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Template) UnmarshalJSON(data []byte) error {
	type embed Template
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Template(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "tool", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Template) MarshalJSON() ([]byte, error) {
	type embed Template
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Type      string             `json:"type"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Type:      "tool",
	}
	return json.Marshal(marshaler)
}

func (t *Template) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TemplateDetails struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (t *TemplateDetails) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if t == nil {
		return nil
	}
	return t.CreateDtmfToolDto
}

func (t *TemplateDetails) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateEndCallToolDto
}

func (t *TemplateDetails) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if t == nil {
		return nil
	}
	return t.CreateVoicemailToolDto
}

func (t *TemplateDetails) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if t == nil {
		return nil
	}
	return t.CreateFunctionToolDto
}

func (t *TemplateDetails) GetCreateGhlToolDto() *CreateGhlToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGhlToolDto
}

func (t *TemplateDetails) GetCreateMakeToolDto() *CreateMakeToolDto {
	if t == nil {
		return nil
	}
	return t.CreateMakeToolDto
}

func (t *TemplateDetails) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTransferCallToolDto
}

func (t *TemplateDetails) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.typ = "CreateDtmfToolDto"
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.typ = "CreateEndCallToolDto"
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		t.typ = "CreateVoicemailToolDto"
		t.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.typ = "CreateFunctionToolDto"
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		t.typ = "CreateGhlToolDto"
		t.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		t.typ = "CreateMakeToolDto"
		t.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.typ = "CreateTransferCallToolDto"
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TemplateDetails) MarshalJSON() ([]byte, error) {
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateVoicemailToolDto" || t.CreateVoicemailToolDto != nil {
		return json.Marshal(t.CreateVoicemailToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGhlToolDto" || t.CreateGhlToolDto != nil {
		return json.Marshal(t.CreateGhlToolDto)
	}
	if t.typ == "CreateMakeToolDto" || t.CreateMakeToolDto != nil {
		return json.Marshal(t.CreateMakeToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateDetailsVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (t *TemplateDetails) Accept(visitor TemplateDetailsVisitor) error {
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateVoicemailToolDto" || t.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(t.CreateVoicemailToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGhlToolDto" || t.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(t.CreateGhlToolDto)
	}
	if t.typ == "CreateMakeToolDto" || t.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(t.CreateMakeToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateProvider string

const (
	TemplateProviderMake        TemplateProvider = "make"
	TemplateProviderGohighlevel TemplateProvider = "gohighlevel"
	TemplateProviderFunction    TemplateProvider = "function"
)

func NewTemplateProviderFromString(s string) (TemplateProvider, error) {
	switch s {
	case "make":
		return TemplateProviderMake, nil
	case "gohighlevel":
		return TemplateProviderGohighlevel, nil
	case "function":
		return TemplateProviderFunction, nil
	}
	var t TemplateProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TemplateProvider) Ptr() *TemplateProvider {
	return &t
}

type TemplateProviderDetails struct {
	MakeToolProviderDetails     *MakeToolProviderDetails
	GhlToolProviderDetails      *GhlToolProviderDetails
	FunctionToolProviderDetails *FunctionToolProviderDetails

	typ string
}

func (t *TemplateProviderDetails) GetMakeToolProviderDetails() *MakeToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.MakeToolProviderDetails
}

func (t *TemplateProviderDetails) GetGhlToolProviderDetails() *GhlToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.GhlToolProviderDetails
}

func (t *TemplateProviderDetails) GetFunctionToolProviderDetails() *FunctionToolProviderDetails {
	if t == nil {
		return nil
	}
	return t.FunctionToolProviderDetails
}

func (t *TemplateProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		t.typ = "MakeToolProviderDetails"
		t.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		t.typ = "GhlToolProviderDetails"
		t.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		t.typ = "FunctionToolProviderDetails"
		t.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TemplateProviderDetails) MarshalJSON() ([]byte, error) {
	if t.typ == "MakeToolProviderDetails" || t.MakeToolProviderDetails != nil {
		return json.Marshal(t.MakeToolProviderDetails)
	}
	if t.typ == "GhlToolProviderDetails" || t.GhlToolProviderDetails != nil {
		return json.Marshal(t.GhlToolProviderDetails)
	}
	if t.typ == "FunctionToolProviderDetails" || t.FunctionToolProviderDetails != nil {
		return json.Marshal(t.FunctionToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
}

func (t *TemplateProviderDetails) Accept(visitor TemplateProviderDetailsVisitor) error {
	if t.typ == "MakeToolProviderDetails" || t.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(t.MakeToolProviderDetails)
	}
	if t.typ == "GhlToolProviderDetails" || t.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(t.GhlToolProviderDetails)
	}
	if t.typ == "FunctionToolProviderDetails" || t.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(t.FunctionToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TemplateVisibility string

const (
	TemplateVisibilityPublic  TemplateVisibility = "public"
	TemplateVisibilityPrivate TemplateVisibility = "private"
)

func NewTemplateVisibilityFromString(s string) (TemplateVisibility, error) {
	switch s {
	case "public":
		return TemplateVisibilityPublic, nil
	case "private":
		return TemplateVisibilityPrivate, nil
	}
	var t TemplateVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TemplateVisibility) Ptr() *TemplateVisibility {
	return &t
}

type TextContent struct {
	Text     string              `json:"text" url:"text"`
	Language TextContentLanguage `json:"language" url:"language"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TextContent) GetText() string {
	if t == nil {
		return ""
	}
	return t.Text
}

func (t *TextContent) GetLanguage() TextContentLanguage {
	if t == nil {
		return ""
	}
	return t.Language
}

func (t *TextContent) Type() string {
	return t.type_
}

func (t *TextContent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextContent) UnmarshalJSON(data []byte) error {
	type embed TextContent
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextContent(unmarshaler.embed)
	if unmarshaler.Type != "text" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "text", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextContent) MarshalJSON() ([]byte, error) {
	type embed TextContent
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "text",
	}
	return json.Marshal(marshaler)
}

func (t *TextContent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TextContentLanguage string

const (
	TextContentLanguageAa  TextContentLanguage = "aa"
	TextContentLanguageAb  TextContentLanguage = "ab"
	TextContentLanguageAe  TextContentLanguage = "ae"
	TextContentLanguageAf  TextContentLanguage = "af"
	TextContentLanguageAk  TextContentLanguage = "ak"
	TextContentLanguageAm  TextContentLanguage = "am"
	TextContentLanguageAn  TextContentLanguage = "an"
	TextContentLanguageAr  TextContentLanguage = "ar"
	TextContentLanguageAs  TextContentLanguage = "as"
	TextContentLanguageAv  TextContentLanguage = "av"
	TextContentLanguageAy  TextContentLanguage = "ay"
	TextContentLanguageAz  TextContentLanguage = "az"
	TextContentLanguageBa  TextContentLanguage = "ba"
	TextContentLanguageBe  TextContentLanguage = "be"
	TextContentLanguageBg  TextContentLanguage = "bg"
	TextContentLanguageBh  TextContentLanguage = "bh"
	TextContentLanguageBi  TextContentLanguage = "bi"
	TextContentLanguageBm  TextContentLanguage = "bm"
	TextContentLanguageBn  TextContentLanguage = "bn"
	TextContentLanguageBo  TextContentLanguage = "bo"
	TextContentLanguageBr  TextContentLanguage = "br"
	TextContentLanguageBs  TextContentLanguage = "bs"
	TextContentLanguageCa  TextContentLanguage = "ca"
	TextContentLanguageCe  TextContentLanguage = "ce"
	TextContentLanguageCh  TextContentLanguage = "ch"
	TextContentLanguageCo  TextContentLanguage = "co"
	TextContentLanguageCr  TextContentLanguage = "cr"
	TextContentLanguageCs  TextContentLanguage = "cs"
	TextContentLanguageCu  TextContentLanguage = "cu"
	TextContentLanguageCv  TextContentLanguage = "cv"
	TextContentLanguageCy  TextContentLanguage = "cy"
	TextContentLanguageDa  TextContentLanguage = "da"
	TextContentLanguageDe  TextContentLanguage = "de"
	TextContentLanguageDv  TextContentLanguage = "dv"
	TextContentLanguageDz  TextContentLanguage = "dz"
	TextContentLanguageEe  TextContentLanguage = "ee"
	TextContentLanguageEl  TextContentLanguage = "el"
	TextContentLanguageEn  TextContentLanguage = "en"
	TextContentLanguageEo  TextContentLanguage = "eo"
	TextContentLanguageEs  TextContentLanguage = "es"
	TextContentLanguageEt  TextContentLanguage = "et"
	TextContentLanguageEu  TextContentLanguage = "eu"
	TextContentLanguageFa  TextContentLanguage = "fa"
	TextContentLanguageFf  TextContentLanguage = "ff"
	TextContentLanguageFi  TextContentLanguage = "fi"
	TextContentLanguageFj  TextContentLanguage = "fj"
	TextContentLanguageFo  TextContentLanguage = "fo"
	TextContentLanguageFr  TextContentLanguage = "fr"
	TextContentLanguageFy  TextContentLanguage = "fy"
	TextContentLanguageGa  TextContentLanguage = "ga"
	TextContentLanguageGd  TextContentLanguage = "gd"
	TextContentLanguageGl  TextContentLanguage = "gl"
	TextContentLanguageGn  TextContentLanguage = "gn"
	TextContentLanguageGu  TextContentLanguage = "gu"
	TextContentLanguageGv  TextContentLanguage = "gv"
	TextContentLanguageHa  TextContentLanguage = "ha"
	TextContentLanguageHe  TextContentLanguage = "he"
	TextContentLanguageHi  TextContentLanguage = "hi"
	TextContentLanguageHo  TextContentLanguage = "ho"
	TextContentLanguageHr  TextContentLanguage = "hr"
	TextContentLanguageHt  TextContentLanguage = "ht"
	TextContentLanguageHu  TextContentLanguage = "hu"
	TextContentLanguageHy  TextContentLanguage = "hy"
	TextContentLanguageHz  TextContentLanguage = "hz"
	TextContentLanguageIa  TextContentLanguage = "ia"
	TextContentLanguageId  TextContentLanguage = "id"
	TextContentLanguageIe  TextContentLanguage = "ie"
	TextContentLanguageIg  TextContentLanguage = "ig"
	TextContentLanguageIi  TextContentLanguage = "ii"
	TextContentLanguageIk  TextContentLanguage = "ik"
	TextContentLanguageIo  TextContentLanguage = "io"
	TextContentLanguageIs  TextContentLanguage = "is"
	TextContentLanguageIt  TextContentLanguage = "it"
	TextContentLanguageIu  TextContentLanguage = "iu"
	TextContentLanguageJa  TextContentLanguage = "ja"
	TextContentLanguageJv  TextContentLanguage = "jv"
	TextContentLanguageKa  TextContentLanguage = "ka"
	TextContentLanguageKg  TextContentLanguage = "kg"
	TextContentLanguageKi  TextContentLanguage = "ki"
	TextContentLanguageKj  TextContentLanguage = "kj"
	TextContentLanguageKk  TextContentLanguage = "kk"
	TextContentLanguageKl  TextContentLanguage = "kl"
	TextContentLanguageKm  TextContentLanguage = "km"
	TextContentLanguageKn  TextContentLanguage = "kn"
	TextContentLanguageKo  TextContentLanguage = "ko"
	TextContentLanguageKr  TextContentLanguage = "kr"
	TextContentLanguageKs  TextContentLanguage = "ks"
	TextContentLanguageKu  TextContentLanguage = "ku"
	TextContentLanguageKv  TextContentLanguage = "kv"
	TextContentLanguageKw  TextContentLanguage = "kw"
	TextContentLanguageKy  TextContentLanguage = "ky"
	TextContentLanguageLa  TextContentLanguage = "la"
	TextContentLanguageLb  TextContentLanguage = "lb"
	TextContentLanguageLg  TextContentLanguage = "lg"
	TextContentLanguageLi  TextContentLanguage = "li"
	TextContentLanguageLn  TextContentLanguage = "ln"
	TextContentLanguageLo  TextContentLanguage = "lo"
	TextContentLanguageLt  TextContentLanguage = "lt"
	TextContentLanguageLu  TextContentLanguage = "lu"
	TextContentLanguageLv  TextContentLanguage = "lv"
	TextContentLanguageMg  TextContentLanguage = "mg"
	TextContentLanguageMh  TextContentLanguage = "mh"
	TextContentLanguageMi  TextContentLanguage = "mi"
	TextContentLanguageMk  TextContentLanguage = "mk"
	TextContentLanguageMl  TextContentLanguage = "ml"
	TextContentLanguageMn  TextContentLanguage = "mn"
	TextContentLanguageMr  TextContentLanguage = "mr"
	TextContentLanguageMs  TextContentLanguage = "ms"
	TextContentLanguageMt  TextContentLanguage = "mt"
	TextContentLanguageMy  TextContentLanguage = "my"
	TextContentLanguageNa  TextContentLanguage = "na"
	TextContentLanguageNb  TextContentLanguage = "nb"
	TextContentLanguageNd  TextContentLanguage = "nd"
	TextContentLanguageNe  TextContentLanguage = "ne"
	TextContentLanguageNg  TextContentLanguage = "ng"
	TextContentLanguageNl  TextContentLanguage = "nl"
	TextContentLanguageNn  TextContentLanguage = "nn"
	TextContentLanguageNo  TextContentLanguage = "no"
	TextContentLanguageNr  TextContentLanguage = "nr"
	TextContentLanguageNv  TextContentLanguage = "nv"
	TextContentLanguageNy  TextContentLanguage = "ny"
	TextContentLanguageOc  TextContentLanguage = "oc"
	TextContentLanguageOj  TextContentLanguage = "oj"
	TextContentLanguageOm  TextContentLanguage = "om"
	TextContentLanguageOr  TextContentLanguage = "or"
	TextContentLanguageOs  TextContentLanguage = "os"
	TextContentLanguagePa  TextContentLanguage = "pa"
	TextContentLanguagePi  TextContentLanguage = "pi"
	TextContentLanguagePl  TextContentLanguage = "pl"
	TextContentLanguagePs  TextContentLanguage = "ps"
	TextContentLanguagePt  TextContentLanguage = "pt"
	TextContentLanguageQu  TextContentLanguage = "qu"
	TextContentLanguageRm  TextContentLanguage = "rm"
	TextContentLanguageRn  TextContentLanguage = "rn"
	TextContentLanguageRo  TextContentLanguage = "ro"
	TextContentLanguageRu  TextContentLanguage = "ru"
	TextContentLanguageRw  TextContentLanguage = "rw"
	TextContentLanguageSa  TextContentLanguage = "sa"
	TextContentLanguageSc  TextContentLanguage = "sc"
	TextContentLanguageSd  TextContentLanguage = "sd"
	TextContentLanguageSe  TextContentLanguage = "se"
	TextContentLanguageSg  TextContentLanguage = "sg"
	TextContentLanguageSi  TextContentLanguage = "si"
	TextContentLanguageSk  TextContentLanguage = "sk"
	TextContentLanguageSl  TextContentLanguage = "sl"
	TextContentLanguageSm  TextContentLanguage = "sm"
	TextContentLanguageSn  TextContentLanguage = "sn"
	TextContentLanguageSo  TextContentLanguage = "so"
	TextContentLanguageSq  TextContentLanguage = "sq"
	TextContentLanguageSr  TextContentLanguage = "sr"
	TextContentLanguageSs  TextContentLanguage = "ss"
	TextContentLanguageSt  TextContentLanguage = "st"
	TextContentLanguageSu  TextContentLanguage = "su"
	TextContentLanguageSv  TextContentLanguage = "sv"
	TextContentLanguageSw  TextContentLanguage = "sw"
	TextContentLanguageTa  TextContentLanguage = "ta"
	TextContentLanguageTe  TextContentLanguage = "te"
	TextContentLanguageTg  TextContentLanguage = "tg"
	TextContentLanguageTh  TextContentLanguage = "th"
	TextContentLanguageTi  TextContentLanguage = "ti"
	TextContentLanguageTk  TextContentLanguage = "tk"
	TextContentLanguageTl  TextContentLanguage = "tl"
	TextContentLanguageTn  TextContentLanguage = "tn"
	TextContentLanguageTo  TextContentLanguage = "to"
	TextContentLanguageTr  TextContentLanguage = "tr"
	TextContentLanguageTs  TextContentLanguage = "ts"
	TextContentLanguageTt  TextContentLanguage = "tt"
	TextContentLanguageTw  TextContentLanguage = "tw"
	TextContentLanguageTy  TextContentLanguage = "ty"
	TextContentLanguageUg  TextContentLanguage = "ug"
	TextContentLanguageUk  TextContentLanguage = "uk"
	TextContentLanguageUr  TextContentLanguage = "ur"
	TextContentLanguageUz  TextContentLanguage = "uz"
	TextContentLanguageVe  TextContentLanguage = "ve"
	TextContentLanguageVi  TextContentLanguage = "vi"
	TextContentLanguageVo  TextContentLanguage = "vo"
	TextContentLanguageWa  TextContentLanguage = "wa"
	TextContentLanguageWo  TextContentLanguage = "wo"
	TextContentLanguageXh  TextContentLanguage = "xh"
	TextContentLanguageYi  TextContentLanguage = "yi"
	TextContentLanguageYue TextContentLanguage = "yue"
	TextContentLanguageYo  TextContentLanguage = "yo"
	TextContentLanguageZa  TextContentLanguage = "za"
	TextContentLanguageZh  TextContentLanguage = "zh"
	TextContentLanguageZu  TextContentLanguage = "zu"
)

func NewTextContentLanguageFromString(s string) (TextContentLanguage, error) {
	switch s {
	case "aa":
		return TextContentLanguageAa, nil
	case "ab":
		return TextContentLanguageAb, nil
	case "ae":
		return TextContentLanguageAe, nil
	case "af":
		return TextContentLanguageAf, nil
	case "ak":
		return TextContentLanguageAk, nil
	case "am":
		return TextContentLanguageAm, nil
	case "an":
		return TextContentLanguageAn, nil
	case "ar":
		return TextContentLanguageAr, nil
	case "as":
		return TextContentLanguageAs, nil
	case "av":
		return TextContentLanguageAv, nil
	case "ay":
		return TextContentLanguageAy, nil
	case "az":
		return TextContentLanguageAz, nil
	case "ba":
		return TextContentLanguageBa, nil
	case "be":
		return TextContentLanguageBe, nil
	case "bg":
		return TextContentLanguageBg, nil
	case "bh":
		return TextContentLanguageBh, nil
	case "bi":
		return TextContentLanguageBi, nil
	case "bm":
		return TextContentLanguageBm, nil
	case "bn":
		return TextContentLanguageBn, nil
	case "bo":
		return TextContentLanguageBo, nil
	case "br":
		return TextContentLanguageBr, nil
	case "bs":
		return TextContentLanguageBs, nil
	case "ca":
		return TextContentLanguageCa, nil
	case "ce":
		return TextContentLanguageCe, nil
	case "ch":
		return TextContentLanguageCh, nil
	case "co":
		return TextContentLanguageCo, nil
	case "cr":
		return TextContentLanguageCr, nil
	case "cs":
		return TextContentLanguageCs, nil
	case "cu":
		return TextContentLanguageCu, nil
	case "cv":
		return TextContentLanguageCv, nil
	case "cy":
		return TextContentLanguageCy, nil
	case "da":
		return TextContentLanguageDa, nil
	case "de":
		return TextContentLanguageDe, nil
	case "dv":
		return TextContentLanguageDv, nil
	case "dz":
		return TextContentLanguageDz, nil
	case "ee":
		return TextContentLanguageEe, nil
	case "el":
		return TextContentLanguageEl, nil
	case "en":
		return TextContentLanguageEn, nil
	case "eo":
		return TextContentLanguageEo, nil
	case "es":
		return TextContentLanguageEs, nil
	case "et":
		return TextContentLanguageEt, nil
	case "eu":
		return TextContentLanguageEu, nil
	case "fa":
		return TextContentLanguageFa, nil
	case "ff":
		return TextContentLanguageFf, nil
	case "fi":
		return TextContentLanguageFi, nil
	case "fj":
		return TextContentLanguageFj, nil
	case "fo":
		return TextContentLanguageFo, nil
	case "fr":
		return TextContentLanguageFr, nil
	case "fy":
		return TextContentLanguageFy, nil
	case "ga":
		return TextContentLanguageGa, nil
	case "gd":
		return TextContentLanguageGd, nil
	case "gl":
		return TextContentLanguageGl, nil
	case "gn":
		return TextContentLanguageGn, nil
	case "gu":
		return TextContentLanguageGu, nil
	case "gv":
		return TextContentLanguageGv, nil
	case "ha":
		return TextContentLanguageHa, nil
	case "he":
		return TextContentLanguageHe, nil
	case "hi":
		return TextContentLanguageHi, nil
	case "ho":
		return TextContentLanguageHo, nil
	case "hr":
		return TextContentLanguageHr, nil
	case "ht":
		return TextContentLanguageHt, nil
	case "hu":
		return TextContentLanguageHu, nil
	case "hy":
		return TextContentLanguageHy, nil
	case "hz":
		return TextContentLanguageHz, nil
	case "ia":
		return TextContentLanguageIa, nil
	case "id":
		return TextContentLanguageId, nil
	case "ie":
		return TextContentLanguageIe, nil
	case "ig":
		return TextContentLanguageIg, nil
	case "ii":
		return TextContentLanguageIi, nil
	case "ik":
		return TextContentLanguageIk, nil
	case "io":
		return TextContentLanguageIo, nil
	case "is":
		return TextContentLanguageIs, nil
	case "it":
		return TextContentLanguageIt, nil
	case "iu":
		return TextContentLanguageIu, nil
	case "ja":
		return TextContentLanguageJa, nil
	case "jv":
		return TextContentLanguageJv, nil
	case "ka":
		return TextContentLanguageKa, nil
	case "kg":
		return TextContentLanguageKg, nil
	case "ki":
		return TextContentLanguageKi, nil
	case "kj":
		return TextContentLanguageKj, nil
	case "kk":
		return TextContentLanguageKk, nil
	case "kl":
		return TextContentLanguageKl, nil
	case "km":
		return TextContentLanguageKm, nil
	case "kn":
		return TextContentLanguageKn, nil
	case "ko":
		return TextContentLanguageKo, nil
	case "kr":
		return TextContentLanguageKr, nil
	case "ks":
		return TextContentLanguageKs, nil
	case "ku":
		return TextContentLanguageKu, nil
	case "kv":
		return TextContentLanguageKv, nil
	case "kw":
		return TextContentLanguageKw, nil
	case "ky":
		return TextContentLanguageKy, nil
	case "la":
		return TextContentLanguageLa, nil
	case "lb":
		return TextContentLanguageLb, nil
	case "lg":
		return TextContentLanguageLg, nil
	case "li":
		return TextContentLanguageLi, nil
	case "ln":
		return TextContentLanguageLn, nil
	case "lo":
		return TextContentLanguageLo, nil
	case "lt":
		return TextContentLanguageLt, nil
	case "lu":
		return TextContentLanguageLu, nil
	case "lv":
		return TextContentLanguageLv, nil
	case "mg":
		return TextContentLanguageMg, nil
	case "mh":
		return TextContentLanguageMh, nil
	case "mi":
		return TextContentLanguageMi, nil
	case "mk":
		return TextContentLanguageMk, nil
	case "ml":
		return TextContentLanguageMl, nil
	case "mn":
		return TextContentLanguageMn, nil
	case "mr":
		return TextContentLanguageMr, nil
	case "ms":
		return TextContentLanguageMs, nil
	case "mt":
		return TextContentLanguageMt, nil
	case "my":
		return TextContentLanguageMy, nil
	case "na":
		return TextContentLanguageNa, nil
	case "nb":
		return TextContentLanguageNb, nil
	case "nd":
		return TextContentLanguageNd, nil
	case "ne":
		return TextContentLanguageNe, nil
	case "ng":
		return TextContentLanguageNg, nil
	case "nl":
		return TextContentLanguageNl, nil
	case "nn":
		return TextContentLanguageNn, nil
	case "no":
		return TextContentLanguageNo, nil
	case "nr":
		return TextContentLanguageNr, nil
	case "nv":
		return TextContentLanguageNv, nil
	case "ny":
		return TextContentLanguageNy, nil
	case "oc":
		return TextContentLanguageOc, nil
	case "oj":
		return TextContentLanguageOj, nil
	case "om":
		return TextContentLanguageOm, nil
	case "or":
		return TextContentLanguageOr, nil
	case "os":
		return TextContentLanguageOs, nil
	case "pa":
		return TextContentLanguagePa, nil
	case "pi":
		return TextContentLanguagePi, nil
	case "pl":
		return TextContentLanguagePl, nil
	case "ps":
		return TextContentLanguagePs, nil
	case "pt":
		return TextContentLanguagePt, nil
	case "qu":
		return TextContentLanguageQu, nil
	case "rm":
		return TextContentLanguageRm, nil
	case "rn":
		return TextContentLanguageRn, nil
	case "ro":
		return TextContentLanguageRo, nil
	case "ru":
		return TextContentLanguageRu, nil
	case "rw":
		return TextContentLanguageRw, nil
	case "sa":
		return TextContentLanguageSa, nil
	case "sc":
		return TextContentLanguageSc, nil
	case "sd":
		return TextContentLanguageSd, nil
	case "se":
		return TextContentLanguageSe, nil
	case "sg":
		return TextContentLanguageSg, nil
	case "si":
		return TextContentLanguageSi, nil
	case "sk":
		return TextContentLanguageSk, nil
	case "sl":
		return TextContentLanguageSl, nil
	case "sm":
		return TextContentLanguageSm, nil
	case "sn":
		return TextContentLanguageSn, nil
	case "so":
		return TextContentLanguageSo, nil
	case "sq":
		return TextContentLanguageSq, nil
	case "sr":
		return TextContentLanguageSr, nil
	case "ss":
		return TextContentLanguageSs, nil
	case "st":
		return TextContentLanguageSt, nil
	case "su":
		return TextContentLanguageSu, nil
	case "sv":
		return TextContentLanguageSv, nil
	case "sw":
		return TextContentLanguageSw, nil
	case "ta":
		return TextContentLanguageTa, nil
	case "te":
		return TextContentLanguageTe, nil
	case "tg":
		return TextContentLanguageTg, nil
	case "th":
		return TextContentLanguageTh, nil
	case "ti":
		return TextContentLanguageTi, nil
	case "tk":
		return TextContentLanguageTk, nil
	case "tl":
		return TextContentLanguageTl, nil
	case "tn":
		return TextContentLanguageTn, nil
	case "to":
		return TextContentLanguageTo, nil
	case "tr":
		return TextContentLanguageTr, nil
	case "ts":
		return TextContentLanguageTs, nil
	case "tt":
		return TextContentLanguageTt, nil
	case "tw":
		return TextContentLanguageTw, nil
	case "ty":
		return TextContentLanguageTy, nil
	case "ug":
		return TextContentLanguageUg, nil
	case "uk":
		return TextContentLanguageUk, nil
	case "ur":
		return TextContentLanguageUr, nil
	case "uz":
		return TextContentLanguageUz, nil
	case "ve":
		return TextContentLanguageVe, nil
	case "vi":
		return TextContentLanguageVi, nil
	case "vo":
		return TextContentLanguageVo, nil
	case "wa":
		return TextContentLanguageWa, nil
	case "wo":
		return TextContentLanguageWo, nil
	case "xh":
		return TextContentLanguageXh, nil
	case "yi":
		return TextContentLanguageYi, nil
	case "yue":
		return TextContentLanguageYue, nil
	case "yo":
		return TextContentLanguageYo, nil
	case "za":
		return TextContentLanguageZa, nil
	case "zh":
		return TextContentLanguageZh, nil
	case "zu":
		return TextContentLanguageZu, nil
	}
	var t TextContentLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TextContentLanguage) Ptr() *TextContentLanguage {
	return &t
}

type TimeRange struct {
	// This is the time step for aggregations.
	//
	// If not provided, defaults to returning for the entire time range.
	Step *TimeRangeStep `json:"step,omitempty" url:"step,omitempty"`
	// This is the start date for the time range.
	//
	// If not provided, defaults to the 7 days ago.
	Start *time.Time `json:"start,omitempty" url:"start,omitempty"`
	// This is the end date for the time range.
	//
	// If not provided, defaults to now.
	End *time.Time `json:"end,omitempty" url:"end,omitempty"`
	// This is the timezone you want to set for the query.
	//
	// If not provided, defaults to UTC.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimeRange) GetStep() *TimeRangeStep {
	if t == nil {
		return nil
	}
	return t.Step
}

func (t *TimeRange) GetStart() *time.Time {
	if t == nil {
		return nil
	}
	return t.Start
}

func (t *TimeRange) GetEnd() *time.Time {
	if t == nil {
		return nil
	}
	return t.End
}

func (t *TimeRange) GetTimezone() *string {
	if t == nil {
		return nil
	}
	return t.Timezone
}

func (t *TimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	type embed TimeRange
	var unmarshaler = struct {
		embed
		Start *internal.DateTime `json:"start,omitempty"`
		End   *internal.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeRange(unmarshaler.embed)
	t.Start = unmarshaler.Start.TimePtr()
	t.End = unmarshaler.End.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeRange) MarshalJSON() ([]byte, error) {
	type embed TimeRange
	var marshaler = struct {
		embed
		Start *internal.DateTime `json:"start,omitempty"`
		End   *internal.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*t),
		Start: internal.NewOptionalDateTime(t.Start),
		End:   internal.NewOptionalDateTime(t.End),
	}
	return json.Marshal(marshaler)
}

func (t *TimeRange) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the time step for aggregations.
//
// If not provided, defaults to returning for the entire time range.
type TimeRangeStep string

const (
	TimeRangeStepMinute     TimeRangeStep = "minute"
	TimeRangeStepHour       TimeRangeStep = "hour"
	TimeRangeStepDay        TimeRangeStep = "day"
	TimeRangeStepWeek       TimeRangeStep = "week"
	TimeRangeStepMonth      TimeRangeStep = "month"
	TimeRangeStepQuarter    TimeRangeStep = "quarter"
	TimeRangeStepYear       TimeRangeStep = "year"
	TimeRangeStepDecade     TimeRangeStep = "decade"
	TimeRangeStepCentury    TimeRangeStep = "century"
	TimeRangeStepMillennium TimeRangeStep = "millennium"
)

func NewTimeRangeStepFromString(s string) (TimeRangeStep, error) {
	switch s {
	case "minute":
		return TimeRangeStepMinute, nil
	case "hour":
		return TimeRangeStepHour, nil
	case "day":
		return TimeRangeStepDay, nil
	case "week":
		return TimeRangeStepWeek, nil
	case "month":
		return TimeRangeStepMonth, nil
	case "quarter":
		return TimeRangeStepQuarter, nil
	case "year":
		return TimeRangeStepYear, nil
	case "decade":
		return TimeRangeStepDecade, nil
	case "century":
		return TimeRangeStepCentury, nil
	case "millennium":
		return TimeRangeStepMillennium, nil
	}
	var t TimeRangeStep
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeRangeStep) Ptr() *TimeRangeStep {
	return &t
}

type TogetherAiCredential struct {
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TogetherAiCredential) GetApiKey() string {
	if t == nil {
		return ""
	}
	return t.ApiKey
}

func (t *TogetherAiCredential) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TogetherAiCredential) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TogetherAiCredential) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TogetherAiCredential) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TogetherAiCredential) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TogetherAiCredential) Provider() string {
	return t.provider
}

func (t *TogetherAiCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TogetherAiCredential) UnmarshalJSON(data []byte) error {
	type embed TogetherAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TogetherAiCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "together-ai", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TogetherAiCredential) MarshalJSON() ([]byte, error) {
	type embed TogetherAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Provider:  "together-ai",
	}
	return json.Marshal(marshaler)
}

func (t *TogetherAiCredential) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TogetherAiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*TogetherAiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TogetherAiModel) GetMessages() []*OpenAiMessage {
	if t == nil {
		return nil
	}
	return t.Messages
}

func (t *TogetherAiModel) GetTools() []*TogetherAiModelToolsItem {
	if t == nil {
		return nil
	}
	return t.Tools
}

func (t *TogetherAiModel) GetToolIds() []string {
	if t == nil {
		return nil
	}
	return t.ToolIds
}

func (t *TogetherAiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if t == nil {
		return nil
	}
	return t.KnowledgeBase
}

func (t *TogetherAiModel) GetKnowledgeBaseId() *string {
	if t == nil {
		return nil
	}
	return t.KnowledgeBaseId
}

func (t *TogetherAiModel) GetModel() string {
	if t == nil {
		return ""
	}
	return t.Model
}

func (t *TogetherAiModel) GetTemperature() *float64 {
	if t == nil {
		return nil
	}
	return t.Temperature
}

func (t *TogetherAiModel) GetMaxTokens() *float64 {
	if t == nil {
		return nil
	}
	return t.MaxTokens
}

func (t *TogetherAiModel) GetEmotionRecognitionEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.EmotionRecognitionEnabled
}

func (t *TogetherAiModel) GetNumFastTurns() *float64 {
	if t == nil {
		return nil
	}
	return t.NumFastTurns
}

func (t *TogetherAiModel) Provider() string {
	return t.provider
}

func (t *TogetherAiModel) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TogetherAiModel) UnmarshalJSON(data []byte) error {
	type embed TogetherAiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TogetherAiModel(unmarshaler.embed)
	if unmarshaler.Provider != "together-ai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "together-ai", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TogetherAiModel) MarshalJSON() ([]byte, error) {
	type embed TogetherAiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "together-ai",
	}
	return json.Marshal(marshaler)
}

func (t *TogetherAiModel) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TogetherAiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (t *TogetherAiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if t == nil {
		return nil
	}
	return t.CreateDtmfToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateEndCallToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if t == nil {
		return nil
	}
	return t.CreateVoicemailToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if t == nil {
		return nil
	}
	return t.CreateFunctionToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if t == nil {
		return nil
	}
	return t.CreateGhlToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if t == nil {
		return nil
	}
	return t.CreateMakeToolDto
}

func (t *TogetherAiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if t == nil {
		return nil
	}
	return t.CreateTransferCallToolDto
}

func (t *TogetherAiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		t.typ = "CreateDtmfToolDto"
		t.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		t.typ = "CreateEndCallToolDto"
		t.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		t.typ = "CreateVoicemailToolDto"
		t.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		t.typ = "CreateFunctionToolDto"
		t.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		t.typ = "CreateGhlToolDto"
		t.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		t.typ = "CreateMakeToolDto"
		t.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		t.typ = "CreateTransferCallToolDto"
		t.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TogetherAiModelToolsItem) MarshalJSON() ([]byte, error) {
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return json.Marshal(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return json.Marshal(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateVoicemailToolDto" || t.CreateVoicemailToolDto != nil {
		return json.Marshal(t.CreateVoicemailToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return json.Marshal(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGhlToolDto" || t.CreateGhlToolDto != nil {
		return json.Marshal(t.CreateGhlToolDto)
	}
	if t.typ == "CreateMakeToolDto" || t.CreateMakeToolDto != nil {
		return json.Marshal(t.CreateMakeToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return json.Marshal(t.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TogetherAiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (t *TogetherAiModelToolsItem) Accept(visitor TogetherAiModelToolsItemVisitor) error {
	if t.typ == "CreateDtmfToolDto" || t.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(t.CreateDtmfToolDto)
	}
	if t.typ == "CreateEndCallToolDto" || t.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(t.CreateEndCallToolDto)
	}
	if t.typ == "CreateVoicemailToolDto" || t.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(t.CreateVoicemailToolDto)
	}
	if t.typ == "CreateFunctionToolDto" || t.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(t.CreateFunctionToolDto)
	}
	if t.typ == "CreateGhlToolDto" || t.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(t.CreateGhlToolDto)
	}
	if t.typ == "CreateMakeToolDto" || t.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(t.CreateMakeToolDto)
	}
	if t.typ == "CreateTransferCallToolDto" || t.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(t.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type Token struct {
	// This is the tag for the token. It represents its scope.
	Tag *TokenTag `json:"tag,omitempty" url:"tag,omitempty"`
	// This is the unique identifier for the token.
	Id string `json:"id" url:"id"`
	// This is unique identifier for the org that this token belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the token was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the token was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the token key.
	Value string `json:"value" url:"value"`
	// This is the name of the token. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This are the restrictions for the token.
	Restrictions *TokenRestrictions `json:"restrictions,omitempty" url:"restrictions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Token) GetTag() *TokenTag {
	if t == nil {
		return nil
	}
	return t.Tag
}

func (t *Token) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *Token) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *Token) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *Token) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *Token) GetValue() string {
	if t == nil {
		return ""
	}
	return t.Value
}

func (t *Token) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *Token) GetRestrictions() *TokenRestrictions {
	if t == nil {
		return nil
	}
	return t.Restrictions
}

func (t *Token) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Token) UnmarshalJSON(data []byte) error {
	type embed Token
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Token(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Token) MarshalJSON() ([]byte, error) {
	type embed Token
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *Token) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenRestrictions struct {
	// This determines whether the token is enabled or disabled. Default is true, it's enabled.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This determines the allowed origins for this token. Validates the `Origin` header. Default is any origin.
	//
	// Only relevant for `public` tokens.
	AllowedOrigins []string `json:"allowedOrigins,omitempty" url:"allowedOrigins,omitempty"`
	// This determines which assistantIds can be used when creating a call. Default is any assistantId.
	//
	// Only relevant for `public` tokens.
	AllowedAssistantIds []string `json:"allowedAssistantIds,omitempty" url:"allowedAssistantIds,omitempty"`
	// This determines whether transient assistants can be used when creating a call. Default is true.
	//
	// If `allowedAssistantIds` is provided, this is automatically false.
	//
	// Only relevant for `public` tokens.
	AllowTransientAssistant *bool `json:"allowTransientAssistant,omitempty" url:"allowTransientAssistant,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenRestrictions) GetEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.Enabled
}

func (t *TokenRestrictions) GetAllowedOrigins() []string {
	if t == nil {
		return nil
	}
	return t.AllowedOrigins
}

func (t *TokenRestrictions) GetAllowedAssistantIds() []string {
	if t == nil {
		return nil
	}
	return t.AllowedAssistantIds
}

func (t *TokenRestrictions) GetAllowTransientAssistant() *bool {
	if t == nil {
		return nil
	}
	return t.AllowTransientAssistant
}

func (t *TokenRestrictions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenRestrictions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenRestrictions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenRestrictions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenRestrictions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the tag for the token. It represents its scope.
type TokenTag string

const (
	TokenTagPrivate TokenTag = "private"
	TokenTagPublic  TokenTag = "public"
)

func NewTokenTagFromString(s string) (TokenTag, error) {
	switch s {
	case "private":
		return TokenTagPrivate, nil
	case "public":
		return TokenTagPublic, nil
	}
	var t TokenTag
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenTag) Ptr() *TokenTag {
	return &t
}

type ToolCall struct {
	// This is the type of tool the model called.
	// This is the function the model called.
	Function *ToolCallFunction `json:"function,omitempty" url:"function,omitempty"`
	// This is the unique identifier for the tool call.
	Id    string `json:"id" url:"id"`
	type_ string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCall) GetFunction() *ToolCallFunction {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *ToolCall) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *ToolCall) Type() string {
	return t.type_
}

func (t *ToolCall) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCall) UnmarshalJSON(data []byte) error {
	type embed ToolCall
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolCall(unmarshaler.embed)
	if unmarshaler.Type != "function" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "function", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCall) MarshalJSON() ([]byte, error) {
	type embed ToolCall
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "function",
	}
	return json.Marshal(marshaler)
}

func (t *ToolCall) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallFunction struct {
	// This is the name of the function the model called.
	Name string `json:"name" url:"name"`
	// These are the arguments that the function was called with.
	Arguments map[string]interface{} `json:"arguments,omitempty" url:"arguments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallFunction) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *ToolCallFunction) GetArguments() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Arguments
}

func (t *ToolCallFunction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallFunction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallFunction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallResult struct {
	// This is the message that will be spoken to the user.
	//
	// If this is not returned, assistant will speak:
	// 1. a `request-complete` or `request-failed` message from `tool.messages`, if it exists
	// 2. a response generated by the model, if not
	Message []*ToolCallResultMessageItem `json:"message,omitempty" url:"message,omitempty"`
	// This is the name of the function the model called.
	Name string `json:"name" url:"name"`
	// This is the unique identifier for the tool call.
	ToolCallId string `json:"toolCallId" url:"toolCallId"`
	// This is the result if the tool call was successful. This is added to the conversation history.
	//
	// Further, if this is returned, assistant will speak:
	// 1. the `message`, if it exists and is of type `request-complete`
	// 2. a `request-complete` message from `tool.messages`, if it exists
	// 3. a response generated by the model, if neither exist
	Result *string `json:"result,omitempty" url:"result,omitempty"`
	// This is the error if the tool call was not successful. This is added to the conversation history.
	//
	// Further, if this is returned, assistant will speak:
	// 1. the `message`, if it exists and is of type `request-failed`
	// 2. a `request-failed` message from `tool.messages`, if it exists
	// 3. a response generated by the model, if neither exist
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallResult) GetMessage() []*ToolCallResultMessageItem {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *ToolCallResult) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *ToolCallResult) GetToolCallId() string {
	if t == nil {
		return ""
	}
	return t.ToolCallId
}

func (t *ToolCallResult) GetResult() *string {
	if t == nil {
		return nil
	}
	return t.Result
}

func (t *ToolCallResult) GetError() *string {
	if t == nil {
		return nil
	}
	return t.Error
}

func (t *ToolCallResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallResult) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallResultMessageItem struct {
	ToolMessageComplete *ToolMessageComplete
	ToolMessageFailed   *ToolMessageFailed

	typ string
}

func (t *ToolCallResultMessageItem) GetToolMessageComplete() *ToolMessageComplete {
	if t == nil {
		return nil
	}
	return t.ToolMessageComplete
}

func (t *ToolCallResultMessageItem) GetToolMessageFailed() *ToolMessageFailed {
	if t == nil {
		return nil
	}
	return t.ToolMessageFailed
}

func (t *ToolCallResultMessageItem) UnmarshalJSON(data []byte) error {
	valueToolMessageComplete := new(ToolMessageComplete)
	if err := json.Unmarshal(data, &valueToolMessageComplete); err == nil {
		t.typ = "ToolMessageComplete"
		t.ToolMessageComplete = valueToolMessageComplete
		return nil
	}
	valueToolMessageFailed := new(ToolMessageFailed)
	if err := json.Unmarshal(data, &valueToolMessageFailed); err == nil {
		t.typ = "ToolMessageFailed"
		t.ToolMessageFailed = valueToolMessageFailed
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolCallResultMessageItem) MarshalJSON() ([]byte, error) {
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return json.Marshal(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return json.Marshal(t.ToolMessageFailed)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolCallResultMessageItemVisitor interface {
	VisitToolMessageComplete(*ToolMessageComplete) error
	VisitToolMessageFailed(*ToolMessageFailed) error
}

func (t *ToolCallResultMessageItem) Accept(visitor ToolCallResultMessageItemVisitor) error {
	if t.typ == "ToolMessageComplete" || t.ToolMessageComplete != nil {
		return visitor.VisitToolMessageComplete(t.ToolMessageComplete)
	}
	if t.typ == "ToolMessageFailed" || t.ToolMessageFailed != nil {
		return visitor.VisitToolMessageFailed(t.ToolMessageFailed)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolMessageComplete struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This message is triggered when the tool call is complete.
	//
	// This message is triggered immediately without waiting for your server to respond for async tool calls.
	//
	// If this message is not provided, the model will be requested to respond.
	//
	// If this message is provided, only this message will be spoken and the model will not be requested to come up with a response. It's an exclusive OR.
	// This is optional and defaults to "assistant".
	//
	// When role=assistant, `content` is said out loud.
	//
	// When role=system, `content` is passed to the model in a system message. Example:
	//
	//	system: default one
	//	assistant:
	//	user:
	//	assistant:
	//	user:
	//	assistant:
	//	user:
	//	assistant: tool called
	//	tool: your server response
	//	<--- system prompt as hint
	//	---> model generates response which is spoken
	//
	// This is useful when you want to provide a hint to the model about what to say next.
	Role *ToolMessageCompleteRole `json:"role,omitempty" url:"role,omitempty"`
	// This is an optional boolean that if true, the call will end after the message is spoken. Default is false.
	//
	// This is ignored if `role` is set to `system`.
	//
	// @default false
	EndCallAfterSpokenEnabled *bool `json:"endCallAfterSpokenEnabled,omitempty" url:"endCallAfterSpokenEnabled,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageComplete) GetContents() []*TextContent {
	if t == nil {
		return nil
	}
	return t.Contents
}

func (t *ToolMessageComplete) GetRole() *ToolMessageCompleteRole {
	if t == nil {
		return nil
	}
	return t.Role
}

func (t *ToolMessageComplete) GetEndCallAfterSpokenEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.EndCallAfterSpokenEnabled
}

func (t *ToolMessageComplete) GetContent() *string {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageComplete) GetConditions() []*Condition {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *ToolMessageComplete) Type() string {
	return t.type_
}

func (t *ToolMessageComplete) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageComplete) UnmarshalJSON(data []byte) error {
	type embed ToolMessageComplete
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageComplete(unmarshaler.embed)
	if unmarshaler.Type != "request-complete" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-complete", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageComplete) MarshalJSON() ([]byte, error) {
	type embed ToolMessageComplete
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-complete",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageComplete) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is optional and defaults to "assistant".
//
// When role=assistant, `content` is said out loud.
//
// When role=system, `content` is passed to the model in a system message. Example:
//
//	system: default one
//	assistant:
//	user:
//	assistant:
//	user:
//	assistant:
//	user:
//	assistant: tool called
//	tool: your server response
//	<--- system prompt as hint
//	---> model generates response which is spoken
//
// This is useful when you want to provide a hint to the model about what to say next.
type ToolMessageCompleteRole string

const (
	ToolMessageCompleteRoleAssistant ToolMessageCompleteRole = "assistant"
	ToolMessageCompleteRoleSystem    ToolMessageCompleteRole = "system"
)

func NewToolMessageCompleteRoleFromString(s string) (ToolMessageCompleteRole, error) {
	switch s {
	case "assistant":
		return ToolMessageCompleteRoleAssistant, nil
	case "system":
		return ToolMessageCompleteRoleSystem, nil
	}
	var t ToolMessageCompleteRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t ToolMessageCompleteRole) Ptr() *ToolMessageCompleteRole {
	return &t
}

type ToolMessageDelayed struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This message is triggered when the tool call is delayed.
	//
	// There are the two things that can trigger this message:
	// 1. The user talks with the assistant while your server is processing the request. Default is "Sorry, a few more seconds."
	// 2. The server doesn't respond within `timingMilliseconds`.
	//
	// This message is never triggered for async tool calls.
	// The number of milliseconds to wait for the server response before saying this message.
	TimingMilliseconds *float64 `json:"timingMilliseconds,omitempty" url:"timingMilliseconds,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageDelayed) GetContents() []*TextContent {
	if t == nil {
		return nil
	}
	return t.Contents
}

func (t *ToolMessageDelayed) GetTimingMilliseconds() *float64 {
	if t == nil {
		return nil
	}
	return t.TimingMilliseconds
}

func (t *ToolMessageDelayed) GetContent() *string {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageDelayed) GetConditions() []*Condition {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *ToolMessageDelayed) Type() string {
	return t.type_
}

func (t *ToolMessageDelayed) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageDelayed) UnmarshalJSON(data []byte) error {
	type embed ToolMessageDelayed
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageDelayed(unmarshaler.embed)
	if unmarshaler.Type != "request-response-delayed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-response-delayed", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageDelayed) MarshalJSON() ([]byte, error) {
	type embed ToolMessageDelayed
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-response-delayed",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageDelayed) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolMessageFailed struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This message is triggered when the tool call fails.
	//
	// This message is never triggered for async tool calls.
	//
	// If this message is not provided, the model will be requested to respond.
	//
	// If this message is provided, only this message will be spoken and the model will not be requested to come up with a response. It's an exclusive OR.
	// This is an optional boolean that if true, the call will end after the message is spoken. Default is false.
	//
	// @default false
	EndCallAfterSpokenEnabled *bool `json:"endCallAfterSpokenEnabled,omitempty" url:"endCallAfterSpokenEnabled,omitempty"`
	// This is the content that the assistant says when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageFailed) GetContents() []*TextContent {
	if t == nil {
		return nil
	}
	return t.Contents
}

func (t *ToolMessageFailed) GetEndCallAfterSpokenEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.EndCallAfterSpokenEnabled
}

func (t *ToolMessageFailed) GetContent() *string {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageFailed) GetConditions() []*Condition {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *ToolMessageFailed) Type() string {
	return t.type_
}

func (t *ToolMessageFailed) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageFailed) UnmarshalJSON(data []byte) error {
	type embed ToolMessageFailed
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageFailed(unmarshaler.embed)
	if unmarshaler.Type != "request-failed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-failed", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageFailed) MarshalJSON() ([]byte, error) {
	type embed ToolMessageFailed
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-failed",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageFailed) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolMessageStart struct {
	// This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.
	//
	// Usage:
	// - If your assistants are multilingual, you can provide content for each language.
	// - If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.
	//
	// This will override the `content` property.
	Contents []*TextContent `json:"contents,omitempty" url:"contents,omitempty"`
	// This message is triggered when the tool call starts.
	//
	// This message is never triggered for async tools.
	//
	// If this message is not provided, one of the default filler messages "Hold on a sec", "One moment", "Just a sec", "Give me a moment" or "This'll just take a sec" will be used.
	// This is the content that the assistant says when this message is triggered.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.
	Conditions []*Condition `json:"conditions,omitempty" url:"conditions,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageStart) GetContents() []*TextContent {
	if t == nil {
		return nil
	}
	return t.Contents
}

func (t *ToolMessageStart) GetContent() *string {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageStart) GetConditions() []*Condition {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *ToolMessageStart) Type() string {
	return t.type_
}

func (t *ToolMessageStart) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageStart) UnmarshalJSON(data []byte) error {
	type embed ToolMessageStart
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolMessageStart(unmarshaler.embed)
	if unmarshaler.Type != "request-start" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "request-start", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageStart) MarshalJSON() ([]byte, error) {
	type embed ToolMessageStart
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "request-start",
	}
	return json.Marshal(marshaler)
}

func (t *ToolMessageStart) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolTemplateMetadata struct {
	CollectionType *string `json:"collectionType,omitempty" url:"collectionType,omitempty"`
	CollectionId   *string `json:"collectionId,omitempty" url:"collectionId,omitempty"`
	CollectionName *string `json:"collectionName,omitempty" url:"collectionName,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolTemplateMetadata) GetCollectionType() *string {
	if t == nil {
		return nil
	}
	return t.CollectionType
}

func (t *ToolTemplateMetadata) GetCollectionId() *string {
	if t == nil {
		return nil
	}
	return t.CollectionId
}

func (t *ToolTemplateMetadata) GetCollectionName() *string {
	if t == nil {
		return nil
	}
	return t.CollectionName
}

func (t *ToolTemplateMetadata) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolTemplateMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolTemplateMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolTemplateMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolTemplateMetadata) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolTemplateSetup struct {
	Title       string  `json:"title" url:"title"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	VideoUrl    *string `json:"videoUrl,omitempty" url:"videoUrl,omitempty"`
	DocsUrl     *string `json:"docsUrl,omitempty" url:"docsUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolTemplateSetup) GetTitle() string {
	if t == nil {
		return ""
	}
	return t.Title
}

func (t *ToolTemplateSetup) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *ToolTemplateSetup) GetVideoUrl() *string {
	if t == nil {
		return nil
	}
	return t.VideoUrl
}

func (t *ToolTemplateSetup) GetDocsUrl() *string {
	if t == nil {
		return nil
	}
	return t.DocsUrl
}

func (t *ToolTemplateSetup) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolTemplateSetup) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolTemplateSetup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolTemplateSetup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolTemplateSetup) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TranscriptPlan struct {
	// This determines whether the transcript is stored in `call.artifact.transcript`. Defaults to true.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// This is the name of the assistant in the transcript. Defaults to 'AI'.
	//
	// Usage:
	// - If you want to change the name of the assistant in the transcript, set this. Example, here is what the transcript would look like with `assistantName` set to 'Buyer':
	// ```
	// User: Hello, how are you?
	// Buyer: I'm fine.
	// User: Do you want to buy a car?
	// Buyer: No.
	// ```
	//
	// @default 'AI'
	AssistantName *string `json:"assistantName,omitempty" url:"assistantName,omitempty"`
	// This is the name of the user in the transcript. Defaults to 'User'.
	//
	// Usage:
	// - If you want to change the name of the user in the transcript, set this. Example, here is what the transcript would look like with `userName` set to 'Seller':
	// ```
	// Seller: Hello, how are you?
	// AI: I'm fine.
	// Seller: Do you want to buy a car?
	// AI: No.
	// ```
	//
	// @default 'User'
	UserName *string `json:"userName,omitempty" url:"userName,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TranscriptPlan) GetEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.Enabled
}

func (t *TranscriptPlan) GetAssistantName() *string {
	if t == nil {
		return nil
	}
	return t.AssistantName
}

func (t *TranscriptPlan) GetUserName() *string {
	if t == nil {
		return nil
	}
	return t.UserName
}

func (t *TranscriptPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TranscriptPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TranscriptPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TranscriptPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TranscriptPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TranscriptionEndpointingPlan struct {
	// The minimum number of seconds to wait after transcription ending with punctuation before sending a request to the model. Defaults to 0.1.
	//
	// This setting exists because the transcriber punctuates the transcription when it's more confident that customer has completed a thought.
	//
	// @default 0.1
	OnPunctuationSeconds *float64 `json:"onPunctuationSeconds,omitempty" url:"onPunctuationSeconds,omitempty"`
	// The minimum number of seconds to wait after transcription ending without punctuation before sending a request to the model. Defaults to 1.5.
	//
	// This setting exists to catch the cases where the transcriber was not confident enough to punctuate the transcription, but the customer is done and has been silent for a long time.
	//
	// @default 1.5
	OnNoPunctuationSeconds *float64 `json:"onNoPunctuationSeconds,omitempty" url:"onNoPunctuationSeconds,omitempty"`
	// The minimum number of seconds to wait after transcription ending with a number before sending a request to the model. Defaults to 0.4.
	//
	// This setting exists because the transcriber will sometimes punctuate the transcription ending with a number, even though the customer hasn't uttered the full number. This happens commonly for long numbers when the customer reads the number in chunks.
	//
	// @default 0.5
	OnNumberSeconds *float64 `json:"onNumberSeconds,omitempty" url:"onNumberSeconds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TranscriptionEndpointingPlan) GetOnPunctuationSeconds() *float64 {
	if t == nil {
		return nil
	}
	return t.OnPunctuationSeconds
}

func (t *TranscriptionEndpointingPlan) GetOnNoPunctuationSeconds() *float64 {
	if t == nil {
		return nil
	}
	return t.OnNoPunctuationSeconds
}

func (t *TranscriptionEndpointingPlan) GetOnNumberSeconds() *float64 {
	if t == nil {
		return nil
	}
	return t.OnNumberSeconds
}

func (t *TranscriptionEndpointingPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TranscriptionEndpointingPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TranscriptionEndpointingPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TranscriptionEndpointingPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TranscriptionEndpointingPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransferDestinationAssistant struct {
	// This is spoken to the customer before connecting them to the destination.
	//
	// Usage:
	// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	//
	// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
	Message *TransferDestinationAssistantMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the mode to use for the transfer. Defaults to `rolling-history`.
	//
	// - `rolling-history`: This is the default mode. It keeps the entire conversation history and appends the new assistant's system message on transfer.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//
	//	Post-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//	  system: assistant2 system message
	//	  assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)
	//
	// - `swap-system-message-in-history`: This replaces the original system message with the new assistant's system message on transfer.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//
	//	Post-transfer:
	//	  system: assistant2 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//	  assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)
	//
	// - `delete-history`: This deletes the entire conversation history on transfer.
	//
	//	Example:
	//
	//	Pre-transfer:
	//	  system: assistant1 system message
	//	  assistant: assistant1 first message
	//	  user: hey, good morning
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//	  assistant: (destination.message)
	//
	//	Post-transfer:
	//	  system: assistant2 system message
	//	  assistant: assistant2 first message
	//	  user: Yes, please
	//	  assistant: how can i help?
	//	  user: i need help with my account
	//
	// @default 'rolling-history'
	TransferMode *TransferMode `json:"transferMode,omitempty" url:"transferMode,omitempty"`
	// This is the assistant to transfer the call to.
	AssistantName string `json:"assistantName" url:"assistantName"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferDestinationAssistant) GetMessage() *TransferDestinationAssistantMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferDestinationAssistant) GetTransferMode() *TransferMode {
	if t == nil {
		return nil
	}
	return t.TransferMode
}

func (t *TransferDestinationAssistant) GetAssistantName() string {
	if t == nil {
		return ""
	}
	return t.AssistantName
}

func (t *TransferDestinationAssistant) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TransferDestinationAssistant) Type() string {
	return t.type_
}

func (t *TransferDestinationAssistant) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationAssistant) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationAssistant
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationAssistant(unmarshaler.embed)
	if unmarshaler.Type != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "assistant", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationAssistant) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationAssistant
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "assistant",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationAssistant) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is spoken to the customer before connecting them to the destination.
//
// Usage:
// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
//
// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
type TransferDestinationAssistantMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferDestinationAssistantMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferDestinationAssistantMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferDestinationAssistantMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferDestinationAssistantMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationAssistantMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferDestinationAssistantMessage) Accept(visitor TransferDestinationAssistantMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationNumber struct {
	// This is spoken to the customer before connecting them to the destination.
	//
	// Usage:
	// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	//
	// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
	Message *TransferDestinationNumberMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.
	//
	// Use cases:
	// - `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.
	// - `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.
	//
	// If `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\+?[a-zA-Z0-9]+$/`).
	//
	// @default true (E164 check is enabled)
	NumberE164CheckEnabled *bool `json:"numberE164CheckEnabled,omitempty" url:"numberE164CheckEnabled,omitempty"`
	// This is the phone number to transfer the call to.
	Number string `json:"number" url:"number"`
	// This is the extension to dial after transferring the call to the `number`.
	Extension *string `json:"extension,omitempty" url:"extension,omitempty"`
	// This is the caller ID to use when transferring the call to the `number`.
	//
	// Usage:
	// - If not provided, the caller ID will be the number the call is coming from. Example, +14151111111 calls in to and the assistant transfers out to +16470000000. +16470000000 will see +14151111111 as the caller.
	// - To change this behavior, provide a `callerId`.
	// - Set to '{{customer.number}}' to always use the customer's number as the caller ID.
	// - Set to '{{phoneNumber.number}}' to always use the phone number of the assistant as the caller ID.
	// - Set to any E164 number to always use that number as the caller ID. This needs to be a number that is owned or verified by your Transport provider like Twilio.
	//
	// For Twilio, you can read up more here: https://www.twilio.com/docs/voice/twiml/dial#callerid
	CallerId *string `json:"callerId,omitempty" url:"callerId,omitempty"`
	// This configures how transfer is executed and the experience of the destination party receiving the call. Defaults to `blind-transfer`.
	//
	// @default `transferPlan.mode='blind-transfer'`
	TransferPlan *TransferPlan `json:"transferPlan,omitempty" url:"transferPlan,omitempty"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferDestinationNumber) GetMessage() *TransferDestinationNumberMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferDestinationNumber) GetNumberE164CheckEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.NumberE164CheckEnabled
}

func (t *TransferDestinationNumber) GetNumber() string {
	if t == nil {
		return ""
	}
	return t.Number
}

func (t *TransferDestinationNumber) GetExtension() *string {
	if t == nil {
		return nil
	}
	return t.Extension
}

func (t *TransferDestinationNumber) GetCallerId() *string {
	if t == nil {
		return nil
	}
	return t.CallerId
}

func (t *TransferDestinationNumber) GetTransferPlan() *TransferPlan {
	if t == nil {
		return nil
	}
	return t.TransferPlan
}

func (t *TransferDestinationNumber) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TransferDestinationNumber) Type() string {
	return t.type_
}

func (t *TransferDestinationNumber) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationNumber) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationNumber
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationNumber(unmarshaler.embed)
	if unmarshaler.Type != "number" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "number", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationNumber) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationNumber
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "number",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationNumber) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is spoken to the customer before connecting them to the destination.
//
// Usage:
// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
//
// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
type TransferDestinationNumberMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferDestinationNumberMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferDestinationNumberMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferDestinationNumberMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferDestinationNumberMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationNumberMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferDestinationNumberMessage) Accept(visitor TransferDestinationNumberMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationSip struct {
	// This is spoken to the customer before connecting them to the destination.
	//
	// Usage:
	// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	//
	// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
	Message *TransferDestinationSipMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the SIP URI to transfer the call to.
	SipUri string `json:"sipUri" url:"sipUri"`
	// This configures how transfer is executed and the experience of the destination party receiving the call. Defaults to `blind-transfer`.
	//
	// @default `transferPlan.mode='blind-transfer'`
	TransferPlan *TransferPlan `json:"transferPlan,omitempty" url:"transferPlan,omitempty"`
	// These are custom headers to be added to SIP refer during transfer call.
	SipHeaders map[string]interface{} `json:"sipHeaders,omitempty" url:"sipHeaders,omitempty"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferDestinationSip) GetMessage() *TransferDestinationSipMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferDestinationSip) GetSipUri() string {
	if t == nil {
		return ""
	}
	return t.SipUri
}

func (t *TransferDestinationSip) GetTransferPlan() *TransferPlan {
	if t == nil {
		return nil
	}
	return t.TransferPlan
}

func (t *TransferDestinationSip) GetSipHeaders() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.SipHeaders
}

func (t *TransferDestinationSip) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TransferDestinationSip) Type() string {
	return t.type_
}

func (t *TransferDestinationSip) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationSip) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationSip
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationSip(unmarshaler.embed)
	if unmarshaler.Type != "sip" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "sip", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationSip) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationSip
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "sip",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationSip) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is spoken to the customer before connecting them to the destination.
//
// Usage:
// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
//
// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
type TransferDestinationSipMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferDestinationSipMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferDestinationSipMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferDestinationSipMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferDestinationSipMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationSipMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferDestinationSipMessage) Accept(visitor TransferDestinationSipMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationStep struct {
	// This is spoken to the customer before connecting them to the destination.
	//
	// Usage:
	// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
	// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
	//
	// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
	Message *TransferDestinationStepMessage `json:"message,omitempty" url:"message,omitempty"`
	// This is the step to transfer to.
	StepName string `json:"stepName" url:"stepName"`
	// This is the description of the destination, used by the AI to choose when and how to transfer the call.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	type_       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferDestinationStep) GetMessage() *TransferDestinationStepMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferDestinationStep) GetStepName() string {
	if t == nil {
		return ""
	}
	return t.StepName
}

func (t *TransferDestinationStep) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TransferDestinationStep) Type() string {
	return t.type_
}

func (t *TransferDestinationStep) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferDestinationStep) UnmarshalJSON(data []byte) error {
	type embed TransferDestinationStep
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransferDestinationStep(unmarshaler.embed)
	if unmarshaler.Type != "step" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "step", unmarshaler.Type)
	}
	t.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "type")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferDestinationStep) MarshalJSON() ([]byte, error) {
	type embed TransferDestinationStep
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "step",
	}
	return json.Marshal(marshaler)
}

func (t *TransferDestinationStep) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is spoken to the customer before connecting them to the destination.
//
// Usage:
// - If this is not provided and transfer tool messages is not provided, default is "Transferring the call now".
// - If set to "", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.
//
// This accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.
type TransferDestinationStepMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferDestinationStepMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferDestinationStepMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferDestinationStepMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferDestinationStepMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferDestinationStepMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferDestinationStepMessage) Accept(visitor TransferDestinationStepMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferMode string

const (
	TransferModeRollingHistory             TransferMode = "rolling-history"
	TransferModeSwapSystemMessageInHistory TransferMode = "swap-system-message-in-history"
)

func NewTransferModeFromString(s string) (TransferMode, error) {
	switch s {
	case "rolling-history":
		return TransferModeRollingHistory, nil
	case "swap-system-message-in-history":
		return TransferModeSwapSystemMessageInHistory, nil
	}
	var t TransferMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransferMode) Ptr() *TransferMode {
	return &t
}

type TransferPlan struct {
	// This configures how transfer is executed and the experience of the destination party receiving the call.
	//
	// Usage:
	// - `blind-transfer`: The assistant forwards the call to the destination without any message or summary.
	// - `blind-transfer-add-summary-to-sip-header`: The assistant forwards the call to the destination and adds a SIP header X-Transfer-Summary to the call to include the summary.
	// - `warm-transfer-say-message`: The assistant dials the destination, delivers the `message` to the destination party, connects the customer, and leaves the call.
	// - `warm-transfer-say-summary`: The assistant dials the destination, provides a summary of the call to the destination party, connects the customer, and leaves the call.
	// - `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`: The assistant dials the destination, waits for the operator to speak, delivers the `message` to the destination party, and then connects the customer.
	// - `warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary`: The assistant dials the destination, waits for the operator to speak, provides a summary of the call to the destination party, and then connects the customer.
	//
	// @default 'blind-transfer'
	Mode TransferPlanMode `json:"mode" url:"mode"`
	// This is the message the assistant will deliver to the destination party before connecting the customer.
	//
	// Usage:
	// - Used only when `mode` is `blind-transfer-add-summary-to-sip-header`, `warm-transfer-say-message` or `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`.
	Message *TransferPlanMessage `json:"message,omitempty" url:"message,omitempty"`
	// This specifies the SIP verb to use while transferring the call.
	// - 'refer': Uses SIP REFER to transfer the call (default)
	// - 'bye': Ends current call with SIP BYE
	SipVerb map[string]interface{} `json:"sipVerb,omitempty" url:"sipVerb,omitempty"`
	// This is the plan for generating a summary of the call to present to the destination party.
	//
	// Usage:
	// - Used only when `mode` is `blind-transfer-add-summary-to-sip-header` or `warm-transfer-say-summary` or `warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary`.
	SummaryPlan *SummaryPlan `json:"summaryPlan,omitempty" url:"summaryPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransferPlan) GetMode() TransferPlanMode {
	if t == nil {
		return ""
	}
	return t.Mode
}

func (t *TransferPlan) GetMessage() *TransferPlanMessage {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TransferPlan) GetSipVerb() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.SipVerb
}

func (t *TransferPlan) GetSummaryPlan() *SummaryPlan {
	if t == nil {
		return nil
	}
	return t.SummaryPlan
}

func (t *TransferPlan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransferPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler TransferPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransferPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransferPlan) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// This is the message the assistant will deliver to the destination party before connecting the customer.
//
// Usage:
// - Used only when `mode` is `blind-transfer-add-summary-to-sip-header`, `warm-transfer-say-message` or `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`.
type TransferPlanMessage struct {
	String        string
	CustomMessage *CustomMessage

	typ string
}

func (t *TransferPlanMessage) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TransferPlanMessage) GetCustomMessage() *CustomMessage {
	if t == nil {
		return nil
	}
	return t.CustomMessage
}

func (t *TransferPlanMessage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	valueCustomMessage := new(CustomMessage)
	if err := json.Unmarshal(data, &valueCustomMessage); err == nil {
		t.typ = "CustomMessage"
		t.CustomMessage = valueCustomMessage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransferPlanMessage) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return json.Marshal(t.CustomMessage)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TransferPlanMessageVisitor interface {
	VisitString(string) error
	VisitCustomMessage(*CustomMessage) error
}

func (t *TransferPlanMessage) Accept(visitor TransferPlanMessageVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "CustomMessage" || t.CustomMessage != nil {
		return visitor.VisitCustomMessage(t.CustomMessage)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// This configures how transfer is executed and the experience of the destination party receiving the call.
//
// Usage:
// - `blind-transfer`: The assistant forwards the call to the destination without any message or summary.
// - `blind-transfer-add-summary-to-sip-header`: The assistant forwards the call to the destination and adds a SIP header X-Transfer-Summary to the call to include the summary.
// - `warm-transfer-say-message`: The assistant dials the destination, delivers the `message` to the destination party, connects the customer, and leaves the call.
// - `warm-transfer-say-summary`: The assistant dials the destination, provides a summary of the call to the destination party, connects the customer, and leaves the call.
// - `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`: The assistant dials the destination, waits for the operator to speak, delivers the `message` to the destination party, and then connects the customer.
// - `warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary`: The assistant dials the destination, waits for the operator to speak, provides a summary of the call to the destination party, and then connects the customer.
//
// @default 'blind-transfer'
type TransferPlanMode string

const (
	TransferPlanModeBlindTransfer                                            TransferPlanMode = "blind-transfer"
	TransferPlanModeBlindTransferAddSummaryToSipHeader                       TransferPlanMode = "blind-transfer-add-summary-to-sip-header"
	TransferPlanModeWarmTransferSayMessage                                   TransferPlanMode = "warm-transfer-say-message"
	TransferPlanModeWarmTransferSaySummary                                   TransferPlanMode = "warm-transfer-say-summary"
	TransferPlanModeWarmTransferWaitForOperatorToSpeakFirstAndThenSayMessage TransferPlanMode = "warm-transfer-wait-for-operator-to-speak-first-and-then-say-message"
	TransferPlanModeWarmTransferWaitForOperatorToSpeakFirstAndThenSaySummary TransferPlanMode = "warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary"
)

func NewTransferPlanModeFromString(s string) (TransferPlanMode, error) {
	switch s {
	case "blind-transfer":
		return TransferPlanModeBlindTransfer, nil
	case "blind-transfer-add-summary-to-sip-header":
		return TransferPlanModeBlindTransferAddSummaryToSipHeader, nil
	case "warm-transfer-say-message":
		return TransferPlanModeWarmTransferSayMessage, nil
	case "warm-transfer-say-summary":
		return TransferPlanModeWarmTransferSaySummary, nil
	case "warm-transfer-wait-for-operator-to-speak-first-and-then-say-message":
		return TransferPlanModeWarmTransferWaitForOperatorToSpeakFirstAndThenSayMessage, nil
	case "warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary":
		return TransferPlanModeWarmTransferWaitForOperatorToSpeakFirstAndThenSaySummary, nil
	}
	var t TransferPlanMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransferPlanMode) Ptr() *TransferPlanMode {
	return &t
}

type TransportConfigurationTwilio struct {
	// The integer number of seconds that we should allow the phone to ring before assuming there is no answer.
	// The default is `60` seconds and the maximum is `600` seconds.
	// For some call flows, we will add a 5-second buffer to the timeout value you provide.
	// For this reason, a timeout value of 10 seconds could result in an actual timeout closer to 15 seconds.
	// You can set this to a short time, such as `15` seconds, to hang up before reaching an answering machine or voicemail.
	//
	// @default 60
	Timeout *float64 `json:"timeout,omitempty" url:"timeout,omitempty"`
	// Whether to record the call.
	// Can be `true` to record the phone call, or `false` to not.
	// The default is `false`.
	//
	// @default false
	Record *bool `json:"record,omitempty" url:"record,omitempty"`
	// The number of channels in the final recording.
	// Can be: `mono` or `dual`.
	// The default is `mono`.
	// `mono` records both legs of the call in a single channel of the recording file.
	// `dual` records each leg to a separate channel of the recording file.
	// The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
	//
	// @default 'mono'
	RecordingChannels *TransportConfigurationTwilioRecordingChannels `json:"recordingChannels,omitempty" url:"recordingChannels,omitempty"`
	provider          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransportConfigurationTwilio) GetTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.Timeout
}

func (t *TransportConfigurationTwilio) GetRecord() *bool {
	if t == nil {
		return nil
	}
	return t.Record
}

func (t *TransportConfigurationTwilio) GetRecordingChannels() *TransportConfigurationTwilioRecordingChannels {
	if t == nil {
		return nil
	}
	return t.RecordingChannels
}

func (t *TransportConfigurationTwilio) Provider() string {
	return t.provider
}

func (t *TransportConfigurationTwilio) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransportConfigurationTwilio) UnmarshalJSON(data []byte) error {
	type embed TransportConfigurationTwilio
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransportConfigurationTwilio(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransportConfigurationTwilio) MarshalJSON() ([]byte, error) {
	type embed TransportConfigurationTwilio
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TransportConfigurationTwilio) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The number of channels in the final recording.
// Can be: `mono` or `dual`.
// The default is `mono`.
// `mono` records both legs of the call in a single channel of the recording file.
// `dual` records each leg to a separate channel of the recording file.
// The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
//
// @default 'mono'
type TransportConfigurationTwilioRecordingChannels string

const (
	TransportConfigurationTwilioRecordingChannelsMono TransportConfigurationTwilioRecordingChannels = "mono"
	TransportConfigurationTwilioRecordingChannelsDual TransportConfigurationTwilioRecordingChannels = "dual"
)

func NewTransportConfigurationTwilioRecordingChannelsFromString(s string) (TransportConfigurationTwilioRecordingChannels, error) {
	switch s {
	case "mono":
		return TransportConfigurationTwilioRecordingChannelsMono, nil
	case "dual":
		return TransportConfigurationTwilioRecordingChannelsDual, nil
	}
	var t TransportConfigurationTwilioRecordingChannels
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransportConfigurationTwilioRecordingChannels) Ptr() *TransportConfigurationTwilioRecordingChannels {
	return &t
}

type TwilioCredential struct {
	// This is not returned in the API.
	AuthToken string `json:"authToken" url:"authToken"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name       *string `json:"name,omitempty" url:"name,omitempty"`
	AccountSid string  `json:"accountSid" url:"accountSid"`
	provider   string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TwilioCredential) GetAuthToken() string {
	if t == nil {
		return ""
	}
	return t.AuthToken
}

func (t *TwilioCredential) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *TwilioCredential) GetOrgId() string {
	if t == nil {
		return ""
	}
	return t.OrgId
}

func (t *TwilioCredential) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TwilioCredential) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TwilioCredential) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TwilioCredential) GetAccountSid() string {
	if t == nil {
		return ""
	}
	return t.AccountSid
}

func (t *TwilioCredential) Provider() string {
	return t.provider
}

func (t *TwilioCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TwilioCredential) UnmarshalJSON(data []byte) error {
	type embed TwilioCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TwilioCredential(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TwilioCredential) MarshalJSON() ([]byte, error) {
	type embed TwilioCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
		Provider:  "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TwilioCredential) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TwilioVoicemailDetection struct {
	// This is the provider to use for voicemail detection.
	// These are the AMD messages from Twilio that are considered as voicemail. Default is ['machine_end_beep', 'machine_end_silence'].
	//
	// @default {Array} ['machine_end_beep', 'machine_end_silence']
	VoicemailDetectionTypes []TwilioVoicemailDetectionVoicemailDetectionTypesItem `json:"voicemailDetectionTypes,omitempty" url:"voicemailDetectionTypes,omitempty"`
	// This sets whether the assistant should detect voicemail. Defaults to true.
	//
	// @default true
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The number of seconds that Twilio should attempt to perform answering machine detection before timing out and returning AnsweredBy as unknown. Default is 30 seconds.
	//
	// Increasing this value will provide the engine more time to make a determination. This can be useful when DetectMessageEnd is provided in the MachineDetection parameter and there is an expectation of long answering machine greetings that can exceed 30 seconds.
	//
	// Decreasing this value will reduce the amount of time the engine has to make a determination. This can be particularly useful when the Enable option is provided in the MachineDetection parameter and you want to limit the time for initial detection.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 30
	MachineDetectionTimeout *float64 `json:"machineDetectionTimeout,omitempty" url:"machineDetectionTimeout,omitempty"`
	// The number of milliseconds that is used as the measuring stick for the length of the speech activity. Durations lower than this value will be interpreted as a human, longer as a machine. Default is 2400 milliseconds.
	//
	// Increasing this value will reduce the chance of a False Machine (detected machine, actually human) for a long human greeting (e.g., a business greeting) but increase the time it takes to detect a machine.
	//
	// Decreasing this value will reduce the chances of a False Human (detected human, actually machine) for short voicemail greetings. The value of this parameter may need to be reduced by more than 1000ms to detect very short voicemail greetings. A reduction of that significance can result in increased False Machine detections. Adjusting the MachineDetectionSpeechEndThreshold is likely the better approach for short voicemails. Decreasing MachineDetectionSpeechThreshold will also reduce the time it takes to detect a machine.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 2400
	MachineDetectionSpeechThreshold *float64 `json:"machineDetectionSpeechThreshold,omitempty" url:"machineDetectionSpeechThreshold,omitempty"`
	// The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Default is 1200 milliseconds.
	//
	// Increasing this value will typically be used to better address the short voicemail greeting scenarios. For short voicemails, there is typically 1000-2000ms of audio followed by 1200-2400ms of silence and then additional audio before the beep. Increasing the MachineDetectionSpeechEndThreshold to ~2500ms will treat the 1200-2400ms of silence as a gap in the greeting but not the end of the greeting and will result in a machine detection. The downsides of such a change include:
	// - Increasing the delay for human detection by the amount you increase this parameter, e.g., a change of 1200ms to 2500ms increases human detection delay by 1300ms.
	// - Cases where a human has two utterances separated by a period of silence (e.g. a "Hello", then 2000ms of silence, and another "Hello") may be interpreted as a machine.
	//
	// Decreasing this value will result in faster human detection. The consequence is that it can lead to increased False Human (detected human, actually machine) detections because a silence gap in a voicemail greeting (not necessarily just in short voicemail scenarios) can be incorrectly interpreted as the end of speech.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 1200
	MachineDetectionSpeechEndThreshold *float64 `json:"machineDetectionSpeechEndThreshold,omitempty" url:"machineDetectionSpeechEndThreshold,omitempty"`
	// The number of milliseconds of initial silence after which an unknown AnsweredBy result will be returned. Default is 5000 milliseconds.
	//
	// Increasing this value will result in waiting for a longer period of initial silence before returning an 'unknown' AMD result.
	//
	// Decreasing this value will result in waiting for a shorter period of initial silence before returning an 'unknown' AMD result.
	//
	// Check the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.
	//
	// @default 5000
	MachineDetectionSilenceTimeout *float64 `json:"machineDetectionSilenceTimeout,omitempty" url:"machineDetectionSilenceTimeout,omitempty"`
	provider                       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TwilioVoicemailDetection) GetVoicemailDetectionTypes() []TwilioVoicemailDetectionVoicemailDetectionTypesItem {
	if t == nil {
		return nil
	}
	return t.VoicemailDetectionTypes
}

func (t *TwilioVoicemailDetection) GetEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.Enabled
}

func (t *TwilioVoicemailDetection) GetMachineDetectionTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.MachineDetectionTimeout
}

func (t *TwilioVoicemailDetection) GetMachineDetectionSpeechThreshold() *float64 {
	if t == nil {
		return nil
	}
	return t.MachineDetectionSpeechThreshold
}

func (t *TwilioVoicemailDetection) GetMachineDetectionSpeechEndThreshold() *float64 {
	if t == nil {
		return nil
	}
	return t.MachineDetectionSpeechEndThreshold
}

func (t *TwilioVoicemailDetection) GetMachineDetectionSilenceTimeout() *float64 {
	if t == nil {
		return nil
	}
	return t.MachineDetectionSilenceTimeout
}

func (t *TwilioVoicemailDetection) Provider() string {
	return t.provider
}

func (t *TwilioVoicemailDetection) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TwilioVoicemailDetection) UnmarshalJSON(data []byte) error {
	type embed TwilioVoicemailDetection
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TwilioVoicemailDetection(unmarshaler.embed)
	if unmarshaler.Provider != "twilio" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", t, "twilio", unmarshaler.Provider)
	}
	t.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *t, "provider")
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TwilioVoicemailDetection) MarshalJSON() ([]byte, error) {
	type embed TwilioVoicemailDetection
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*t),
		Provider: "twilio",
	}
	return json.Marshal(marshaler)
}

func (t *TwilioVoicemailDetection) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TwilioVoicemailDetectionVoicemailDetectionTypesItem string

const (
	TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineStart      TwilioVoicemailDetectionVoicemailDetectionTypesItem = "machine_start"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemHuman             TwilioVoicemailDetectionVoicemailDetectionTypesItem = "human"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemFax               TwilioVoicemailDetectionVoicemailDetectionTypesItem = "fax"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemUnknown           TwilioVoicemailDetectionVoicemailDetectionTypesItem = "unknown"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndBeep    TwilioVoicemailDetectionVoicemailDetectionTypesItem = "machine_end_beep"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndSilence TwilioVoicemailDetectionVoicemailDetectionTypesItem = "machine_end_silence"
	TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndOther   TwilioVoicemailDetectionVoicemailDetectionTypesItem = "machine_end_other"
)

func NewTwilioVoicemailDetectionVoicemailDetectionTypesItemFromString(s string) (TwilioVoicemailDetectionVoicemailDetectionTypesItem, error) {
	switch s {
	case "machine_start":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineStart, nil
	case "human":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemHuman, nil
	case "fax":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemFax, nil
	case "unknown":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemUnknown, nil
	case "machine_end_beep":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndBeep, nil
	case "machine_end_silence":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndSilence, nil
	case "machine_end_other":
		return TwilioVoicemailDetectionVoicemailDetectionTypesItemMachineEndOther, nil
	}
	var t TwilioVoicemailDetectionVoicemailDetectionTypesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TwilioVoicemailDetectionVoicemailDetectionTypesItem) Ptr() *TwilioVoicemailDetectionVoicemailDetectionTypesItem {
	return &t
}

type UpdateAnthropicCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAnthropicCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateAnthropicCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAnthropicCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAnthropicCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAnthropicCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAnthropicCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAnthropicCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAnyscaleCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAnyscaleCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateAnyscaleCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAnyscaleCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAnyscaleCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAnyscaleCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAnyscaleCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAnyscaleCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAssemblyAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAssemblyAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateAssemblyAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAssemblyAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAssemblyAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAssemblyAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAssemblyAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAssemblyAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAzureCredentialDto struct {
	// This is the service being used in Azure.
	Service *UpdateAzureCredentialDtoService `json:"service,omitempty" url:"service,omitempty"`
	// This is the region of the Azure resource.
	Region *UpdateAzureCredentialDtoRegion `json:"region,omitempty" url:"region,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.
	BucketPlan *AzureBlobStorageBucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAzureCredentialDto) GetService() *UpdateAzureCredentialDtoService {
	if u == nil {
		return nil
	}
	return u.Service
}

func (u *UpdateAzureCredentialDto) GetRegion() *UpdateAzureCredentialDtoRegion {
	if u == nil {
		return nil
	}
	return u.Region
}

func (u *UpdateAzureCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateAzureCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAzureCredentialDto) GetBucketPlan() *AzureBlobStorageBucketPlan {
	if u == nil {
		return nil
	}
	return u.BucketPlan
}

func (u *UpdateAzureCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAzureCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAzureCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAzureCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAzureCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the region of the Azure resource.
type UpdateAzureCredentialDtoRegion string

const (
	UpdateAzureCredentialDtoRegionAustralia      UpdateAzureCredentialDtoRegion = "australia"
	UpdateAzureCredentialDtoRegionCanada         UpdateAzureCredentialDtoRegion = "canada"
	UpdateAzureCredentialDtoRegionEastus2        UpdateAzureCredentialDtoRegion = "eastus2"
	UpdateAzureCredentialDtoRegionEastus         UpdateAzureCredentialDtoRegion = "eastus"
	UpdateAzureCredentialDtoRegionFrance         UpdateAzureCredentialDtoRegion = "france"
	UpdateAzureCredentialDtoRegionIndia          UpdateAzureCredentialDtoRegion = "india"
	UpdateAzureCredentialDtoRegionJapan          UpdateAzureCredentialDtoRegion = "japan"
	UpdateAzureCredentialDtoRegionUaenorth       UpdateAzureCredentialDtoRegion = "uaenorth"
	UpdateAzureCredentialDtoRegionNorthcentralus UpdateAzureCredentialDtoRegion = "northcentralus"
	UpdateAzureCredentialDtoRegionNorway         UpdateAzureCredentialDtoRegion = "norway"
	UpdateAzureCredentialDtoRegionSouthcentralus UpdateAzureCredentialDtoRegion = "southcentralus"
	UpdateAzureCredentialDtoRegionSwedencentral  UpdateAzureCredentialDtoRegion = "swedencentral"
	UpdateAzureCredentialDtoRegionSwitzerland    UpdateAzureCredentialDtoRegion = "switzerland"
	UpdateAzureCredentialDtoRegionUk             UpdateAzureCredentialDtoRegion = "uk"
	UpdateAzureCredentialDtoRegionWestus         UpdateAzureCredentialDtoRegion = "westus"
	UpdateAzureCredentialDtoRegionWestus3        UpdateAzureCredentialDtoRegion = "westus3"
)

func NewUpdateAzureCredentialDtoRegionFromString(s string) (UpdateAzureCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return UpdateAzureCredentialDtoRegionAustralia, nil
	case "canada":
		return UpdateAzureCredentialDtoRegionCanada, nil
	case "eastus2":
		return UpdateAzureCredentialDtoRegionEastus2, nil
	case "eastus":
		return UpdateAzureCredentialDtoRegionEastus, nil
	case "france":
		return UpdateAzureCredentialDtoRegionFrance, nil
	case "india":
		return UpdateAzureCredentialDtoRegionIndia, nil
	case "japan":
		return UpdateAzureCredentialDtoRegionJapan, nil
	case "uaenorth":
		return UpdateAzureCredentialDtoRegionUaenorth, nil
	case "northcentralus":
		return UpdateAzureCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return UpdateAzureCredentialDtoRegionNorway, nil
	case "southcentralus":
		return UpdateAzureCredentialDtoRegionSouthcentralus, nil
	case "swedencentral":
		return UpdateAzureCredentialDtoRegionSwedencentral, nil
	case "switzerland":
		return UpdateAzureCredentialDtoRegionSwitzerland, nil
	case "uk":
		return UpdateAzureCredentialDtoRegionUk, nil
	case "westus":
		return UpdateAzureCredentialDtoRegionWestus, nil
	case "westus3":
		return UpdateAzureCredentialDtoRegionWestus3, nil
	}
	var t UpdateAzureCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureCredentialDtoRegion) Ptr() *UpdateAzureCredentialDtoRegion {
	return &u
}

// This is the service being used in Azure.
type UpdateAzureCredentialDtoService string

const (
	UpdateAzureCredentialDtoServiceSpeech      UpdateAzureCredentialDtoService = "speech"
	UpdateAzureCredentialDtoServiceBlobStorage UpdateAzureCredentialDtoService = "blob_storage"
)

func NewUpdateAzureCredentialDtoServiceFromString(s string) (UpdateAzureCredentialDtoService, error) {
	switch s {
	case "speech":
		return UpdateAzureCredentialDtoServiceSpeech, nil
	case "blob_storage":
		return UpdateAzureCredentialDtoServiceBlobStorage, nil
	}
	var t UpdateAzureCredentialDtoService
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureCredentialDtoService) Ptr() *UpdateAzureCredentialDtoService {
	return &u
}

type UpdateAzureOpenAiCredentialDto struct {
	Region *UpdateAzureOpenAiCredentialDtoRegion      `json:"region,omitempty" url:"region,omitempty"`
	Models []UpdateAzureOpenAiCredentialDtoModelsItem `json:"models,omitempty" url:"models,omitempty"`
	// This is not returned in the API.
	OpenAiKey *string `json:"openAIKey,omitempty" url:"openAIKey,omitempty"`
	// This is not returned in the API.
	OcpApimSubscriptionKey *string `json:"ocpApimSubscriptionKey,omitempty" url:"ocpApimSubscriptionKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name           *string `json:"name,omitempty" url:"name,omitempty"`
	OpenAiEndpoint *string `json:"openAIEndpoint,omitempty" url:"openAIEndpoint,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateAzureOpenAiCredentialDto) GetRegion() *UpdateAzureOpenAiCredentialDtoRegion {
	if u == nil {
		return nil
	}
	return u.Region
}

func (u *UpdateAzureOpenAiCredentialDto) GetModels() []UpdateAzureOpenAiCredentialDtoModelsItem {
	if u == nil {
		return nil
	}
	return u.Models
}

func (u *UpdateAzureOpenAiCredentialDto) GetOpenAiKey() *string {
	if u == nil {
		return nil
	}
	return u.OpenAiKey
}

func (u *UpdateAzureOpenAiCredentialDto) GetOcpApimSubscriptionKey() *string {
	if u == nil {
		return nil
	}
	return u.OcpApimSubscriptionKey
}

func (u *UpdateAzureOpenAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateAzureOpenAiCredentialDto) GetOpenAiEndpoint() *string {
	if u == nil {
		return nil
	}
	return u.OpenAiEndpoint
}

func (u *UpdateAzureOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateAzureOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAzureOpenAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAzureOpenAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAzureOpenAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateAzureOpenAiCredentialDtoModelsItem string

const (
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240806     UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-08-06"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718 UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-mini-2024-07-18"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240513     UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4o-2024-05-13"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409 UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-turbo-2024-04-09"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt40125Preview   UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0125-preview"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt41106Preview   UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-1106-preview"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt40613          UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-4-0613"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125    UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-0125"
	UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106    UpdateAzureOpenAiCredentialDtoModelsItem = "gpt-35-turbo-1106"
)

func NewUpdateAzureOpenAiCredentialDtoModelsItemFromString(s string) (UpdateAzureOpenAiCredentialDtoModelsItem, error) {
	switch s {
	case "gpt-4o-2024-08-06":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240806, nil
	case "gpt-4o-mini-2024-07-18":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4OMini20240718, nil
	case "gpt-4o-2024-05-13":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4O20240513, nil
	case "gpt-4-turbo-2024-04-09":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt4Turbo20240409, nil
	case "gpt-4-0125-preview":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt40125Preview, nil
	case "gpt-4-1106-preview":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt41106Preview, nil
	case "gpt-4-0613":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt40613, nil
	case "gpt-35-turbo-0125":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo0125, nil
	case "gpt-35-turbo-1106":
		return UpdateAzureOpenAiCredentialDtoModelsItemGpt35Turbo1106, nil
	}
	var t UpdateAzureOpenAiCredentialDtoModelsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureOpenAiCredentialDtoModelsItem) Ptr() *UpdateAzureOpenAiCredentialDtoModelsItem {
	return &u
}

type UpdateAzureOpenAiCredentialDtoRegion string

const (
	UpdateAzureOpenAiCredentialDtoRegionAustralia      UpdateAzureOpenAiCredentialDtoRegion = "australia"
	UpdateAzureOpenAiCredentialDtoRegionCanada         UpdateAzureOpenAiCredentialDtoRegion = "canada"
	UpdateAzureOpenAiCredentialDtoRegionEastus2        UpdateAzureOpenAiCredentialDtoRegion = "eastus2"
	UpdateAzureOpenAiCredentialDtoRegionEastus         UpdateAzureOpenAiCredentialDtoRegion = "eastus"
	UpdateAzureOpenAiCredentialDtoRegionFrance         UpdateAzureOpenAiCredentialDtoRegion = "france"
	UpdateAzureOpenAiCredentialDtoRegionIndia          UpdateAzureOpenAiCredentialDtoRegion = "india"
	UpdateAzureOpenAiCredentialDtoRegionJapan          UpdateAzureOpenAiCredentialDtoRegion = "japan"
	UpdateAzureOpenAiCredentialDtoRegionUaenorth       UpdateAzureOpenAiCredentialDtoRegion = "uaenorth"
	UpdateAzureOpenAiCredentialDtoRegionNorthcentralus UpdateAzureOpenAiCredentialDtoRegion = "northcentralus"
	UpdateAzureOpenAiCredentialDtoRegionNorway         UpdateAzureOpenAiCredentialDtoRegion = "norway"
	UpdateAzureOpenAiCredentialDtoRegionSouthcentralus UpdateAzureOpenAiCredentialDtoRegion = "southcentralus"
	UpdateAzureOpenAiCredentialDtoRegionSwedencentral  UpdateAzureOpenAiCredentialDtoRegion = "swedencentral"
	UpdateAzureOpenAiCredentialDtoRegionSwitzerland    UpdateAzureOpenAiCredentialDtoRegion = "switzerland"
	UpdateAzureOpenAiCredentialDtoRegionUk             UpdateAzureOpenAiCredentialDtoRegion = "uk"
	UpdateAzureOpenAiCredentialDtoRegionWestus         UpdateAzureOpenAiCredentialDtoRegion = "westus"
	UpdateAzureOpenAiCredentialDtoRegionWestus3        UpdateAzureOpenAiCredentialDtoRegion = "westus3"
)

func NewUpdateAzureOpenAiCredentialDtoRegionFromString(s string) (UpdateAzureOpenAiCredentialDtoRegion, error) {
	switch s {
	case "australia":
		return UpdateAzureOpenAiCredentialDtoRegionAustralia, nil
	case "canada":
		return UpdateAzureOpenAiCredentialDtoRegionCanada, nil
	case "eastus2":
		return UpdateAzureOpenAiCredentialDtoRegionEastus2, nil
	case "eastus":
		return UpdateAzureOpenAiCredentialDtoRegionEastus, nil
	case "france":
		return UpdateAzureOpenAiCredentialDtoRegionFrance, nil
	case "india":
		return UpdateAzureOpenAiCredentialDtoRegionIndia, nil
	case "japan":
		return UpdateAzureOpenAiCredentialDtoRegionJapan, nil
	case "uaenorth":
		return UpdateAzureOpenAiCredentialDtoRegionUaenorth, nil
	case "northcentralus":
		return UpdateAzureOpenAiCredentialDtoRegionNorthcentralus, nil
	case "norway":
		return UpdateAzureOpenAiCredentialDtoRegionNorway, nil
	case "southcentralus":
		return UpdateAzureOpenAiCredentialDtoRegionSouthcentralus, nil
	case "swedencentral":
		return UpdateAzureOpenAiCredentialDtoRegionSwedencentral, nil
	case "switzerland":
		return UpdateAzureOpenAiCredentialDtoRegionSwitzerland, nil
	case "uk":
		return UpdateAzureOpenAiCredentialDtoRegionUk, nil
	case "westus":
		return UpdateAzureOpenAiCredentialDtoRegionWestus, nil
	case "westus3":
		return UpdateAzureOpenAiCredentialDtoRegionWestus3, nil
	}
	var t UpdateAzureOpenAiCredentialDtoRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateAzureOpenAiCredentialDtoRegion) Ptr() *UpdateAzureOpenAiCredentialDtoRegion {
	return &u
}

type UpdateByoSipTrunkCredentialDto struct {
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the list of SIP trunk's gateways.
	Gateways []*SipTrunkGateway `json:"gateways,omitempty" url:"gateways,omitempty"`
	// This can be used to configure the outbound authentication if required by the SIP trunk.
	OutboundAuthenticationPlan *SipTrunkOutboundAuthenticationPlan `json:"outboundAuthenticationPlan,omitempty" url:"outboundAuthenticationPlan,omitempty"`
	// This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.
	//
	// Usage:
	// - Vonage/Twilio requires leading plus for all outbound calls. Set this to true.
	//
	// @default false
	OutboundLeadingPlusEnabled *bool `json:"outboundLeadingPlusEnabled,omitempty" url:"outboundLeadingPlusEnabled,omitempty"`
	// This can be used to configure the tech prefix on outbound calls. This is an advanced property.
	TechPrefix *string `json:"techPrefix,omitempty" url:"techPrefix,omitempty"`
	// This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.
	SipDiversionHeader *string `json:"sipDiversionHeader,omitempty" url:"sipDiversionHeader,omitempty"`
	// This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.
	SbcConfiguration *SbcConfiguration `json:"sbcConfiguration,omitempty" url:"sbcConfiguration,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateByoSipTrunkCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateByoSipTrunkCredentialDto) GetGateways() []*SipTrunkGateway {
	if u == nil {
		return nil
	}
	return u.Gateways
}

func (u *UpdateByoSipTrunkCredentialDto) GetOutboundAuthenticationPlan() *SipTrunkOutboundAuthenticationPlan {
	if u == nil {
		return nil
	}
	return u.OutboundAuthenticationPlan
}

func (u *UpdateByoSipTrunkCredentialDto) GetOutboundLeadingPlusEnabled() *bool {
	if u == nil {
		return nil
	}
	return u.OutboundLeadingPlusEnabled
}

func (u *UpdateByoSipTrunkCredentialDto) GetTechPrefix() *string {
	if u == nil {
		return nil
	}
	return u.TechPrefix
}

func (u *UpdateByoSipTrunkCredentialDto) GetSipDiversionHeader() *string {
	if u == nil {
		return nil
	}
	return u.SipDiversionHeader
}

func (u *UpdateByoSipTrunkCredentialDto) GetSbcConfiguration() *SbcConfiguration {
	if u == nil {
		return nil
	}
	return u.SbcConfiguration
}

func (u *UpdateByoSipTrunkCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateByoSipTrunkCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateByoSipTrunkCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateByoSipTrunkCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateByoSipTrunkCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCartesiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCartesiaCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateCartesiaCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateCartesiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCartesiaCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCartesiaCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCartesiaCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCartesiaCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCerebrasCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCerebrasCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateCerebrasCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateCerebrasCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCerebrasCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCerebrasCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCerebrasCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCerebrasCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCloudflareCredentialDto struct {
	// Cloudflare Account Id.
	AccountId *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Cloudflare API Key / Token.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// Cloudflare Account Email.
	AccountEmail *string `json:"accountEmail,omitempty" url:"accountEmail,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in R2
	BucketPlan *CloudflareR2BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCloudflareCredentialDto) GetAccountId() *string {
	if u == nil {
		return nil
	}
	return u.AccountId
}

func (u *UpdateCloudflareCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateCloudflareCredentialDto) GetAccountEmail() *string {
	if u == nil {
		return nil
	}
	return u.AccountEmail
}

func (u *UpdateCloudflareCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateCloudflareCredentialDto) GetBucketPlan() *CloudflareR2BucketPlan {
	if u == nil {
		return nil
	}
	return u.BucketPlan
}

func (u *UpdateCloudflareCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCloudflareCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCloudflareCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCloudflareCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCloudflareCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCustomLlmCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCustomLlmCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateCustomLlmCredentialDto) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if u == nil {
		return nil
	}
	return u.AuthenticationPlan
}

func (u *UpdateCustomLlmCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateCustomLlmCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomLlmCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomLlmCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomLlmCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomLlmCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDeepInfraCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateDeepInfraCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateDeepInfraCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateDeepInfraCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDeepInfraCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateDeepInfraCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateDeepInfraCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDeepInfraCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDeepSeekCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateDeepSeekCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateDeepSeekCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateDeepSeekCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDeepSeekCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateDeepSeekCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateDeepSeekCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDeepSeekCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateDeepgramCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com.
	ApiUrl *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateDeepgramCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateDeepgramCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateDeepgramCredentialDto) GetApiUrl() *string {
	if u == nil {
		return nil
	}
	return u.ApiUrl
}

func (u *UpdateDeepgramCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateDeepgramCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateDeepgramCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateDeepgramCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateDeepgramCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateElevenLabsCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateElevenLabsCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateElevenLabsCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateElevenLabsCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateElevenLabsCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateElevenLabsCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateElevenLabsCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateElevenLabsCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGcpCredentialDto struct {
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.
	//
	// The schema is identical to the JSON that GCP outputs.
	GcpKey *GcpKey `json:"gcpKey,omitempty" url:"gcpKey,omitempty"`
	// This is the bucket plan that can be provided to store call artifacts in GCP.
	BucketPlan *BucketPlan `json:"bucketPlan,omitempty" url:"bucketPlan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGcpCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGcpCredentialDto) GetGcpKey() *GcpKey {
	if u == nil {
		return nil
	}
	return u.GcpKey
}

func (u *UpdateGcpCredentialDto) GetBucketPlan() *BucketPlan {
	if u == nil {
		return nil
	}
	return u.BucketPlan
}

func (u *UpdateGcpCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGcpCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGcpCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGcpCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGcpCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGladiaCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGladiaCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateGladiaCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGladiaCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGladiaCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGladiaCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGladiaCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGladiaCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoHighLevelCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoHighLevelCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateGoHighLevelCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGoHighLevelCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoHighLevelCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoHighLevelCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoHighLevelCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoHighLevelCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGoogleCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGoogleCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateGoogleCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGoogleCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGoogleCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGoogleCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGoogleCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGoogleCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateGroqCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateGroqCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateGroqCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateGroqCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateGroqCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateGroqCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateGroqCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateGroqCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateInflectionAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateInflectionAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateInflectionAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateInflectionAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateInflectionAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateInflectionAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateInflectionAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateInflectionAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateLangfuseCredentialDto struct {
	// The public key for Langfuse project. Eg: pk-lf-...
	PublicKey *string `json:"publicKey,omitempty" url:"publicKey,omitempty"`
	// The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// The host URL for Langfuse project. Eg: https://cloud.langfuse.com
	ApiUrl *string `json:"apiUrl,omitempty" url:"apiUrl,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateLangfuseCredentialDto) GetPublicKey() *string {
	if u == nil {
		return nil
	}
	return u.PublicKey
}

func (u *UpdateLangfuseCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateLangfuseCredentialDto) GetApiUrl() *string {
	if u == nil {
		return nil
	}
	return u.ApiUrl
}

func (u *UpdateLangfuseCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateLangfuseCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLangfuseCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateLangfuseCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateLangfuseCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLangfuseCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateLmntCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateLmntCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateLmntCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateLmntCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLmntCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateLmntCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateLmntCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLmntCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateMakeCredentialDto struct {
	// Team ID
	TeamId *string `json:"teamId,omitempty" url:"teamId,omitempty"`
	// Region of your application. For example: eu1, eu2, us1, us2
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateMakeCredentialDto) GetTeamId() *string {
	if u == nil {
		return nil
	}
	return u.TeamId
}

func (u *UpdateMakeCredentialDto) GetRegion() *string {
	if u == nil {
		return nil
	}
	return u.Region
}

func (u *UpdateMakeCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateMakeCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateMakeCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMakeCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMakeCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMakeCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMakeCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOpenAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateOpenAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateOpenAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateOpenAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOpenAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOpenAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOpenAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOpenAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOpenRouterCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateOpenRouterCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateOpenRouterCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateOpenRouterCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOpenRouterCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOpenRouterCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOpenRouterCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOpenRouterCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateOrgDto struct {
	// When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.
	// When HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.
	// This is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.
	HipaaEnabled *bool `json:"hipaaEnabled,omitempty" url:"hipaaEnabled,omitempty"`
	// This is the ID of the subscription the org belongs to.
	SubscriptionId *string `json:"subscriptionId,omitempty" url:"subscriptionId,omitempty"`
	// This is the name of the org. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
	Channel *UpdateOrgDtoChannel `json:"channel,omitempty" url:"channel,omitempty"`
	// This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.
	BillingLimit *float64 `json:"billingLimit,omitempty" url:"billingLimit,omitempty"`
	// This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.
	//
	// The order of precedence is:
	//
	// 1. assistant.server
	// 2. phoneNumber.server
	// 3. org.server
	Server *Server `json:"server,omitempty" url:"server,omitempty"`
	// This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.
	ConcurrencyLimit *float64 `json:"concurrencyLimit,omitempty" url:"concurrencyLimit,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateOrgDto) GetHipaaEnabled() *bool {
	if u == nil {
		return nil
	}
	return u.HipaaEnabled
}

func (u *UpdateOrgDto) GetSubscriptionId() *string {
	if u == nil {
		return nil
	}
	return u.SubscriptionId
}

func (u *UpdateOrgDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateOrgDto) GetChannel() *UpdateOrgDtoChannel {
	if u == nil {
		return nil
	}
	return u.Channel
}

func (u *UpdateOrgDto) GetBillingLimit() *float64 {
	if u == nil {
		return nil
	}
	return u.BillingLimit
}

func (u *UpdateOrgDto) GetServer() *Server {
	if u == nil {
		return nil
	}
	return u.Server
}

func (u *UpdateOrgDto) GetConcurrencyLimit() *float64 {
	if u == nil {
		return nil
	}
	return u.ConcurrencyLimit
}

func (u *UpdateOrgDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOrgDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOrgDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOrgDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOrgDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the channel of the org. There is the cluster the API traffic for the org will be directed.
type UpdateOrgDtoChannel string

const (
	UpdateOrgDtoChannelDefault UpdateOrgDtoChannel = "default"
	UpdateOrgDtoChannelWeekly  UpdateOrgDtoChannel = "weekly"
)

func NewUpdateOrgDtoChannelFromString(s string) (UpdateOrgDtoChannel, error) {
	switch s {
	case "default":
		return UpdateOrgDtoChannelDefault, nil
	case "weekly":
		return UpdateOrgDtoChannelWeekly, nil
	}
	var t UpdateOrgDtoChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateOrgDtoChannel) Ptr() *UpdateOrgDtoChannel {
	return &u
}

type UpdatePerplexityAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdatePerplexityAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdatePerplexityAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdatePerplexityAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePerplexityAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePerplexityAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePerplexityAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePerplexityAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePlayHtCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name   *string `json:"name,omitempty" url:"name,omitempty"`
	UserId *string `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdatePlayHtCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdatePlayHtCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdatePlayHtCredentialDto) GetUserId() *string {
	if u == nil {
		return nil
	}
	return u.UserId
}

func (u *UpdatePlayHtCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePlayHtCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePlayHtCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePlayHtCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePlayHtCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateRimeAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateRimeAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateRimeAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateRimeAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateRimeAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateRimeAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateRimeAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateRimeAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateRunpodCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateRunpodCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateRunpodCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateRunpodCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateRunpodCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateRunpodCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateRunpodCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateRunpodCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateS3CredentialDto struct {
	// AWS access key ID.
	AwsAccessKeyId *string `json:"awsAccessKeyId,omitempty" url:"awsAccessKeyId,omitempty"`
	// AWS access key secret. This is not returned in the API.
	AwsSecretAccessKey *string `json:"awsSecretAccessKey,omitempty" url:"awsSecretAccessKey,omitempty"`
	// AWS region in which the S3 bucket is located.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// AWS S3 bucket name.
	S3BucketName *string `json:"s3BucketName,omitempty" url:"s3BucketName,omitempty"`
	// The path prefix for the uploaded recording. Ex. "recordings/"
	S3PathPrefix *string `json:"s3PathPrefix,omitempty" url:"s3PathPrefix,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateS3CredentialDto) GetAwsAccessKeyId() *string {
	if u == nil {
		return nil
	}
	return u.AwsAccessKeyId
}

func (u *UpdateS3CredentialDto) GetAwsSecretAccessKey() *string {
	if u == nil {
		return nil
	}
	return u.AwsSecretAccessKey
}

func (u *UpdateS3CredentialDto) GetRegion() *string {
	if u == nil {
		return nil
	}
	return u.Region
}

func (u *UpdateS3CredentialDto) GetS3BucketName() *string {
	if u == nil {
		return nil
	}
	return u.S3BucketName
}

func (u *UpdateS3CredentialDto) GetS3PathPrefix() *string {
	if u == nil {
		return nil
	}
	return u.S3PathPrefix
}

func (u *UpdateS3CredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateS3CredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateS3CredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateS3CredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateS3CredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateS3CredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSmallestAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSmallestAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateSmallestAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateSmallestAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSmallestAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSmallestAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSmallestAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSmallestAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTavusCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTavusCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateTavusCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTavusCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTavusCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTavusCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTavusCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTavusCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTogetherAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTogetherAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateTogetherAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTogetherAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTogetherAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTogetherAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTogetherAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTogetherAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateTokenDto struct {
	// This is the tag for the token. It represents its scope.
	Tag *UpdateTokenDtoTag `json:"tag,omitempty" url:"tag,omitempty"`
	// This is the name of the token. This is just for your own reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This are the restrictions for the token.
	Restrictions *TokenRestrictions `json:"restrictions,omitempty" url:"restrictions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTokenDto) GetTag() *UpdateTokenDtoTag {
	if u == nil {
		return nil
	}
	return u.Tag
}

func (u *UpdateTokenDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTokenDto) GetRestrictions() *TokenRestrictions {
	if u == nil {
		return nil
	}
	return u.Restrictions
}

func (u *UpdateTokenDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTokenDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTokenDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTokenDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTokenDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// This is the tag for the token. It represents its scope.
type UpdateTokenDtoTag string

const (
	UpdateTokenDtoTagPrivate UpdateTokenDtoTag = "private"
	UpdateTokenDtoTagPublic  UpdateTokenDtoTag = "public"
)

func NewUpdateTokenDtoTagFromString(s string) (UpdateTokenDtoTag, error) {
	switch s {
	case "private":
		return UpdateTokenDtoTagPrivate, nil
	case "public":
		return UpdateTokenDtoTagPublic, nil
	}
	var t UpdateTokenDtoTag
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateTokenDtoTag) Ptr() *UpdateTokenDtoTag {
	return &u
}

type UpdateToolTemplateDto struct {
	Details         *UpdateToolTemplateDtoDetails         `json:"details,omitempty" url:"details,omitempty"`
	ProviderDetails *UpdateToolTemplateDtoProviderDetails `json:"providerDetails,omitempty" url:"providerDetails,omitempty"`
	Metadata        *ToolTemplateMetadata                 `json:"metadata,omitempty" url:"metadata,omitempty"`
	Visibility      *UpdateToolTemplateDtoVisibility      `json:"visibility,omitempty" url:"visibility,omitempty"`
	// The name of the template. This is just for your own reference.
	Name     *string                        `json:"name,omitempty" url:"name,omitempty"`
	Provider *UpdateToolTemplateDtoProvider `json:"provider,omitempty" url:"provider,omitempty"`
	type_    string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateToolTemplateDto) GetDetails() *UpdateToolTemplateDtoDetails {
	if u == nil {
		return nil
	}
	return u.Details
}

func (u *UpdateToolTemplateDto) GetProviderDetails() *UpdateToolTemplateDtoProviderDetails {
	if u == nil {
		return nil
	}
	return u.ProviderDetails
}

func (u *UpdateToolTemplateDto) GetMetadata() *ToolTemplateMetadata {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UpdateToolTemplateDto) GetVisibility() *UpdateToolTemplateDtoVisibility {
	if u == nil {
		return nil
	}
	return u.Visibility
}

func (u *UpdateToolTemplateDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateToolTemplateDto) GetProvider() *UpdateToolTemplateDtoProvider {
	if u == nil {
		return nil
	}
	return u.Provider
}

func (u *UpdateToolTemplateDto) Type() string {
	return u.type_
}

func (u *UpdateToolTemplateDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateToolTemplateDto) UnmarshalJSON(data []byte) error {
	type embed UpdateToolTemplateDto
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UpdateToolTemplateDto(unmarshaler.embed)
	if unmarshaler.Type != "tool" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "tool", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateToolTemplateDto) MarshalJSON() ([]byte, error) {
	type embed UpdateToolTemplateDto
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "tool",
	}
	return json.Marshal(marshaler)
}

func (u *UpdateToolTemplateDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateToolTemplateDtoDetails struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (u *UpdateToolTemplateDtoDetails) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if u == nil {
		return nil
	}
	return u.CreateDtmfToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if u == nil {
		return nil
	}
	return u.CreateEndCallToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if u == nil {
		return nil
	}
	return u.CreateVoicemailToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if u == nil {
		return nil
	}
	return u.CreateFunctionToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateGhlToolDto() *CreateGhlToolDto {
	if u == nil {
		return nil
	}
	return u.CreateGhlToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateMakeToolDto() *CreateMakeToolDto {
	if u == nil {
		return nil
	}
	return u.CreateMakeToolDto
}

func (u *UpdateToolTemplateDtoDetails) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if u == nil {
		return nil
	}
	return u.CreateTransferCallToolDto
}

func (u *UpdateToolTemplateDtoDetails) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		u.typ = "CreateDtmfToolDto"
		u.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		u.typ = "CreateEndCallToolDto"
		u.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		u.typ = "CreateVoicemailToolDto"
		u.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		u.typ = "CreateFunctionToolDto"
		u.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		u.typ = "CreateGhlToolDto"
		u.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		u.typ = "CreateMakeToolDto"
		u.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		u.typ = "CreateTransferCallToolDto"
		u.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateToolTemplateDtoDetails) MarshalJSON() ([]byte, error) {
	if u.typ == "CreateDtmfToolDto" || u.CreateDtmfToolDto != nil {
		return json.Marshal(u.CreateDtmfToolDto)
	}
	if u.typ == "CreateEndCallToolDto" || u.CreateEndCallToolDto != nil {
		return json.Marshal(u.CreateEndCallToolDto)
	}
	if u.typ == "CreateVoicemailToolDto" || u.CreateVoicemailToolDto != nil {
		return json.Marshal(u.CreateVoicemailToolDto)
	}
	if u.typ == "CreateFunctionToolDto" || u.CreateFunctionToolDto != nil {
		return json.Marshal(u.CreateFunctionToolDto)
	}
	if u.typ == "CreateGhlToolDto" || u.CreateGhlToolDto != nil {
		return json.Marshal(u.CreateGhlToolDto)
	}
	if u.typ == "CreateMakeToolDto" || u.CreateMakeToolDto != nil {
		return json.Marshal(u.CreateMakeToolDto)
	}
	if u.typ == "CreateTransferCallToolDto" || u.CreateTransferCallToolDto != nil {
		return json.Marshal(u.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoDetailsVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (u *UpdateToolTemplateDtoDetails) Accept(visitor UpdateToolTemplateDtoDetailsVisitor) error {
	if u.typ == "CreateDtmfToolDto" || u.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(u.CreateDtmfToolDto)
	}
	if u.typ == "CreateEndCallToolDto" || u.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(u.CreateEndCallToolDto)
	}
	if u.typ == "CreateVoicemailToolDto" || u.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(u.CreateVoicemailToolDto)
	}
	if u.typ == "CreateFunctionToolDto" || u.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(u.CreateFunctionToolDto)
	}
	if u.typ == "CreateGhlToolDto" || u.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(u.CreateGhlToolDto)
	}
	if u.typ == "CreateMakeToolDto" || u.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(u.CreateMakeToolDto)
	}
	if u.typ == "CreateTransferCallToolDto" || u.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(u.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoProvider string

const (
	UpdateToolTemplateDtoProviderMake        UpdateToolTemplateDtoProvider = "make"
	UpdateToolTemplateDtoProviderGohighlevel UpdateToolTemplateDtoProvider = "gohighlevel"
	UpdateToolTemplateDtoProviderFunction    UpdateToolTemplateDtoProvider = "function"
)

func NewUpdateToolTemplateDtoProviderFromString(s string) (UpdateToolTemplateDtoProvider, error) {
	switch s {
	case "make":
		return UpdateToolTemplateDtoProviderMake, nil
	case "gohighlevel":
		return UpdateToolTemplateDtoProviderGohighlevel, nil
	case "function":
		return UpdateToolTemplateDtoProviderFunction, nil
	}
	var t UpdateToolTemplateDtoProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateToolTemplateDtoProvider) Ptr() *UpdateToolTemplateDtoProvider {
	return &u
}

type UpdateToolTemplateDtoProviderDetails struct {
	MakeToolProviderDetails     *MakeToolProviderDetails
	GhlToolProviderDetails      *GhlToolProviderDetails
	FunctionToolProviderDetails *FunctionToolProviderDetails

	typ string
}

func (u *UpdateToolTemplateDtoProviderDetails) GetMakeToolProviderDetails() *MakeToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.MakeToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetGhlToolProviderDetails() *GhlToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.GhlToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) GetFunctionToolProviderDetails() *FunctionToolProviderDetails {
	if u == nil {
		return nil
	}
	return u.FunctionToolProviderDetails
}

func (u *UpdateToolTemplateDtoProviderDetails) UnmarshalJSON(data []byte) error {
	valueMakeToolProviderDetails := new(MakeToolProviderDetails)
	if err := json.Unmarshal(data, &valueMakeToolProviderDetails); err == nil {
		u.typ = "MakeToolProviderDetails"
		u.MakeToolProviderDetails = valueMakeToolProviderDetails
		return nil
	}
	valueGhlToolProviderDetails := new(GhlToolProviderDetails)
	if err := json.Unmarshal(data, &valueGhlToolProviderDetails); err == nil {
		u.typ = "GhlToolProviderDetails"
		u.GhlToolProviderDetails = valueGhlToolProviderDetails
		return nil
	}
	valueFunctionToolProviderDetails := new(FunctionToolProviderDetails)
	if err := json.Unmarshal(data, &valueFunctionToolProviderDetails); err == nil {
		u.typ = "FunctionToolProviderDetails"
		u.FunctionToolProviderDetails = valueFunctionToolProviderDetails
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateToolTemplateDtoProviderDetails) MarshalJSON() ([]byte, error) {
	if u.typ == "MakeToolProviderDetails" || u.MakeToolProviderDetails != nil {
		return json.Marshal(u.MakeToolProviderDetails)
	}
	if u.typ == "GhlToolProviderDetails" || u.GhlToolProviderDetails != nil {
		return json.Marshal(u.GhlToolProviderDetails)
	}
	if u.typ == "FunctionToolProviderDetails" || u.FunctionToolProviderDetails != nil {
		return json.Marshal(u.FunctionToolProviderDetails)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoProviderDetailsVisitor interface {
	VisitMakeToolProviderDetails(*MakeToolProviderDetails) error
	VisitGhlToolProviderDetails(*GhlToolProviderDetails) error
	VisitFunctionToolProviderDetails(*FunctionToolProviderDetails) error
}

func (u *UpdateToolTemplateDtoProviderDetails) Accept(visitor UpdateToolTemplateDtoProviderDetailsVisitor) error {
	if u.typ == "MakeToolProviderDetails" || u.MakeToolProviderDetails != nil {
		return visitor.VisitMakeToolProviderDetails(u.MakeToolProviderDetails)
	}
	if u.typ == "GhlToolProviderDetails" || u.GhlToolProviderDetails != nil {
		return visitor.VisitGhlToolProviderDetails(u.GhlToolProviderDetails)
	}
	if u.typ == "FunctionToolProviderDetails" || u.FunctionToolProviderDetails != nil {
		return visitor.VisitFunctionToolProviderDetails(u.FunctionToolProviderDetails)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UpdateToolTemplateDtoVisibility string

const (
	UpdateToolTemplateDtoVisibilityPublic  UpdateToolTemplateDtoVisibility = "public"
	UpdateToolTemplateDtoVisibilityPrivate UpdateToolTemplateDtoVisibility = "private"
)

func NewUpdateToolTemplateDtoVisibilityFromString(s string) (UpdateToolTemplateDtoVisibility, error) {
	switch s {
	case "public":
		return UpdateToolTemplateDtoVisibilityPublic, nil
	case "private":
		return UpdateToolTemplateDtoVisibilityPrivate, nil
	}
	var t UpdateToolTemplateDtoVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateToolTemplateDtoVisibility) Ptr() *UpdateToolTemplateDtoVisibility {
	return &u
}

type UpdateTwilioCredentialDto struct {
	// This is not returned in the API.
	AuthToken *string `json:"authToken,omitempty" url:"authToken,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name       *string `json:"name,omitempty" url:"name,omitempty"`
	AccountSid *string `json:"accountSid,omitempty" url:"accountSid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTwilioCredentialDto) GetAuthToken() *string {
	if u == nil {
		return nil
	}
	return u.AuthToken
}

func (u *UpdateTwilioCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateTwilioCredentialDto) GetAccountSid() *string {
	if u == nil {
		return nil
	}
	return u.AccountSid
}

func (u *UpdateTwilioCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTwilioCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTwilioCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTwilioCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTwilioCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateUserRoleDto struct {
	UserId string                `json:"userId" url:"userId"`
	Role   UpdateUserRoleDtoRole `json:"role" url:"role"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateUserRoleDto) GetUserId() string {
	if u == nil {
		return ""
	}
	return u.UserId
}

func (u *UpdateUserRoleDto) GetRole() UpdateUserRoleDtoRole {
	if u == nil {
		return ""
	}
	return u.Role
}

func (u *UpdateUserRoleDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateUserRoleDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateUserRoleDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateUserRoleDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateUserRoleDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateUserRoleDtoRole string

const (
	UpdateUserRoleDtoRoleAdmin  UpdateUserRoleDtoRole = "admin"
	UpdateUserRoleDtoRoleEditor UpdateUserRoleDtoRole = "editor"
	UpdateUserRoleDtoRoleViewer UpdateUserRoleDtoRole = "viewer"
)

func NewUpdateUserRoleDtoRoleFromString(s string) (UpdateUserRoleDtoRole, error) {
	switch s {
	case "admin":
		return UpdateUserRoleDtoRoleAdmin, nil
	case "editor":
		return UpdateUserRoleDtoRoleEditor, nil
	case "viewer":
		return UpdateUserRoleDtoRoleViewer, nil
	}
	var t UpdateUserRoleDtoRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateUserRoleDtoRole) Ptr() *UpdateUserRoleDtoRole {
	return &u
}

type UpdateVonageCredentialDto struct {
	// This is not returned in the API.
	ApiSecret *string `json:"apiSecret,omitempty" url:"apiSecret,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name   *string `json:"name,omitempty" url:"name,omitempty"`
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateVonageCredentialDto) GetApiSecret() *string {
	if u == nil {
		return nil
	}
	return u.ApiSecret
}

func (u *UpdateVonageCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateVonageCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateVonageCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateVonageCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateVonageCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateVonageCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateVonageCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateXAiCredentialDto struct {
	// This is not returned in the API.
	ApiKey *string `json:"apiKey,omitempty" url:"apiKey,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateXAiCredentialDto) GetApiKey() *string {
	if u == nil {
		return nil
	}
	return u.ApiKey
}

func (u *UpdateXAiCredentialDto) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateXAiCredentialDto) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateXAiCredentialDto) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateXAiCredentialDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateXAiCredentialDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateXAiCredentialDto) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type User struct {
	// This is the unique identifier for the profile or user.
	Id string `json:"id" url:"id"`
	// This is the ISO 8601 date-time string of when the profile was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the profile was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the email of the user that is associated with the profile.
	Email string `json:"email" url:"email"`
	// This is the full name of the user that is associated with the profile.
	FullName *string `json:"fullName,omitempty" url:"fullName,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *User) GetId() string {
	if u == nil {
		return ""
	}
	return u.Id
}

func (u *User) GetCreatedAt() time.Time {
	if u == nil {
		return time.Time{}
	}
	return u.CreatedAt
}

func (u *User) GetUpdatedAt() time.Time {
	if u == nil {
		return time.Time{}
	}
	return u.UpdatedAt
}

func (u *User) GetEmail() string {
	if u == nil {
		return ""
	}
	return u.Email
}

func (u *User) GetFullName() *string {
	if u == nil {
		return nil
	}
	return u.FullName
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type embed User
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = User(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) MarshalJSON() ([]byte, error) {
	type embed User
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*u),
		CreatedAt: internal.NewDateTime(u.CreatedAt),
		UpdatedAt: internal.NewDateTime(u.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (u *User) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VapiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*VapiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string               `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	Steps           []*VapiModelStepsItem `json:"steps,omitempty" url:"steps,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	Model string `json:"model" url:"model"`
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VapiModel) GetMessages() []*OpenAiMessage {
	if v == nil {
		return nil
	}
	return v.Messages
}

func (v *VapiModel) GetTools() []*VapiModelToolsItem {
	if v == nil {
		return nil
	}
	return v.Tools
}

func (v *VapiModel) GetToolIds() []string {
	if v == nil {
		return nil
	}
	return v.ToolIds
}

func (v *VapiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if v == nil {
		return nil
	}
	return v.KnowledgeBase
}

func (v *VapiModel) GetKnowledgeBaseId() *string {
	if v == nil {
		return nil
	}
	return v.KnowledgeBaseId
}

func (v *VapiModel) GetSteps() []*VapiModelStepsItem {
	if v == nil {
		return nil
	}
	return v.Steps
}

func (v *VapiModel) GetModel() string {
	if v == nil {
		return ""
	}
	return v.Model
}

func (v *VapiModel) GetTemperature() *float64 {
	if v == nil {
		return nil
	}
	return v.Temperature
}

func (v *VapiModel) GetMaxTokens() *float64 {
	if v == nil {
		return nil
	}
	return v.MaxTokens
}

func (v *VapiModel) GetEmotionRecognitionEnabled() *bool {
	if v == nil {
		return nil
	}
	return v.EmotionRecognitionEnabled
}

func (v *VapiModel) GetNumFastTurns() *float64 {
	if v == nil {
		return nil
	}
	return v.NumFastTurns
}

func (v *VapiModel) Provider() string {
	return v.provider
}

func (v *VapiModel) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VapiModel) UnmarshalJSON(data []byte) error {
	type embed VapiModel
	var unmarshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VapiModel(unmarshaler.embed)
	if unmarshaler.Provider != "vapi" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vapi", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VapiModel) MarshalJSON() ([]byte, error) {
	type embed VapiModel
	var marshaler = struct {
		embed
		Provider string `json:"provider"`
	}{
		embed:    embed(*v),
		Provider: "vapi",
	}
	return json.Marshal(marshaler)
}

func (v *VapiModel) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VapiModelStepsItem struct {
	HandoffStep  *HandoffStep
	CallbackStep *CallbackStep

	typ string
}

func (v *VapiModelStepsItem) GetHandoffStep() *HandoffStep {
	if v == nil {
		return nil
	}
	return v.HandoffStep
}

func (v *VapiModelStepsItem) GetCallbackStep() *CallbackStep {
	if v == nil {
		return nil
	}
	return v.CallbackStep
}

func (v *VapiModelStepsItem) UnmarshalJSON(data []byte) error {
	valueHandoffStep := new(HandoffStep)
	if err := json.Unmarshal(data, &valueHandoffStep); err == nil {
		v.typ = "HandoffStep"
		v.HandoffStep = valueHandoffStep
		return nil
	}
	valueCallbackStep := new(CallbackStep)
	if err := json.Unmarshal(data, &valueCallbackStep); err == nil {
		v.typ = "CallbackStep"
		v.CallbackStep = valueCallbackStep
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VapiModelStepsItem) MarshalJSON() ([]byte, error) {
	if v.typ == "HandoffStep" || v.HandoffStep != nil {
		return json.Marshal(v.HandoffStep)
	}
	if v.typ == "CallbackStep" || v.CallbackStep != nil {
		return json.Marshal(v.CallbackStep)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiModelStepsItemVisitor interface {
	VisitHandoffStep(*HandoffStep) error
	VisitCallbackStep(*CallbackStep) error
}

func (v *VapiModelStepsItem) Accept(visitor VapiModelStepsItemVisitor) error {
	if v.typ == "HandoffStep" || v.HandoffStep != nil {
		return visitor.VisitHandoffStep(v.HandoffStep)
	}
	if v.typ == "CallbackStep" || v.CallbackStep != nil {
		return visitor.VisitCallbackStep(v.CallbackStep)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (v *VapiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if v == nil {
		return nil
	}
	return v.CreateDtmfToolDto
}

func (v *VapiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if v == nil {
		return nil
	}
	return v.CreateEndCallToolDto
}

func (v *VapiModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if v == nil {
		return nil
	}
	return v.CreateVoicemailToolDto
}

func (v *VapiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if v == nil {
		return nil
	}
	return v.CreateFunctionToolDto
}

func (v *VapiModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if v == nil {
		return nil
	}
	return v.CreateGhlToolDto
}

func (v *VapiModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if v == nil {
		return nil
	}
	return v.CreateMakeToolDto
}

func (v *VapiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if v == nil {
		return nil
	}
	return v.CreateTransferCallToolDto
}

func (v *VapiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		v.typ = "CreateDtmfToolDto"
		v.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		v.typ = "CreateEndCallToolDto"
		v.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		v.typ = "CreateVoicemailToolDto"
		v.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		v.typ = "CreateFunctionToolDto"
		v.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		v.typ = "CreateGhlToolDto"
		v.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		v.typ = "CreateMakeToolDto"
		v.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		v.typ = "CreateTransferCallToolDto"
		v.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VapiModelToolsItem) MarshalJSON() ([]byte, error) {
	if v.typ == "CreateDtmfToolDto" || v.CreateDtmfToolDto != nil {
		return json.Marshal(v.CreateDtmfToolDto)
	}
	if v.typ == "CreateEndCallToolDto" || v.CreateEndCallToolDto != nil {
		return json.Marshal(v.CreateEndCallToolDto)
	}
	if v.typ == "CreateVoicemailToolDto" || v.CreateVoicemailToolDto != nil {
		return json.Marshal(v.CreateVoicemailToolDto)
	}
	if v.typ == "CreateFunctionToolDto" || v.CreateFunctionToolDto != nil {
		return json.Marshal(v.CreateFunctionToolDto)
	}
	if v.typ == "CreateGhlToolDto" || v.CreateGhlToolDto != nil {
		return json.Marshal(v.CreateGhlToolDto)
	}
	if v.typ == "CreateMakeToolDto" || v.CreateMakeToolDto != nil {
		return json.Marshal(v.CreateMakeToolDto)
	}
	if v.typ == "CreateTransferCallToolDto" || v.CreateTransferCallToolDto != nil {
		return json.Marshal(v.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VapiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (v *VapiModelToolsItem) Accept(visitor VapiModelToolsItemVisitor) error {
	if v.typ == "CreateDtmfToolDto" || v.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(v.CreateDtmfToolDto)
	}
	if v.typ == "CreateEndCallToolDto" || v.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(v.CreateEndCallToolDto)
	}
	if v.typ == "CreateVoicemailToolDto" || v.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(v.CreateVoicemailToolDto)
	}
	if v.typ == "CreateFunctionToolDto" || v.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(v.CreateFunctionToolDto)
	}
	if v.typ == "CreateGhlToolDto" || v.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(v.CreateGhlToolDto)
	}
	if v.typ == "CreateMakeToolDto" || v.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(v.CreateMakeToolDto)
	}
	if v.typ == "CreateTransferCallToolDto" || v.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(v.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VoiceLibrary struct {
	// This is the voice provider that will be used.
	Provider map[string]interface{} `json:"provider,omitempty" url:"provider,omitempty"`
	// The ID of the voice provided by the provider.
	ProviderId *string `json:"providerId,omitempty" url:"providerId,omitempty"`
	// The unique slug of the voice.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// The name of the voice.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The language of the voice.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The language code of the voice.
	LanguageCode *string `json:"languageCode,omitempty" url:"languageCode,omitempty"`
	// The model of the voice.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The supported models of the voice.
	SupportedModels *string `json:"supportedModels,omitempty" url:"supportedModels,omitempty"`
	// The gender of the voice.
	Gender *VoiceLibraryGender `json:"gender,omitempty" url:"gender,omitempty"`
	// The accent of the voice.
	Accent *string `json:"accent,omitempty" url:"accent,omitempty"`
	// The preview URL of the voice.
	PreviewUrl *string `json:"previewUrl,omitempty" url:"previewUrl,omitempty"`
	// The description of the voice.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The credential ID of the voice.
	CredentialId *string `json:"credentialId,omitempty" url:"credentialId,omitempty"`
	// The unique identifier for the voice library.
	Id string `json:"id" url:"id"`
	// The unique identifier for the organization that this voice library belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// The Public voice is shared accross all the organizations.
	IsPublic bool `json:"isPublic" url:"isPublic"`
	// The deletion status of the voice.
	IsDeleted bool `json:"isDeleted" url:"isDeleted"`
	// The ISO 8601 date-time string of when the voice library was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The ISO 8601 date-time string of when the voice library was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VoiceLibrary) GetProvider() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Provider
}

func (v *VoiceLibrary) GetProviderId() *string {
	if v == nil {
		return nil
	}
	return v.ProviderId
}

func (v *VoiceLibrary) GetSlug() *string {
	if v == nil {
		return nil
	}
	return v.Slug
}

func (v *VoiceLibrary) GetName() *string {
	if v == nil {
		return nil
	}
	return v.Name
}

func (v *VoiceLibrary) GetLanguage() *string {
	if v == nil {
		return nil
	}
	return v.Language
}

func (v *VoiceLibrary) GetLanguageCode() *string {
	if v == nil {
		return nil
	}
	return v.LanguageCode
}

func (v *VoiceLibrary) GetModel() *string {
	if v == nil {
		return nil
	}
	return v.Model
}

func (v *VoiceLibrary) GetSupportedModels() *string {
	if v == nil {
		return nil
	}
	return v.SupportedModels
}

func (v *VoiceLibrary) GetGender() *VoiceLibraryGender {
	if v == nil {
		return nil
	}
	return v.Gender
}

func (v *VoiceLibrary) GetAccent() *string {
	if v == nil {
		return nil
	}
	return v.Accent
}

func (v *VoiceLibrary) GetPreviewUrl() *string {
	if v == nil {
		return nil
	}
	return v.PreviewUrl
}

func (v *VoiceLibrary) GetDescription() *string {
	if v == nil {
		return nil
	}
	return v.Description
}

func (v *VoiceLibrary) GetCredentialId() *string {
	if v == nil {
		return nil
	}
	return v.CredentialId
}

func (v *VoiceLibrary) GetId() string {
	if v == nil {
		return ""
	}
	return v.Id
}

func (v *VoiceLibrary) GetOrgId() string {
	if v == nil {
		return ""
	}
	return v.OrgId
}

func (v *VoiceLibrary) GetIsPublic() bool {
	if v == nil {
		return false
	}
	return v.IsPublic
}

func (v *VoiceLibrary) GetIsDeleted() bool {
	if v == nil {
		return false
	}
	return v.IsDeleted
}

func (v *VoiceLibrary) GetCreatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.CreatedAt
}

func (v *VoiceLibrary) GetUpdatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.UpdatedAt
}

func (v *VoiceLibrary) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceLibrary) UnmarshalJSON(data []byte) error {
	type embed VoiceLibrary
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VoiceLibrary(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceLibrary) MarshalJSON() ([]byte, error) {
	type embed VoiceLibrary
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*v),
		CreatedAt: internal.NewDateTime(v.CreatedAt),
		UpdatedAt: internal.NewDateTime(v.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (v *VoiceLibrary) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The gender of the voice.
type VoiceLibraryGender string

const (
	VoiceLibraryGenderMale   VoiceLibraryGender = "male"
	VoiceLibraryGenderFemale VoiceLibraryGender = "female"
)

func NewVoiceLibraryGenderFromString(s string) (VoiceLibraryGender, error) {
	switch s {
	case "male":
		return VoiceLibraryGenderMale, nil
	case "female":
		return VoiceLibraryGenderFemale, nil
	}
	var t VoiceLibraryGender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VoiceLibraryGender) Ptr() *VoiceLibraryGender {
	return &v
}

type VoiceLibraryVoiceResponse struct {
	VoiceId       string                 `json:"voiceId" url:"voiceId"`
	Name          string                 `json:"name" url:"name"`
	PublicOwnerId *string                `json:"publicOwnerId,omitempty" url:"publicOwnerId,omitempty"`
	Description   *string                `json:"description,omitempty" url:"description,omitempty"`
	Gender        *string                `json:"gender,omitempty" url:"gender,omitempty"`
	Age           map[string]interface{} `json:"age,omitempty" url:"age,omitempty"`
	Accent        *string                `json:"accent,omitempty" url:"accent,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VoiceLibraryVoiceResponse) GetVoiceId() string {
	if v == nil {
		return ""
	}
	return v.VoiceId
}

func (v *VoiceLibraryVoiceResponse) GetName() string {
	if v == nil {
		return ""
	}
	return v.Name
}

func (v *VoiceLibraryVoiceResponse) GetPublicOwnerId() *string {
	if v == nil {
		return nil
	}
	return v.PublicOwnerId
}

func (v *VoiceLibraryVoiceResponse) GetDescription() *string {
	if v == nil {
		return nil
	}
	return v.Description
}

func (v *VoiceLibraryVoiceResponse) GetGender() *string {
	if v == nil {
		return nil
	}
	return v.Gender
}

func (v *VoiceLibraryVoiceResponse) GetAge() map[string]interface{} {
	if v == nil {
		return nil
	}
	return v.Age
}

func (v *VoiceLibraryVoiceResponse) GetAccent() *string {
	if v == nil {
		return nil
	}
	return v.Accent
}

func (v *VoiceLibraryVoiceResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceLibraryVoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceLibraryVoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceLibraryVoiceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceLibraryVoiceResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VonageCredential struct {
	// This is not returned in the API.
	VonageApplicationPrivateKey string `json:"vonageApplicationPrivateKey" url:"vonageApplicationPrivateKey"`
	// This is not returned in the API.
	ApiSecret string `json:"apiSecret" url:"apiSecret"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the Vonage Application ID for the credential.
	//
	// Only relevant for Vonage credentials.
	VonageApplicationId string `json:"vonageApplicationId" url:"vonageApplicationId"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	ApiKey   string  `json:"apiKey" url:"apiKey"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VonageCredential) GetVonageApplicationPrivateKey() string {
	if v == nil {
		return ""
	}
	return v.VonageApplicationPrivateKey
}

func (v *VonageCredential) GetApiSecret() string {
	if v == nil {
		return ""
	}
	return v.ApiSecret
}

func (v *VonageCredential) GetId() string {
	if v == nil {
		return ""
	}
	return v.Id
}

func (v *VonageCredential) GetOrgId() string {
	if v == nil {
		return ""
	}
	return v.OrgId
}

func (v *VonageCredential) GetCreatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.CreatedAt
}

func (v *VonageCredential) GetUpdatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.UpdatedAt
}

func (v *VonageCredential) GetVonageApplicationId() string {
	if v == nil {
		return ""
	}
	return v.VonageApplicationId
}

func (v *VonageCredential) GetName() *string {
	if v == nil {
		return nil
	}
	return v.Name
}

func (v *VonageCredential) GetApiKey() string {
	if v == nil {
		return ""
	}
	return v.ApiKey
}

func (v *VonageCredential) Provider() string {
	return v.provider
}

func (v *VonageCredential) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VonageCredential) UnmarshalJSON(data []byte) error {
	type embed VonageCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VonageCredential(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "vonage" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", v, "vonage", unmarshaler.Provider)
	}
	v.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *v, "provider")
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VonageCredential) MarshalJSON() ([]byte, error) {
	type embed VonageCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*v),
		CreatedAt: internal.NewDateTime(v.CreatedAt),
		UpdatedAt: internal.NewDateTime(v.UpdatedAt),
		Provider:  "vonage",
	}
	return json.Marshal(marshaler)
}

func (v *VonageCredential) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WebhookCredential struct {
	// This is the authentication plan. Currently supports OAuth2 RFC 6749.
	AuthenticationPlan *OAuth2AuthenticationPlan `json:"authenticationPlan,omitempty" url:"authenticationPlan,omitempty"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the authentication session for the credential. Available for credentials that have an authentication plan.
	AuthenticationSession *Oauth2AuthenticationSession `json:"authenticationSession,omitempty" url:"authenticationSession,omitempty"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookCredential) GetAuthenticationPlan() *OAuth2AuthenticationPlan {
	if w == nil {
		return nil
	}
	return w.AuthenticationPlan
}

func (w *WebhookCredential) GetId() string {
	if w == nil {
		return ""
	}
	return w.Id
}

func (w *WebhookCredential) GetOrgId() string {
	if w == nil {
		return ""
	}
	return w.OrgId
}

func (w *WebhookCredential) GetCreatedAt() time.Time {
	if w == nil {
		return time.Time{}
	}
	return w.CreatedAt
}

func (w *WebhookCredential) GetUpdatedAt() time.Time {
	if w == nil {
		return time.Time{}
	}
	return w.UpdatedAt
}

func (w *WebhookCredential) GetAuthenticationSession() *Oauth2AuthenticationSession {
	if w == nil {
		return nil
	}
	return w.AuthenticationSession
}

func (w *WebhookCredential) GetName() *string {
	if w == nil {
		return nil
	}
	return w.Name
}

func (w *WebhookCredential) Provider() string {
	return w.provider
}

func (w *WebhookCredential) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookCredential) UnmarshalJSON(data []byte) error {
	type embed WebhookCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WebhookCredential(unmarshaler.embed)
	w.CreatedAt = unmarshaler.CreatedAt.Time()
	w.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "webhook" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", w, "webhook", unmarshaler.Provider)
	}
	w.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *w, "provider")
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookCredential) MarshalJSON() ([]byte, error) {
	type embed WebhookCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*w),
		CreatedAt: internal.NewDateTime(w.CreatedAt),
		UpdatedAt: internal.NewDateTime(w.UpdatedAt),
		Provider:  "webhook",
	}
	return json.Marshal(marshaler)
}

func (w *WebhookCredential) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type XAiCredential struct {
	// This is the api key for Grok in XAi's console. Get it from here: https://console.x.ai
	// This is not returned in the API.
	ApiKey string `json:"apiKey" url:"apiKey"`
	// This is the unique identifier for the credential.
	Id string `json:"id" url:"id"`
	// This is the unique identifier for the org that this credential belongs to.
	OrgId string `json:"orgId" url:"orgId"`
	// This is the ISO 8601 date-time string of when the credential was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// This is the ISO 8601 date-time string of when the assistant was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// This is the name of credential. This is just for your reference.
	Name     *string `json:"name,omitempty" url:"name,omitempty"`
	provider string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (x *XAiCredential) GetApiKey() string {
	if x == nil {
		return ""
	}
	return x.ApiKey
}

func (x *XAiCredential) GetId() string {
	if x == nil {
		return ""
	}
	return x.Id
}

func (x *XAiCredential) GetOrgId() string {
	if x == nil {
		return ""
	}
	return x.OrgId
}

func (x *XAiCredential) GetCreatedAt() time.Time {
	if x == nil {
		return time.Time{}
	}
	return x.CreatedAt
}

func (x *XAiCredential) GetUpdatedAt() time.Time {
	if x == nil {
		return time.Time{}
	}
	return x.UpdatedAt
}

func (x *XAiCredential) GetName() *string {
	if x == nil {
		return nil
	}
	return x.Name
}

func (x *XAiCredential) Provider() string {
	return x.provider
}

func (x *XAiCredential) GetExtraProperties() map[string]interface{} {
	return x.extraProperties
}

func (x *XAiCredential) UnmarshalJSON(data []byte) error {
	type embed XAiCredential
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed: embed(*x),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*x = XAiCredential(unmarshaler.embed)
	x.CreatedAt = unmarshaler.CreatedAt.Time()
	x.UpdatedAt = unmarshaler.UpdatedAt.Time()
	if unmarshaler.Provider != "xai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", x, "xai", unmarshaler.Provider)
	}
	x.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *x, "provider")
	if err != nil {
		return err
	}
	x.extraProperties = extraProperties
	x.rawJSON = json.RawMessage(data)
	return nil
}

func (x *XAiCredential) MarshalJSON() ([]byte, error) {
	type embed XAiCredential
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
		Provider  string             `json:"provider"`
	}{
		embed:     embed(*x),
		CreatedAt: internal.NewDateTime(x.CreatedAt),
		UpdatedAt: internal.NewDateTime(x.UpdatedAt),
		Provider:  "xai",
	}
	return json.Marshal(marshaler)
}

func (x *XAiCredential) String() string {
	if len(x.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(x.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(x); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", x)
}

type XaiModel struct {
	// This is the starting state for the conversation.
	Messages []*OpenAiMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.
	//
	// Both `tools` and `toolIds` can be used together.
	Tools []*XaiModelToolsItem `json:"tools,omitempty" url:"tools,omitempty"`
	// These are the tools that the assistant can use during the call. To use transient tools, use `tools`.
	//
	// Both `tools` and `toolIds` can be used together.
	ToolIds []string `json:"toolIds,omitempty" url:"toolIds,omitempty"`
	// These are the options for the knowledge base.
	KnowledgeBase *CreateCustomKnowledgeBaseDto `json:"knowledgeBase,omitempty" url:"knowledgeBase,omitempty"`
	// This is the ID of the knowledge base the model will use.
	KnowledgeBaseId *string `json:"knowledgeBaseId,omitempty" url:"knowledgeBaseId,omitempty"`
	// This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b
	// This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.
	MaxTokens *float64 `json:"maxTokens,omitempty" url:"maxTokens,omitempty"`
	// This determines whether we detect user's emotion while they speak and send it as an additional info to model.
	//
	// Default `false` because the model is usually are good at understanding the user's emotion from text.
	//
	// @default false
	EmotionRecognitionEnabled *bool `json:"emotionRecognitionEnabled,omitempty" url:"emotionRecognitionEnabled,omitempty"`
	// This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.
	//
	// Default is 0.
	//
	// @default 0
	NumFastTurns *float64 `json:"numFastTurns,omitempty" url:"numFastTurns,omitempty"`
	model        string
	provider     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (x *XaiModel) GetMessages() []*OpenAiMessage {
	if x == nil {
		return nil
	}
	return x.Messages
}

func (x *XaiModel) GetTools() []*XaiModelToolsItem {
	if x == nil {
		return nil
	}
	return x.Tools
}

func (x *XaiModel) GetToolIds() []string {
	if x == nil {
		return nil
	}
	return x.ToolIds
}

func (x *XaiModel) GetKnowledgeBase() *CreateCustomKnowledgeBaseDto {
	if x == nil {
		return nil
	}
	return x.KnowledgeBase
}

func (x *XaiModel) GetKnowledgeBaseId() *string {
	if x == nil {
		return nil
	}
	return x.KnowledgeBaseId
}

func (x *XaiModel) GetTemperature() *float64 {
	if x == nil {
		return nil
	}
	return x.Temperature
}

func (x *XaiModel) GetMaxTokens() *float64 {
	if x == nil {
		return nil
	}
	return x.MaxTokens
}

func (x *XaiModel) GetEmotionRecognitionEnabled() *bool {
	if x == nil {
		return nil
	}
	return x.EmotionRecognitionEnabled
}

func (x *XaiModel) GetNumFastTurns() *float64 {
	if x == nil {
		return nil
	}
	return x.NumFastTurns
}

func (x *XaiModel) Model() string {
	return x.model
}

func (x *XaiModel) Provider() string {
	return x.provider
}

func (x *XaiModel) GetExtraProperties() map[string]interface{} {
	return x.extraProperties
}

func (x *XaiModel) UnmarshalJSON(data []byte) error {
	type embed XaiModel
	var unmarshaler = struct {
		embed
		Model    string `json:"model"`
		Provider string `json:"provider"`
	}{
		embed: embed(*x),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*x = XaiModel(unmarshaler.embed)
	if unmarshaler.Model != "grok-beta" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", x, "grok-beta", unmarshaler.Model)
	}
	x.model = unmarshaler.Model
	if unmarshaler.Provider != "xai" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", x, "xai", unmarshaler.Provider)
	}
	x.provider = unmarshaler.Provider
	extraProperties, err := internal.ExtractExtraProperties(data, *x, "model", "provider")
	if err != nil {
		return err
	}
	x.extraProperties = extraProperties
	x.rawJSON = json.RawMessage(data)
	return nil
}

func (x *XaiModel) MarshalJSON() ([]byte, error) {
	type embed XaiModel
	var marshaler = struct {
		embed
		Model    string `json:"model"`
		Provider string `json:"provider"`
	}{
		embed:    embed(*x),
		Model:    "grok-beta",
		Provider: "xai",
	}
	return json.Marshal(marshaler)
}

func (x *XaiModel) String() string {
	if len(x.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(x.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(x); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", x)
}

type XaiModelToolsItem struct {
	CreateDtmfToolDto         *CreateDtmfToolDto
	CreateEndCallToolDto      *CreateEndCallToolDto
	CreateVoicemailToolDto    *CreateVoicemailToolDto
	CreateFunctionToolDto     *CreateFunctionToolDto
	CreateGhlToolDto          *CreateGhlToolDto
	CreateMakeToolDto         *CreateMakeToolDto
	CreateTransferCallToolDto *CreateTransferCallToolDto

	typ string
}

func (x *XaiModelToolsItem) GetCreateDtmfToolDto() *CreateDtmfToolDto {
	if x == nil {
		return nil
	}
	return x.CreateDtmfToolDto
}

func (x *XaiModelToolsItem) GetCreateEndCallToolDto() *CreateEndCallToolDto {
	if x == nil {
		return nil
	}
	return x.CreateEndCallToolDto
}

func (x *XaiModelToolsItem) GetCreateVoicemailToolDto() *CreateVoicemailToolDto {
	if x == nil {
		return nil
	}
	return x.CreateVoicemailToolDto
}

func (x *XaiModelToolsItem) GetCreateFunctionToolDto() *CreateFunctionToolDto {
	if x == nil {
		return nil
	}
	return x.CreateFunctionToolDto
}

func (x *XaiModelToolsItem) GetCreateGhlToolDto() *CreateGhlToolDto {
	if x == nil {
		return nil
	}
	return x.CreateGhlToolDto
}

func (x *XaiModelToolsItem) GetCreateMakeToolDto() *CreateMakeToolDto {
	if x == nil {
		return nil
	}
	return x.CreateMakeToolDto
}

func (x *XaiModelToolsItem) GetCreateTransferCallToolDto() *CreateTransferCallToolDto {
	if x == nil {
		return nil
	}
	return x.CreateTransferCallToolDto
}

func (x *XaiModelToolsItem) UnmarshalJSON(data []byte) error {
	valueCreateDtmfToolDto := new(CreateDtmfToolDto)
	if err := json.Unmarshal(data, &valueCreateDtmfToolDto); err == nil {
		x.typ = "CreateDtmfToolDto"
		x.CreateDtmfToolDto = valueCreateDtmfToolDto
		return nil
	}
	valueCreateEndCallToolDto := new(CreateEndCallToolDto)
	if err := json.Unmarshal(data, &valueCreateEndCallToolDto); err == nil {
		x.typ = "CreateEndCallToolDto"
		x.CreateEndCallToolDto = valueCreateEndCallToolDto
		return nil
	}
	valueCreateVoicemailToolDto := new(CreateVoicemailToolDto)
	if err := json.Unmarshal(data, &valueCreateVoicemailToolDto); err == nil {
		x.typ = "CreateVoicemailToolDto"
		x.CreateVoicemailToolDto = valueCreateVoicemailToolDto
		return nil
	}
	valueCreateFunctionToolDto := new(CreateFunctionToolDto)
	if err := json.Unmarshal(data, &valueCreateFunctionToolDto); err == nil {
		x.typ = "CreateFunctionToolDto"
		x.CreateFunctionToolDto = valueCreateFunctionToolDto
		return nil
	}
	valueCreateGhlToolDto := new(CreateGhlToolDto)
	if err := json.Unmarshal(data, &valueCreateGhlToolDto); err == nil {
		x.typ = "CreateGhlToolDto"
		x.CreateGhlToolDto = valueCreateGhlToolDto
		return nil
	}
	valueCreateMakeToolDto := new(CreateMakeToolDto)
	if err := json.Unmarshal(data, &valueCreateMakeToolDto); err == nil {
		x.typ = "CreateMakeToolDto"
		x.CreateMakeToolDto = valueCreateMakeToolDto
		return nil
	}
	valueCreateTransferCallToolDto := new(CreateTransferCallToolDto)
	if err := json.Unmarshal(data, &valueCreateTransferCallToolDto); err == nil {
		x.typ = "CreateTransferCallToolDto"
		x.CreateTransferCallToolDto = valueCreateTransferCallToolDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, x)
}

func (x XaiModelToolsItem) MarshalJSON() ([]byte, error) {
	if x.typ == "CreateDtmfToolDto" || x.CreateDtmfToolDto != nil {
		return json.Marshal(x.CreateDtmfToolDto)
	}
	if x.typ == "CreateEndCallToolDto" || x.CreateEndCallToolDto != nil {
		return json.Marshal(x.CreateEndCallToolDto)
	}
	if x.typ == "CreateVoicemailToolDto" || x.CreateVoicemailToolDto != nil {
		return json.Marshal(x.CreateVoicemailToolDto)
	}
	if x.typ == "CreateFunctionToolDto" || x.CreateFunctionToolDto != nil {
		return json.Marshal(x.CreateFunctionToolDto)
	}
	if x.typ == "CreateGhlToolDto" || x.CreateGhlToolDto != nil {
		return json.Marshal(x.CreateGhlToolDto)
	}
	if x.typ == "CreateMakeToolDto" || x.CreateMakeToolDto != nil {
		return json.Marshal(x.CreateMakeToolDto)
	}
	if x.typ == "CreateTransferCallToolDto" || x.CreateTransferCallToolDto != nil {
		return json.Marshal(x.CreateTransferCallToolDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", x)
}

type XaiModelToolsItemVisitor interface {
	VisitCreateDtmfToolDto(*CreateDtmfToolDto) error
	VisitCreateEndCallToolDto(*CreateEndCallToolDto) error
	VisitCreateVoicemailToolDto(*CreateVoicemailToolDto) error
	VisitCreateFunctionToolDto(*CreateFunctionToolDto) error
	VisitCreateGhlToolDto(*CreateGhlToolDto) error
	VisitCreateMakeToolDto(*CreateMakeToolDto) error
	VisitCreateTransferCallToolDto(*CreateTransferCallToolDto) error
}

func (x *XaiModelToolsItem) Accept(visitor XaiModelToolsItemVisitor) error {
	if x.typ == "CreateDtmfToolDto" || x.CreateDtmfToolDto != nil {
		return visitor.VisitCreateDtmfToolDto(x.CreateDtmfToolDto)
	}
	if x.typ == "CreateEndCallToolDto" || x.CreateEndCallToolDto != nil {
		return visitor.VisitCreateEndCallToolDto(x.CreateEndCallToolDto)
	}
	if x.typ == "CreateVoicemailToolDto" || x.CreateVoicemailToolDto != nil {
		return visitor.VisitCreateVoicemailToolDto(x.CreateVoicemailToolDto)
	}
	if x.typ == "CreateFunctionToolDto" || x.CreateFunctionToolDto != nil {
		return visitor.VisitCreateFunctionToolDto(x.CreateFunctionToolDto)
	}
	if x.typ == "CreateGhlToolDto" || x.CreateGhlToolDto != nil {
		return visitor.VisitCreateGhlToolDto(x.CreateGhlToolDto)
	}
	if x.typ == "CreateMakeToolDto" || x.CreateMakeToolDto != nil {
		return visitor.VisitCreateMakeToolDto(x.CreateMakeToolDto)
	}
	if x.typ == "CreateTransferCallToolDto" || x.CreateTransferCallToolDto != nil {
		return visitor.VisitCreateTransferCallToolDto(x.CreateTransferCallToolDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", x)
}
